# 策略模块

## 一、搭建策略模块

创建beacon-strategy工程：……

导入依赖：

```xml
<dependencies>
    <!--        start-web-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--        nacos-dis-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--        nacos-config-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--        公共组件，common-->
    <dependency>
        <groupId>com.mashibing</groupId>
        <artifactId>beacon-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

构建启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class StrategyStarterApp {

    public static void main(String[] args) {
        SpringApplication.run(StrategyStarterApp.class,args);
    }

}
```

编写配置文件，并导入到Nacos

```yml
# 服务名称
spring:
  application:
    name: beacon-strategy
# 多环境
  profiles:
    active: dev
# nacos注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 114.116.226.76:8848
      # nacos配置中心地址:
      config:
        server-addr: 114.116.226.76:8848
        file-extension: yml
        # beacon-api-dev.yml
# ===========================Nacos配置中心=======================================
# 端口号
server:
  port: 10003
```

启动测试：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/21e620ac6dd24600afe934e1e7f3de34.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/5aaa528b6cf64724821358b49fee83f0.png)

## 二、接收接口模块的消息

导入依赖

```xml
<!--        RabbitMQ依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

编写配置文件-链接RabbitMQ

```yml
spring: 
# rabbitMQ连接信息
  rabbitmq:
    host: 114.116.226.76
    port: 5672
    username: root
    password: ZhengJinWei123!
    virtual-host: /  
```

编写消费者，接收消息

```java
@Component
@Slf4j
public class PreSendListener {

    @RabbitListener(queues = RabbitMQConstants.SMS_PRE_SEND)
    public void listen(StandardSubmit submit) throws IOException {
        log.info("【策略模块-接收消息】 接收到接口模块发送的消息 submit = {}",submit);
        // 处理业务…………
    }
}
```

编写配置文件-手动ack

```yml
spring: 
# rabbitMQ连接信息
  rabbitmq:
    host: 114.116.226.76
    port: 5672
    username: root
    password: ZhengJinWei123!
    virtual-host: /  
    listener:
      simple:
        # 开启手动ack
        acknowledge-mode: manual
```

编写消费者，手动ack

```java
@Component
@Slf4j
public class PreSendListener {

    @RabbitListener(queues = RabbitMQConstants.SMS_PRE_SEND)
    public void listen(StandardSubmit submit, Message message, Channel channel) throws IOException {
        log.info("【策略模块-接收消息】 接收到接口模块发送的消息 submit = {}",submit);
        // 处理业务…………



        log.info("【策略模块-消费完毕】手动ack");
        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);
    }
}
```

## 三、实现校验链

这个功能和接口模块的校验类，都需要让所有的校验功能相互解耦。

之前接口模块是基于Nacos的动态配置去实现的。

在策略模块中，客户是可以指定一些校验是否需要执行，并且更换校验顺序的。

需要基于客户信息中存储的client_filters字段中存储的顺序去执行。

导入依赖：

```xml
<!--        openFeign-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

启动类追加注解： **@EnableFeignClients**

编写BeaconCacheClient：

```java
@FeignClient(value = "beacon-cache")
public interface BeaconCacheClient {

    @GetMapping("/cache/hget/{key}/{field}")
    String hget(@PathVariable(value = "key")String key, @PathVariable(value = "field")String field);
}
```

构建校验对象：

* 接口
  ```java
  public interface StrategyFilter {

      /**
       * 校验！！！！
       * @param submit
       */
      void strategy(StandardSubmit submit);
  }
  ```
* 实现类
  ```java
  @Service(value = "black")
  @Slf4j
  public class BlackStrategyFilter implements StrategyFilter {
      @Override
      public void strategy(StandardSubmit submit) {
          log.info("【策略模块-黑名单校验】   校验ing…………");
      }
  }
  ```

准备责任链的Context：

```java
@Component
@Slf4j
public class StrategyFilterContext {

    // 泛型注入，拿到所有的校验信息。
    @Autowired
    private Map<String,StrategyFilter> stringStrategyFilterMap;

    // 注入CacheClient
    @Autowired
    private BeaconCacheClient cacheClient;

    private final String CLIENT_FILTERS = "clientFilters";


    /**
     * 当前check方法用于管理校验链的顺序
     */
    public void strategy(StandardSubmit submit) {
        //1、 基于Redis获取客户对应的校验信息
        String filters = cacheClient.hget(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), CLIENT_FILTERS);

        //2、健壮性校验后，基于逗号分隔遍历
        String[] filterArray;
        if(filters != null && (filterArray = filters.split(",")).length > 0){
            // 到这，filterArray不为null，并且有数据
            for (String strategy : filterArray) {
                //3、 遍历时，从stringStrategyFilterMap中获取到需要执行的校验信息，执行
                StrategyFilter strategyFilter = stringStrategyFilterMap.get(strategy);
                if(strategyFilter != null){
                    strategyFilter.strategy(submit);
                }
            }
        }
    }

}
```

完善消费者代码：

```java
@Component
@Slf4j
public class PreSendListener {


    /**
     * 整个策略模块的校验
     */
    @Autowired
    private StrategyFilterContext filterContext;

    @RabbitListener(queues = RabbitMQConstants.SMS_PRE_SEND)
    public void listen(StandardSubmit submit, Message message, Channel channel) throws IOException {
        log.info("【策略模块-接收消息】 接收到接口模块发送的消息 submit = {}",submit);
        // 处理业务…………
        try {
            filterContext.strategy(submit);
            log.info("【策略模块-消费完毕】手动ack");
            channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);
        } catch (IOException e) {
            e.printStackTrace();
            log.error("【策略模块-消费失败】凉凉~~~");
        }
    }
}
```

测试效果：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/2c3b4c005d284a9dafe426ff14992104.png)

## 四、号段补全

为了在做进一步校验之前，需要将手机号的归属地以及对应的运营商查询出来，并且封装到StandardSubmit

手机号的归属地如何获取：基于手机号的前7位获取对应的运营商信息

数据库中的mobile_area中存储了大量的手机号对应的归属于以及运营商信息

为了提升效率，需要将mobile_area表中的50W条左右的数据同步到Redis缓存

可能会出现手机号前7位无法获取到指定的归属地和运营商的信息，需要基于第三方做查询，再将查询到的数据同步到数据库（发送消息）。第一次同步数据，花费的时间会长一些。

### 4.1 同步数据到Redis

缓存模块需要对外提供一个基于pipeline的接口，可以接收大量的key-value，一次性的存储到Redis中。

CacheController中提供的接口

```java
@PostMapping("/cache/pipeline/string")
public void pipelineString(@RequestBody Map<String,String> map){
    log.info("【缓存模块】 pipelineString，获取到存储的数据，map的长度 ={}的数据", map.size());
    redisClient.pipelined(operations -> {
        for (Map.Entry<String, String> entry : map.entrySet()) {
            operations.opsForValue().set(entry.getKey(),entry.getValue());
        }
    });
}
```

在test中，将数据同步到Redis里。最终同步到44W条数据左右，内存中大致占用了0.04G。

```java
@Test
public void findAll() {
    List<MobileArea> list = mapper.findAll();
    Map map = new HashMap(list.size());
    for (MobileArea mobileArea : list) {
        map.put("phase:" + mobileArea.getMobileNumber(),mobileArea.getMobileArea() + "," + mobileArea.getMobileType());
    }
    cacheClient.pipelineString(map);
}
```

内存占用情况：

写入数据之前：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/85240679251c4fed9a038460954187c6.png)

写入数据之后：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/1af32e078bfa4bb7b54ea0587b5261d1.png)

### 4.2 完成号段补全

首先需要基于submit中存储的手机号，去缓存模块查询对应的区域以及运营商信息

如果查询不到，需要通过发送请求的方式，请求 `https://cx.shouji.360.cn/phonearea.php?number=1388888` 地址查询手机号对应的区域以及运营商信息，同时还需要发送消息到 短信管理平台模块 同步信息到MySQL，同时还需要同步到Redis中。

如果查询到，正常封装到StandardSubmit对象中

```java
/**
 * 号段补全：获取手机号的运营商以及对应的归属地
 *
 * @author zjw
 * @description
 */
@Service(value = "phase")
@Slf4j
public class PhaseStrategyFilter implements StrategyFilter {

    /**
     * 切分手机号前7位
     */
    private final int MOBILE_START = 0;
    private final int MOBILE_END = 7;
    /**
     * 校验的长度
     */
    private final int LENGTH = 2;
    /**
     * 分割区域和运营商的标识
     */
    private final String SEPARATE = ",";
    /**
     * 未知的情况
     */
    private final String UNKNOWN = "未知 未知,未知";

    @Autowired
    private BeaconCacheClient cacheClient;

    @Autowired
    private MobileOperatorUtil mobileOperatorUtil;

    @Autowired
    private RabbitTemplate rabbitTemplate;


    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-号段补齐】   补全ing…………");
        //1、根据手机号前7位，查询手机号信息
        String mobile = submit.getMobile().substring(MOBILE_START, MOBILE_END);
        String mobileInfo = cacheClient.getString(CacheConstant.PHASE + mobile);

        getMobileInfo: if (StringUtils.isEmpty(mobileInfo))  {
            //2、查询不到，需要调用三方接口，查询手机号对应信息
            mobileInfo = mobileOperatorUtil.getMobileInfoBy360(mobile);
            if(!StringUtils.isEmpty(mobileInfo)){
                //3、调用三方查到信息后，发送消息到MQ，并且同步到MySQL和Redis
                rabbitTemplate.convertAndSend(RabbitMQConstants.MOBILE_AREA_OPERATOR,submit.getMobile());
                break getMobileInfo;
            }
            mobileInfo = UNKNOWN;
        }

        //4、无论是Redis还是三方接口查询到之后，封装到StandardSubmit对象中
        String[] areaAndOperator = mobileInfo.split(SEPARATE);
        if (areaAndOperator.length == LENGTH) {
            submit.setArea(areaAndOperator[0]);
            submit.setOperatorId(OperatorUtil.getOperatorIdByOperatorName(areaAndOperator[1]));
        }

    }
}
```

## 五、敏感词的校验

这里就是针对发送的短信内容做敏感词的匹配校验。

短信内容分为通知类，营销类。这两种都需要校验。

同时整个策略就是将短信内容进行分词，基于IK分词器对短信内容进行分词。

将分词出来的内容通过数据库存储的数据进行匹配。

数据库效率比较低，将数据扔到Redis中存储。

方式一：将敏感词内容作为key，同步到Redis中，将短信内容分词后，基于get方法去Redis中做匹配，如果有匹配上的内容，直接就无法通过敏感词校验。

方式一的缺点比较明显，如果短信文字比较多，OpenFeign的IO成本还有Redis的IO成本都是比较高。这种方式可以实现功能，但是效率一般。

方式二：将敏感词整理为Set集合，存储到Redis的Set结构中。在做校验时，可以将短信内容进行分词，将分词的内容整理为Set集合存储到Redis的Set结构中。将短信内容的Set集合与敏感词的Set集合做交集操作，如果交集后有内容，证明有敏感词的。如果交集后，返回了一个空的Set，证明没有交集。

方式二，最多有两次网络IO。但是效率相比方式一高很多。所有敏感词需要存储在一个key中，如果敏感词内容比较多，可能会造成数据的倾斜，大量的数据都存储在了一个Redis节点中。（可以解决）

### 5.1 同步敏感词到Redis

首先给缓存模块Cache提供一个添加字符串到set结构的接口

```java
@PostMapping(value = "/cache/saddstr/{key}")
public void saddStr(@PathVariable(value = "key")String key, @RequestBody String... value){
    log.info("【缓存模块】 saddStr方法，存储key = {}，存储value = {}", key, value);
    redisClient.sAdd(key,value);
}
```

在test中，讲数据库中的数据同步到Redis中

```java
@Select("select dirtyword from mobile_dirtyword")
List<String> findDirtyWord();

@Test
public void findAll() {
    List<String> dirtyWords = mapper.findDirtyWord();

    cacheClient.saddStr("dirty_word",dirtyWords.toArray(new String[]{}));
}
```

### 5.2 基于Redis的交集操作实现

第一点：Redis完成交集操作，至少需要两个操作。

* 需要将分词后的短信内容添加到Redis的Set结构中
* 将短信内容和敏感词的set进行sinter交集操作

但是，存储的短信内容，需要在执行完毕交集操作后，删除掉。

需要让缓存模块提供这种交集操作：增，交，删

```java
@PostMapping(value = "/cache/sinterstr/{key}/{sinterKey}")
public Set<Object> sinterStr(@PathVariable(value = "key")String key, @PathVariable String sinterKey,@RequestBody String... value){
    log.info("【缓存模块】 sinterStr的交集方法，存储key = {}，sinterKey = {}，存储value = {}", key, sinterKey,value);
    //1、 存储数据到set集合
    redisClient.sAdd(key,value);
    //2、 需要将key和sinterKey做交集操作，并拿到返回的set（RedisClient没提供，自己写的~~）
    Set<Object> result = redisTemplate.opsForSet().intersect(key, sinterKey);
    //3、 将key删除
    redisClient.delete(key);
    //4、 返回交集结果
    return result;
}
```

第二点：策略模块需要将短信内容进行分词。选择IK分词器对短信内容进行分词，将分词好的短信内容存储到一个集合中，去调用上面提供的增，交，删操作，得到一个返回的set集合。基于返回的set集合判断当前短信内容是否包含敏感词。

```java
@Service(value = "dirtyword")
@Slf4j
public class DirtyWordStrategyFilter implements StrategyFilter {

@Autowired
private BeaconCacheClient cacheClient;

@Override
public void strategy(StandardSubmit submit) {
    log.info("【策略模块-敏感词校验】   校验ing…………");
    //1、 获取短信内容
    String text = submit.getText();

    //2、 对短信内容进行分词，并且将分析内容存储到集合中
    Set<String> contents = new HashSet<>();
    StringReader reader = new StringReader(text);
    IKSegmenter ik = new IKSegmenter(reader,false);
    Lexeme lex = null;
    while(true){
        try {
            if ((lex = ik.next()) == null) break;
        } catch (IOException e) {
            log.info("【策略模块-敏感词校验】   IK分词器在处理短信内容时，出现异常 e = {}" ,e.getMessage());
        }
        contents.add(lex.getLexemeText());
    }


    //3、 调用Cache缓存模块的交集方法，拿到结果

    Set<Object> dirtyWords = cacheClient.sinterStr(UUID.randomUUID().toString(), CacheConstant.DIRTY_WORD, contents.toArray(new String[]{}));

    //4、 根据返回的set集合，判断是否包含敏感词
    if(dirtyWords != null && dirtyWords.size() > 0){
        //5、 如果有敏感词，抛出异常 / 其他操作。。
        log.info("【策略模块-敏感词校验】   短信内容包含敏感词信息， dirtyWords = {}",dirtyWords);
        // 还需要做其他处理
    }
}
```

发现了一个问题：IK分词器在将短信内容传入到IKSegmenter时，速度有点慢…………

### 5.3 基于DFA算法实现敏感词过滤

文本反垃圾算法，有很多可以实现的方式：

* DFA算法（有穷自动机）……
* AC自动机

DFA算法过滤敏感词的方式，基本不需要和Redis交互，也不需要使用分词器，效率会有大大滴提升。

#### 5.3.1 将敏感词存储成敏感词树

需要将敏感词库中的信息存储成下图的效果

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/8f28bac85621464aabd50b57646d40ba.png)

基于代码实现，将一个存储敏感词的集合，生成为一个敏感词树

```java
public class DFAUtil {
// 敏感词树
private static Map dfaMap = new HashMap<>();

private static final String IS_END = "isEnd";

public static void main(String[] args) {
    // 敏感词库
    Set<String> dirtyWords = new HashSet<>();
    dirtyWords.add("三胖");
    dirtyWords.add("山炮");
    dirtyWords.add("三胖啊啊");
    dirtyWords.add("三胖啊啊");
    // 测试敏感词树的生成
    create(dirtyWords);
    // 输出结果
    for (Object o : dfaMap.entrySet()) {
        System.out.println(o);
    }
}


    public static void create(Set<String> dirtyWords){
        //1、 声明一个Map作为临时存储
        Map nowMap;

        //2、遍历敏感词库
        for (String dirtyWord : dirtyWords) {
            nowMap = dfaMap;
            // 每个词，依次获取
            for (int i = 0; i < dirtyWord.length(); i++) {
                // 获取敏感词的每个字
                String word = String.valueOf(dirtyWord.charAt(i));
                // 判断当前的敏感词树中是否包含当前的字
                Map map = (Map) nowMap.get(word);
                if(map == null){
                    // 当前敏感词树中没有这个字
                    map = new HashMap();
                    // 将当前的敏感词存入
                    nowMap.put(word,map);
                }
                // 操作当前key对应的value的map
                nowMap = map;
                // 如果当前的字，已经有IS_END了，并且值为1，直接不管，
                if(nowMap.containsKey(IS_END) && nowMap.get(IS_END).equals("1")){
                    continue;
                }
                // 如果当前的isEnd没有，或者是0，需要考虑需要改为1
                if(i == dirtyWord.length() - 1){
                    // 到最后一个字了。
                    nowMap.put(IS_END,"1");
                }else{
                    // isEnd之前就是0，或者压根就没有isEnd
                    nowMap.putIfAbsent(IS_END,"0");
                }
            }
        }
    }

}
```

#### 5.3.2 基于敏感词树实现敏感词校验

其实就是将短信内容一个一个的将字拿到。

拿到后，先基于最外层的key进行匹配，如果匹配上了，继续向内部的key匹配，

* 如果匹配到的k的isEnd是1，说明和敏感词对应上了，下次就跳到敏感词的后面继续匹配外层key
* 如果匹配到最后，没有k的isEnd是0，说明没匹配上。下次就从第二个字继续匹配

```java
public class DFAUtil {
    // 敏感词树
    private static Map dfaMap = new HashMap<>();

    private static final String IS_END = "isEnd";

    public static void main(String[] args) {
        // 敏感词库
        Set<String> dirtyWords = new HashSet<>();
        dirtyWords.add("三胖");
        dirtyWords.add("山炮");
        dirtyWords.add("三胖啊啊");
        dirtyWords.add("瘦啊");
        // 测试敏感词树的生成
        create(dirtyWords);
        // 测试效果
        String text = "你三瘦啊山炮";
        System.out.println(getDirtyWord(text));
    }

    /**
     * 构建敏感词树
     * @param dirtyWords
     */
    public static void create(Set<String> dirtyWords) {
        //1、 声明一个Map作为临时存储
        Map nowMap;

        //2、遍历敏感词库
        for (String dirtyWord : dirtyWords) {
            nowMap = dfaMap;
            // 每个词，依次获取
            for (int i = 0; i < dirtyWord.length(); i++) {
                // 获取敏感词的每个字
                String word = String.valueOf(dirtyWord.charAt(i));
                // 判断当前的敏感词树中是否包含当前的字
                Map map = (Map) nowMap.get(word);
                if (map == null) {
                    // 当前敏感词树中没有这个字
                    map = new HashMap();
                    // 将当前的敏感词存入
                    nowMap.put(word, map);
                }
                // 操作当前key对应的value的map
                nowMap = map;
                // 如果当前的字，已经有IS_END了，并且值为1，直接不管，
                if (nowMap.containsKey(IS_END) && nowMap.get(IS_END).equals("1")) {
                    continue;
                }
                // 如果当前的isEnd没有，或者是0，需要考虑需要改为1
                if (i == dirtyWord.length() - 1) {
                    // 到最后一个字了。
                    nowMap.put(IS_END, "1");
                } else {
                    // isEnd之前就是0，或者压根就没有isEnd
                    nowMap.putIfAbsent(IS_END, "0");
                }
            }
        }
    }

    /**
     * 基于敏感词树，对文字进行敏感词获取
     * @param text
     * @return
     */
    public static Set<String> getDirtyWord(String text) {
        // 1、作为返回结果存储敏感词的位置
        Set<String> dirtyWords = new HashSet<>();
        // 2、循环遍历文本内容
        for (int i = 0; i < text.length(); i++) {
            // 临时存储索引位置的变量
            int nextLength = 0;
            int dirtyLength = 0;
            // 获取最外层key的map
            Map nowMap = dfaMap;
            // 外层是索引向后动，匹配最外层的key
            // 内层是在匹配上一个后，继续向内部匹配内部的key
            for (int j = i; j < text.length(); j++) {
                // 获取当前索引位置的字
                String word = String.valueOf(text.charAt(j));
                // 先匹配最外层的key
                nowMap = (Map) nowMap.get(word);
                // 判断
                if (nowMap == null) {
                    // 没有这个字开头的敏感词
                    break;
                } else {
                    // 敏感词长度，从i开始算，现在的是dirtyLength
                    dirtyLength++;
                    // 出口即是，当前的map的isEnd是1，代表结束了。已经找到完整的敏感词
                    if ("1".equals(nowMap.get(IS_END))) {
                        // 代表敏感词匹配到一个完整的
                        nextLength = dirtyLength;
                        break;
                    }
                }

            }
            // 判断是否匹配上了敏感词
            if (nextLength > 0) {
                // 匹配上了，添加敏感词到set，同时移动外层索引
                dirtyWords.add(text.substring(i, i + nextLength));
                // -1的原因是，外层for循环，会对i进行++
                i = i + nextLength - 1;
            }
        }
        // 返回
        return dirtyWords;
    }
}
```

#### 5.3.3 将DFA应用到敏感词过滤

现在的敏感词都放在了Redis里，其实在使用DFA之后，可以将敏感词放到本地的文本中，通过IO流去读。

但是咱们现在就先基于Redis存储的方式去将敏感词加载到策略模块中，并生成敏感词树，做校验。

首先是将DFAUtil做一个初始化，在项目启动的时候，基于CacheClient去查询缓存中的全部敏感词信息，然后基于DFAUtil中的create方法，生成敏感词树（SpringUtil是从Spring容器中获取对象）

```java
@Component
public class SpringUtil implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringUtil.applicationContext = applicationContext;
    }

    public static Object getBeanByName(String beanName){
        return SpringUtil.applicationContext.getBean(beanName);
    }

    public static Object getBeanByClass(Class clazz){
        return SpringUtil.applicationContext.getBean(clazz);
    }
}
/**
 * 初始化敏感词树
 */
static {
    // 获取Spring容器中的cacheClient
    BeaconCacheClient cacheClient = (BeaconCacheClient) SpringUtil.getBeanByClass(BeaconCacheClient.class);
    // 获取存储在Redis中的全部敏感词
    Set<String> dirtyWords = cacheClient.smember(CacheConstant.DIRTY_WORD);
    // 调用create，将dfaMap的敏感词树构建
    create(dirtyWords);
}
```

直接在策略模块的过滤器中，再实现一个敏感词校验的Filter，这次是基于DFAUtil实现的

```java
@Service(value = "dfaDirtyWord")
@Slf4j
public class DirtyWordDFAStrategyFilter implements StrategyFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-敏感词校验】   校验ing…………");
        //1、 获取短信内容
        String text = submit.getText();

        //2、 调用DFA查看敏感词
        Set<String> dirtyWords = DFAUtil.getDirtyWord(text);

        //4、 根据返回的set集合，判断是否包含敏感词
        if (dirtyWords != null && dirtyWords.size() > 0) {
            //5、 如果有敏感词，抛出异常 / 其他操作。。
            log.info("【策略模块-敏感词校验】   短信内容包含敏感词信息， dirtyWords = {}", dirtyWords);
            // 还需要做其他处理
        }
    }
}
```

在测试之前，记得将客户的clientFilters属性调整一下

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/9d31dc65c8594768b76eafec6be4c710.png)

### 5.4 基于Hutool实现敏感词过滤

Hutool是国内现在很流行的一个工具类，类似Commons-lang3这种大型的工具了，内部封装了很多常用的功能，直接导入依赖使用即可~

导入依赖

```xml
<!--        导入hutool工具类-->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-dfa</artifactId>
    <version>5.8.12</version>
</dependency>
```

编写工具类

```java
public class HutoolDFAUtil {

    private static WordTree wordTree = new WordTree();

    /**
     * 初始化敏感词树
     */
    static {
        // 获取Spring容器中的cacheClient
        BeaconCacheClient cacheClient = (BeaconCacheClient) SpringUtil.getBeanByClass(BeaconCacheClient.class);
        // 获取存储在Redis中的全部敏感词
        Set<String> dirtyWords = cacheClient.smember(CacheConstant.DIRTY_WORD);
        // 调用WordTree的add方法，将dfaMap的敏感词树构建
        wordTree.addWords(dirtyWords);
    }


    public static List<String> getDirtyWord(String text){
        return wordTree.matchAll(text);
    }

}
```

在Filter中应用

```java
@Service(value = "hutoolDFADirtyWord")
@Slf4j
public class DirtyWordHutoolDFAStrategyFilter implements StrategyFilter {


    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-敏感词校验】   校验ing…………");
        //1、 获取短信内容
        String text = submit.getText();

        //2、 调用DFA查看敏感词
        List<String> dirtyWords = HutoolDFAUtil.getDirtyWord(text);

        //4、 根据返回的set集合，判断是否包含敏感词
        if (dirtyWords != null && dirtyWords.size() > 0) {
            //5、 如果有敏感词，抛出异常 / 其他操作。。
            log.info("【策略模块-敏感词校验】   短信内容包含敏感词信息， dirtyWords = {}", dirtyWords);
            // 还需要做其他处理
        }
    }
}
```

**Ps：后期当敏感词做了写操作后，需要同步到Redis，并且通知策略模块，针对WordTree做修改**

## 六、校验失败后操作

在策略模块中，一些校验没有通过，无法正常发送短信时，需要做三件事情：

* 在策略模块中，有一套校验的策略链，如果一些校验无法通过，就不需要继续执行后续的校验操作了，让策略上下文中的校验直接结束。
* 当校验无法通过时，短信无法正常发送，需要将短信的信息全部存储到Elasticsearch中，可以给用户提供查询的位置，并且Elasticsearch做统计报表功能也是比较强的，而且Elasticsearch存储的数据量比较大。
* 当校验无法通过时，短信无法正常发送，需要根据情况给用户推送一个状态报告

### 6.1 抛出异常

需要在common组件中声明一个针对策略模块的异常对象，同时在ExceptionEnums枚举中提供对应的异常的code以及msg即可。

自定义异常

```java
@Getter
public class StrategyException extends RuntimeException {

    private Integer code;

    public StrategyException(String message, Integer code) {
        super(message);
        this.code = code;
    }


    public StrategyException(ExceptionEnums enums) {
        super(enums.getMsg());
        this.code = enums.getCode();
    }

}

```

记得在ExceptionEnums中声明好对应的错误码和错误信息。

在敏感词校验的后续中，抛出异常即可

```java
throw new StrategyException(ExceptionEnums.HAVE_DIRTY_WORD);
```

同时在MQ接收消息的位置，单独的捕获StrategyException异常，记录info日志即可。

### 6.2 发送写日志消息

需要将submit的信息发送到RabbitMQ中，后续让搜索模块接收这个消息，并且完成数据的保存即可。

在发送消息submit之前，需要先设置好以下信息

* reportState：将当前短信状态设置为发送失败
* errorMsg：短信发送失败的原因是什么

排查属性，以下内容需要补全：

* sendTime：短信发送的时间，在接口模块发送消息之前，设置好sendTime

补全前面的两个信息

```java
// 封装错误信息
submit.setErrorMsg(ExceptionEnums.HAVE_DIRTY_WORD.getMsg() + "dirtyWords = " + dirtyWords.toString());
submit.setReportState(SmsConstant.REPORT_FAIL);
```

将submit作为消息发送到RabbitMQ即可。

* 先准备一个写日志的队列名称。
  ```
  /**
   * 写日志到Elasticsearch的队列
   */
  String SMS_WRITE_LOG = "sms_write_log_topic";
  ```
* 构建这个写日志队列
  ```
  /**
   * 写日志的队列。
   * @return
   */
  @Bean
  public Queue writeLogQueue(){
      return QueueBuilder.durable(RabbitMQConstants.SMS_WRITE_LOG).build();
  }

  ```
* 将消息发送完成
  ```
  rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_WRITE_LOG,submit);
  ```

### 6.3 发送状态报告消息

分析了一下，不需要将submit对象作为状态报告推送的消息，敏感数据比较多。

再次构建了一个Report对象作为状态报告推送的对象

```java
/**
 * 状态报告推送等操作时的类
 * @author zjw
 * @description
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StandardReport implements Serializable {

    /**
     * 针对当前短信的唯一标识，雪花算法（保留）
     */
    private Long sequenceId;

    /**
     * 客户端ID，基于apikey查询缓存模块得到客户的ID
     */
    private Long clientId;


    /**
     * 客户业务内的uid，客户请求传递的
     */
    private String uid;

    /**
     * 目标手机号，客户请求传递的
     */
    private String mobile;

    /**
     * 短信的发送时间，当前系统时间
     */
    private LocalDateTime sendTime;

    /**
     * 短信的发送状态， 0-等待/发送ing，1-成功，2-失败 ，默认情况就是0
     */
    private int reportState;

    /**
     * 短信发送失败的原因是什么，记录在当前属性
     */
    private String errorMsg;

    /**
     *  回调的信息
     */
    private Integer isCallback;
    private String callbackUrl;

}
```

客户是否需要回调，需要根据客户信息中的isCallback确认是否需要发送状态报告的推送

要在发送消息前，先获取客户的isCallback，如果需要发送，再查询客户的callbackUrl，同时封装好Report对象的其他信息，全部封装好之后，发送到指定的队列中即可。

```java
if (dirtyWords != null && dirtyWords.size() > 0) {
    //5、 如果有敏感词，抛出异常 / 其他操作。。
    log.info("【策略模块-敏感词校验】   短信内容包含敏感词信息， dirtyWords = {}", dirtyWords);
    // 封装错误信息
    // ================================发送写日志================================
    submit.setErrorMsg(ExceptionEnums.HAVE_DIRTY_WORD.getMsg() + "dirtyWords = " + dirtyWords.toString());
    submit.setReportState(SmsConstant.REPORT_FAIL);
    // 发送消息到写日志队列
    rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_WRITE_LOG,submit);

    // ================================发送状态报告的消息前，需要将report对象数据封装================================
    // 查询当前客户的isCallback
    Integer isCallback = cacheClient.hgetInteger(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), "isCallback");
    // 查看是否需要给客户一个回调
    if(isCallback == 1){
        // 如果需要回调，再查询客户的回调地址
        String callbackUrl = cacheClient.hget(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), "callbackUrl");
        // 如果回调地址不为空。
        if(!StringUtils.isEmpty(callbackUrl)){
            // 封装客户的报告推送的信息，开始封装StandardReport
            StandardReport report = new StandardReport();
            BeanUtils.copyProperties(submit,report);
            report.setIsCallback(isCallback);
            report.setCallbackUrl(callbackUrl);
            // 发送消息到RabbitMQ
            rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_PUSH_REPORT,report);
        }

    }
    // // ================================抛出异常================================
    throw new StrategyException(ExceptionEnums.HAVE_DIRTY_WORD);

}
```

### 6.4 将方法进行二次封装

将发送写日志的消息以及发送状态报告的消息的两个方法，单独抽取出来进行封装

后续的黑名单，限流等等校验如果失败，也需要完成上述的三个操作。

```java
@Component
public class ErrorSendMsgUtil {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private BeaconCacheClient cacheClient;

    /**
     * 策略模块校验未通过，发送写日志操作
     * @param submit
     * @param dirtyWords
     */
    public void sendWriteLog(StandardSubmit submit, List<String> dirtyWords) {
        submit.setErrorMsg(ExceptionEnums.HAVE_DIRTY_WORD.getMsg() + "dirtyWords = " + dirtyWords.toString());
        submit.setReportState(SmsConstant.REPORT_FAIL);
        // 发送消息到写日志队列
        rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_WRITE_LOG,submit);
    }

    /**
     * 策略模块校验未通过，发送状态报告操作
     */
    public void sendPushReport(StandardSubmit submit) {
        // 查询当前客户的isCallback
        Integer isCallback = cacheClient.hgetInteger(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), "isCallback");
        // 查看是否需要给客户一个回调
        if(isCallback == 1){
            // 如果需要回调，再查询客户的回调地址
            String callbackUrl = cacheClient.hget(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), "callbackUrl");
            // 如果回调地址不为空。
            if(!StringUtils.isEmpty(callbackUrl)){
                // 封装客户的报告推送的信息，开始封装StandardReport
                StandardReport report = new StandardReport();
                BeanUtils.copyProperties(submit,report);
                report.setIsCallback(isCallback);
                report.setCallbackUrl(callbackUrl);
                // 发送消息到RabbitMQ
                rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_PUSH_REPORT,report);
            }

        }
    }
}
```

## 七、黑名单校验

黑名单分为平台级别黑名单和客户级别的黑名单、

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/ebfa6652401a4a4297b296f1d893dae4.png)

**客户黑名单** 就是客户产品中的黑名单信息，一般就是短信退订得到的信息，根据后台管理模块接收到运营商发来的退订信息，将的当前手机号作为客户黑名单，重新订阅也需要用户自行去找客户取消，然后在由客户将信息同步到平台。

**平台黑名单** ，是从运营商得到的信息，如果号主发送了包含一些电信行业违规的措辞，就会列入短信黑名单，这个需要号主主动的去找运营商的营业厅去取消黑名单。所以短信平台需要定时去运营商查询，当前的平台级别的黑名单中是否有取消的黑名单信息。

为了策略模块的效率，黑名单信息依然要存储到Redis中一份。

直接将黑名单手机号存储到Redis中作为key

* 平台级别：black:手机号   作为key，value存储1就ok
* 客户级别：black:clientId:手机号   作为key，value存储1就ok

在对应的策略模块中，直接拿到客户手机号，拼接好key，直接去Redis中执行get即可，如果匹配的value不为1，就不是黑名单，可以正常发送，如果是黑名单，直接走校验失败后的三个操作。

### 7.1 同步数据到Redis

直接查询数据库中的mobile_black表的全部数据

然后基于clientId是否为0，决定当前黑名单是什么级别的。

根据不同的级别设置不同的key。存储到Redis即可

```java
public interface MobileBlackMapper {

    @Select("select black_number,client_id from mobile_black where is_delete = 0")
    List<MobileBlack> findAll();

}
// =========================================
@SpringBootTest
@RunWith(SpringRunner.class)
public class MobileBlackMapperTest {

    @Autowired
    private MobileBlackMapper mapper;

    @Autowired
    private CacheClient cacheClient;


    @Test
    public void findAll() {
        List<MobileBlack> mobileBlackList = mapper.findAll();
        for (MobileBlack mobileBlack : mobileBlackList) {
            if(mobileBlack.getClientId() == 0){
                // 平台级别的黑名单   black:手机号   作为key
                cacheClient.set("black:" + mobileBlack.getBlackNumber(),"1");
            }else{
                // 客户级别的黑名单   black:clientId:手机号
                cacheClient.set("black:" + mobileBlack.getClientId() + ":" +mobileBlack.getBlackNumber(),"1");
            }
        }
    }
}
```

### 7.2 黑名单校验

因为黑名单校验成本不高，直接两个一起写。

全局级别的黑名单：

```java
@Service(value = "blackGlobal")
@Slf4j
public class BlackGlobalStrategyFilter implements StrategyFilter {

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;

    @Autowired
    private BeaconCacheClient cacheClient;

    // 黑名单的默认value
    private final String TRUE = "1";

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-全局级别黑名单校验】   校验ing…………");
        //1、获取发送短信的手机号
        String mobile = submit.getMobile();

        //2、调用Redis查询
        String value = cacheClient.getString(CacheConstant.BLACK + mobile);

        //3、如果查询的结果为"1"，代表是黑名单
        if(TRUE.equals(value)){
            log.info("【策略模块-全局级别黑名单校验】   当前手机号是黑名单！ mobile = {}",mobile);
            submit.setErrorMsg(ExceptionEnums.BLACK_GLOBAL.getMsg() + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.BLACK_GLOBAL);
        }
        //4、不是1，正常结束
        log.info("【策略模块-全局级别黑名单校验】   当前手机号不是黑名单！");
    }
}
```

客户级别的黑名单：

```java
@Service(value = "blackClient")
@Slf4j
public class BlackClientStrategyFilter implements StrategyFilter {

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;

    @Autowired
    private BeaconCacheClient cacheClient;

    // 黑名单的默认value
    private final String TRUE = "1";

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-客户级别黑名单校验】   校验ing…………");
        //1、获取发送短信的手机号,以及客户的ID
        String mobile = submit.getMobile();
        Long clientId = submit.getClientId();

        //2、调用Redis查询
        String value = cacheClient.getString(CacheConstant.BLACK + clientId + CacheConstant.SEPARATE + mobile);

        //3、如果查询的结果为"1"，代表是黑名单
        if(TRUE.equals(value)){
            log.info("【策略模块-客户级别黑名单校验】   当前发送的手机号是客户黑名单！ mobile = {}",mobile);
            submit.setErrorMsg(ExceptionEnums.BLACK_CLIENT + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.BLACK_CLIENT);
        }
        //4、不是1，正常结束
        log.info("【策略模块-客户级别黑名单校验】   当前手机号不是客户黑名单！ ");
    }
}
```

## 八、携号转网校验

携号转网比较特殊，其实对于发送短信，一般来说，没什么影响。因为后期发送短息对接运营商的通道时，通道大多是都是全网通。也就是移动、联通、电信都可以在这个通道上实现短信的发送。

但是有一些特殊的通道，无法支持全网通，价格相对来说更便宜。

这个时候就需要考虑当前的手机号是否有携号转网的情况，如果存在，一定要设置正确的运营商，以保证在对接不支持全网通的通道时，可以正常的去发送短信。

这里的操作成本不高，只需要将表中的mobile_transfer中的携号转网的信息同步到Redis中，而且只同步is_transfer为1，也就是确认更换运营商的数据到Redis。 将手机号作为key，最终运营商设置为value存储到Redis即可。

### 8.1 同步数据到Redis

准备同步数据操作

```java
public interface MobileTransferMapper {

    @Select("select transfer_number,now_isp from mobile_transfer where is_transfer = 1 and is_delete = 0")
    List<MobileTransfer> findAll();

}
// ====================
@SpringBootTest
@RunWith(SpringRunner.class)
public class MobileTransferMapperTest {

    @Autowired
    private MobileTransferMapper mapper;

    @Autowired
    private CacheClient cacheClient;


    @Test
    public void findAll() {
        List<MobileTransfer> list = mapper.findAll();

        for (MobileTransfer mobileTransfer : list) {
            cacheClient.set("transfer:" + mobileTransfer.getTransferNumber(),mobileTransfer.getNowIsp());
        }
    }
}
```

### 8.2 携号转网校验

首先构建一波携号转网的策略链对象。

直接完成下述功能

```java
@Service(value = "transfer")
@Slf4j
public class TransferStrategyFilter implements StrategyFilter {

    // 代表携号转网了！
    private final Boolean TRANSFER = true;

    @Autowired
    private BeaconCacheClient cacheClient;

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-携号转网策略】   ing…………");
        //1、获取用户手机号
        String mobile = submit.getMobile();

        //2、直接基于Redis查询携号转网信息
        String value = cacheClient.getString(CacheConstant.TRANSFER + mobile);

        //3、如果存在携号转网，设置运营商信息
        if(!StringUtils.isEmpty(value)){
            // 代表携号转网了
            submit.setOperatorId(Integer.valueOf(value));
            submit.setIsTransfer(TRANSFER);
            log.info("【策略模块-携号转网策略】   当前手机号携号转网了！");
            return;
        }

        log.info("【策略模块-携号转网策略】   嘛事没有！");

    }
}
```

**Ps：测试的时候，记得将接口模块和策略模块都重启，因为修改了common中的submit对象。同时记得修改客户信息中的clientFilter**

## 九、验证码类短信做限流判断

限流一般是针对验证码短信做的。避免用户在恶意基于客户从短信平台发送和验证码。

虽然客户界面会有30s或者是60s不让重新发送的限制，但是后台依然需要做校验。同时短信平台也必须做一个限制，但是客户是否开启这个是客户的事。

为客户提供三个限流的规则。

* 同一客户针对同一手机号的验证码内容，60s只能获取一条短信。
* 同一客户针对同一手机号的验证码内容，1小时只能获取三条短信。
* 同一客户针对同一手机号的验证码内容，24小时只能发送10条短信。

需要将用户发送短信后的内容，存储到一个位置，需要存储客户信息，手机号信息和发送时间。

在存储之后，需要基于时间范围做一个查询，存储的位置必须提供时间范围的查询方式。

存储的方式，基本可以排除JVM内存，策略模块后期是需要搭建集群的，如果搭建了集群，JVM缓存中的数据无法在多个节点中实现同步。

其次是MySQL，从功能上来说，完全可以实现。MySQL毕竟相对来说并发能力比较差，一般也不会选择MySQL，因为性能会有影响。

最终还是要基于Redis去实现这个功能。可以基于Redis提供的ZSet结构来实现这个功能。

* ZSet结构可以存储key以及score和member
  * key：存储客户标记以及手机号
  * score和member：都存储当前系统时间的毫秒值
* ZSet提供了查询方式，zrangebyscore，可以基于分数做一个范围查询

考虑一下并发的问题：

* 如果再校验限流规则时，是 **先做查询** 的话，会导致并发情况下，多个线程可以同时发送短信。
* 所以针对上面的情况，需要 **先做插入数据** ，然后 **再做范围的查询** 确认是否满足限流的要求。
* 如果先做查询的数据的话，会导致同一个时间点的线程在插入时，会导致后插入线程插入失败。这里可以给当前线程做一个 **重试的操作** ，重置短信发送时间。针对不同的规则，需要有不同的重试次数。

### 9.1 实现60秒限流操作

提供Cache模块的功能

```java
@PostMapping(value = "/cache/zadd/{key}/{score}/{member}")
public Boolean zadd(@PathVariable(value = "key")String key,
                    @PathVariable(value = "score")Long score,
                    @PathVariable(value = "member")Object member){
    log.info("【缓存模块】 zaddLong方法，存储key = {}，存储score = {}，存储value = {}", key,score, member);
    Boolean result = redisClient.zAdd(key, member, score);
    return result;
}

@GetMapping(value = "/cache/zrangebyscorecount/{key}/{start}/{end}")
public int zRangeByScoreCount(@PathVariable(value = "key") String key,
                            @PathVariable(value = "start") Double start,
                            @PathVariable(value = "end") Double end) {
    log.info("【缓存模块】 zRangeByScoreCount方法，查询key = {},start = {},end = {}", key,start,end);
    Set<ZSetOperations.TypedTuple<Object>> values = redisTemplate.opsForZSet().rangeByScoreWithScores(key, start, end);
    if(values != null){
        return values.size();
    }
    return 0;
}
```

在策略模块实现具体的业务逻辑

```java
@Service("limitOneMinute")
@Slf4j
public class LimitOneMinuteStrategyFilter implements StrategyFilter {

    private final String UTC = "+8";

    private final long ONE_MINUTE = 60 * 1000 - 1;

    @Autowired
    private BeaconCacheClient cacheClient;

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;


    @Override
    public void strategy(StandardSubmit submit) {
        //1、基于submit获取短信的发送时间
        LocalDateTime sendTime = submit.getSendTime();
        //2、基于LocalDateTime获取到时间的毫秒值
        long sendTimeMilli = sendTime.toInstant(ZoneOffset.of(UTC)).toEpochMilli();

        //3、基于submit获取客户标识以及手机号信息
        Long clientId = submit.getClientId();
        String mobile = submit.getMobile();

        //4、优先将当前短信发送信息插入到Redis的ZSet结构中 zadd
        String key = CacheConstant.LIMIT_MINUTES + clientId + CacheConstant.SEPARATE + mobile;
        Boolean addOk = cacheClient.zadd(key, sendTimeMilli, sendTimeMilli);

        //5、如果查询失败，直接告辞，有并发情况，60s不能发送两条，直接告辞
        if(!addOk){
            log.info("【策略模块-一分钟限流策略】  插入失败！ 满足一分钟限流规则，无法发送！");
            submit.setErrorMsg(ExceptionEnums.ONE_MINUTE_LIMIT + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.ONE_MINUTE_LIMIT);
        }

        //6、基于zrangebyscore查询1分钟直接，是否只有当前查询的发送短信信息
        long start = sendTimeMilli - ONE_MINUTE;
        int count = cacheClient.zRangeByScoreCount(key, Double.parseDouble(start + ""), Double.parseDouble(sendTimeMilli + ""));

        //7、如果大于等于2条短信信息，达到了60s一条的短信限流规则，直接告辞。
        if(count > 1){
            // 一分钟之前，发送过短信，限流规则生效
            log.info("【策略模块-一分钟限流策略】  插入失败！ 满足一分钟限流规则，无法发送！");
            cacheClient.zRemove(key,sendTimeMilli + "");
            submit.setErrorMsg(ExceptionEnums.ONE_MINUTE_LIMIT + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.ONE_MINUTE_LIMIT);
        }

        log.info("【策略模块-一分钟限流策略】  一分钟限流规则通过，可以发送！");
    }
}
```

### 9.2 实现1小时限流操作

前面基于60s的操作，向Redis中写入了一个信息。

如果1小时限流直接使用之前60s限流会导致出现问题，不知道到底是否需要插入。

这里为了避免因为60s限流对1小时限流，甚至后面的1天限流造成影响，每一个限流规则，都需要独立的去构建一个ZSet结构。

1小时限流先对60s的限流多了一个操作，重试机制。

**Ps：同时1分钟和1小时的限流当前中，都存在一个问题，如果数据正常的插入了，但是做范围查询时，发现满足限流的要求了，无法发送。需要将之前查询的数据删除掉，避免后面判断出现问题。**

在Cache缓存模块提供了删除ZSet中member的接口

```java
@DeleteMapping(value = "/cache/zremove/{key}/{member}")
public void zRemove(@PathVariable(value = "key") String key,@PathVariable(value = "member") String member) {
    log.info("【缓存模块】 zRemove方法，删除key = {},member = {}", key,member);
    redisClient.zRemove(key,member);
}
```

完成1小时的限流规则

```java
/**
 * 1小时发送3条的限流规则
 * @author zjw
 * @description
 */
@Service("limitOneHour")
@Slf4j
public class LimitOneHourStrategyFilter implements StrategyFilter {

    private final String UTC = "+8";

    private final long ONE_HOUR = 60 * 1000 * 60 - 1;

    private final int RETRY_COUNT = 2;

    private final int LIMIT_HOUR = 3;

    @Autowired
    private BeaconCacheClient cacheClient;

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;


    @Override
    public void strategy(StandardSubmit submit) {
        //1、基于submit获取短信的发送时间
        LocalDateTime sendTime = submit.getSendTime();
        //2、基于LocalDateTime获取到时间的毫秒值
        long sendTimeMilli = sendTime.toInstant(ZoneOffset.of(UTC)).toEpochMilli();
        submit.setOneHourLimitMilli(sendTimeMilli);
        //3、基于submit获取客户标识以及手机号信息
        Long clientId = submit.getClientId();
        String mobile = submit.getMobile();

        //4、优先将当前短信发送信息插入到Redis的ZSet结构中 zadd
        String key = CacheConstant.LIMIT_HOURS + clientId + CacheConstant.SEPARATE + mobile;

        //5、如果插入失败，需要重新的将毫秒值做改变，尝试重新插入
        int retry = 0;
        while(!cacheClient.zadd(key, submit.getOneHourLimitMilli(), submit.getOneHourLimitMilli())){
            // 发送失败,尝试重试
            if(retry == RETRY_COUNT) break;
            retry++;
            // 插入失败，是因为存储的member不允许重复，既然重复了，将时间向后移动，移动到当前系统时间
            submit.setOneHourLimitMilli(System.currentTimeMillis());
        }
        // 如果retry为2，代表已经重试了2次，但是依然没有成功
        if(retry == RETRY_COUNT){
            log.info("【策略模块-一小时限流策略】  插入失败！ 满足一小时限流规则，无法发送！");
            submit.setErrorMsg(ExceptionEnums.ONE_HOUR_LIMIT + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.ONE_HOUR_LIMIT);
        }
        // 没有重试2次，3次之内，将数据正常的插入了。基于zrangebyscore做范围查询
        long start = submit.getOneHourLimitMilli() - ONE_HOUR;
        int count = cacheClient.zRangeByScoreCount(key, Double.parseDouble(start + ""), Double.parseDouble(submit.getOneHourLimitMilli() + ""));

        if(count > LIMIT_HOUR){
            log.info("【策略模块-一小时限流策略】  插入失败！ 满足一小时限流规则，无法发送！");
            cacheClient.zRemove(key,submit.getOneHourLimitMilli() + "");
            submit.setErrorMsg(ExceptionEnums.ONE_HOUR_LIMIT + ",mobile = " + mobile);
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.ONE_HOUR_LIMIT);
        }

        log.info("【策略模块-一小时限流策略】  一小时限流规则通过，可以发送！");

    }
}
```

**Ps：同时开始就说过，只有验证码类的短信才需要做限流操作，针对1分钟和1小时的开头，需要追加一个额外的判断，如果当前短信类型不是验证码类型的，直接结束方法，走后续的策略**

```java
// 判断短信类型不是验证码类的，直接结束方法
if(submit.getState() != SmsConstant.CODE_TYPE){
    return;
}
```

postman测试时，传递的参数，记得做调整![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1671628289014/55fbc50aafed42ecb3b534d41cb74c09.png)

## 十、扣费策略

扣费操作，必然要基于Redis做一个费用的扣除，基于Redis的原子性，可以保证不会出现并发的问题，而且效率也是比较快的。这里不需要每次扣费之后，都将数据同步到MySQL数据库中，如果每次都同步MySQL成本太高了。同步方式可以采用定时任务的方式，将Redis的剩余金额，同步到MySQL中。

因为接口模块已经计算过具体的费用，并且做过费用金额的判断，这里正常只对费用进行扣除即可，但是为了避免海量并发导致欠费过多的问题，这里设置一个欠费的临界值。暂时就编写一个固定的，指定暂时所有客户都可以欠费200条，10块大洋的情况。

其次这里的扣费其实是预扣除。策略模块这里，短信还没有发送出去，真正知道短信是否发送成功是在短信网关模块与运营商交互之后，才可以得到的结果。如果在短信网关模块中发现短信发送失败，都需要将费用补回到Redis中。

实现扣费操作

1、在Cache缓存模块提供incr的操作

```java
@PostMapping(value = "/cache/hincrby/{key}/{field}/{delta}")
public Long hIncrBy(@PathVariable(value = "key") String key,
                    @PathVariable(value = "field") String field,
                    @PathVariable(value = "delta") Long delta){
    log.info("【缓存模块】 hIncrBy方法，自增   key = {},field = {}，number = {}", key,field,delta);
    Long result = redisClient.incrementMap(key, field, delta);
    log.info("【缓存模块】 hIncrBy方法，自增   key = {},field = {}，number = {},剩余数值为 = {}", key,field,delta,result);
    return result;
}
```

2、在策略模块提供扣费操作

```java
@Service(value = "fee")
@Slf4j
public class FeeStrategyFilter implements StrategyFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;

    private final String BALANCE = "balance";

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-扣费校验】   校验ing…………");
        //1、获取submit中封装的金额
        Long fee = submit.getFee();
        Long clientId = submit.getClientId();
        //2、调用Redis的decr扣减具体的金额
        Long amount = cacheClient.hIncrBy(CacheConstant.CLIENT_BALANCE + clientId, BALANCE, -fee);

        //3、获取当前客户的欠费金额的限制（外部方法调用，暂时写死为10000厘）
        Long amountLimit = ClientBalanceUtil.getClientAmountLimit(submit.getClientId());

        //4、判断扣减过后的金额，是否超出了金额限制
        if(amount < amountLimit) {
            log.info("【策略模块-扣费校验】   扣除费用后，超过欠费余额的限制，无法发送短信！！");
            //5、如果超过了，需要将扣除的费用增加回去，并且做后续处理
            cacheClient.hIncrBy(CacheConstant.CLIENT_BALANCE + clientId, BALANCE, fee);
            submit.setErrorMsg(ExceptionEnums.BALANCE_NOT_ENOUGH.getMsg());
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.BALANCE_NOT_ENOUGH);
        }
        log.info("【策略模块-扣费校验】   扣费成功！！");
    }
}
```

## 十一、路由策略（选择通道并发送submit）

首先平台内有多少个通道，取决于公司和各处运营商的合作。所以合作的运营商的通道信息，都封装到了channel表里面存储了详细信息。

至于通道选择，需要客户先和具体的通道做一个绑定，指定好与通道的权重信息（默认500），选择具体通道时，会基于这个权重选择优先级更高的通道。其次根据是否可以以及通道与手机的运营商是否匹配来决定最终的通道选择。（地域的筛选暂时不去区别，后期可以追加通道转换的操作来实现这个功能）

后面基于是准备好数据。

* 需要将全部的channel通道信息同步到Redis里中。
  * key：前缀:channelId
* 将client_channel表中的信息也同步到Redis中。
  * 面向客户去做缓存
  * key：前缀:客户id
  * value：基于Set结构存储，主要存储的信息就是client_channel表的信息
  * value主要存储通道id、权重、下发扩展号、是否可用、是否删除

### 11.1 同步数据到Redis

同步两个数据，一个Channel的整体信息，一个是客户和Channel绑定的信息

Channel信息同步到Redis缓存：正常准备查询，准备实体类，存储到Redis中即可

客户和Channel绑定同步到Redis：正常查询信息，值需要之前说的5个信息，准备好实体类，存储到Redis完事

### 11.2 路由策略的整体逻辑

1、选择通道，先根据客户绑定的通道信息，拿到全部通道

2、根据权重信息，选择权重高的，并且确认绑定关系么得问题。

3、直接获取到具体的通道，并且再次判断通道是否可用，以及运营商是否匹配

4、预留了一个通道转换的口子（暂时里面什么都没做）

5、封装好submit

6、声明好队列，并且发送消息，等待短信网关模块处理

```java
@Service(value = "route")
@Slf4j
public class RouteStrategyFilter implements StrategyFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    @Autowired
    private ErrorSendMsgUtil sendMsgUtil;

    @Autowired
    private AmqpAdmin amqpAdmin;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Override
    public void strategy(StandardSubmit submit) {
        log.info("【策略模块-路由策略】   校验ing…………");
        //1、拿到客户id
        Long clientId = submit.getClientId();

        //2、基于redis获取当前客户绑定的所有通道信息
        Set<Map> clientChannels = cacheClient.smemberMap(CacheConstant.CLIENT_CHANNEL + clientId);

        //3、将获取到的客户通道信息根据权重做好排序
        TreeSet<Map> clientWeightChannels = new TreeSet<>(new Comparator<Map>() {
            @Override
            public int compare(Map o1, Map o2) {
                int o1Weight = Integer.parseInt(o1.get("clientChannelWeight") + "");
                int o2Weight = Integer.parseInt(o2.get("clientChannelWeight") + "");
                return o2Weight - o1Weight;
            }
        });
        clientWeightChannels.addAll(clientChannels);

        boolean ok = false;
        Map channel = null;
        Map clientChannel = null;
        //4、基于排好序的通道选择，权重更高的
        for (Map clientWeightChannel : clientWeightChannels) {
            //5、如果客户和通道的绑定关系可用，直接去基于Redis查询具体的通道信息
            if((int)(clientWeightChannel.get("isAvailable")) != 0){
                // 当前关系不可用，直接进行下次循环，选择权重相对更低一点的
                continue;
            }

            //6、如果通道信息查询后，判断通道睡否可用，其次运营商可以匹配。
            channel = cacheClient.hGetAll(CacheConstant.CHANNEL + clientWeightChannel.get("channelId"));
            if((int)(channel.get("isAvailable")) != 0){
                // 当前通道不可用，选择权重更低的通道~
                continue;
            }
            // 获取通道的通讯方式
            Integer channelType = (Integer) channel.get("channelType");
            if (channelType != 0 && submit.getOperatorId() != channelType){
                // 通道不是全网通，并且和当前手机号运营商不匹配
                continue;
            }

            //7、如果后期涉及到的通道的转换，这里留一个口子
            Map transferChannel = ChannelTransferUtil.transfer(submit, channel);

            // 找到可以使用的通道了
            ok = true;
            clientChannel = clientWeightChannel;
            break;
        }

        if(!ok){
            log.info("【策略模块-路由策略】   没有选择到可用的通道！！");
            submit.setErrorMsg(ExceptionEnums.NO_CHANNEL.getMsg());
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(ExceptionEnums.NO_CHANNEL);
        }


        //8、基于选择的通道封装submit的信息
        submit.setChannelId(Long.parseLong(channel.get("id") + ""));
        submit.setSrcNumber("" + channel.get("channelNumber") + clientChannel.get("clientChannelNumber"));

        try {
            //9、声明好队列名称，并构建队列
            String queueName = RabbitMQConstants.SMS_GATEWAY + submit.getChannelId();
            amqpAdmin.declareQueue(QueueBuilder.durable(queueName).build());

            //10、发送消息到声明好的队列中
            rabbitTemplate.convertAndSend(queueName,submit);
        } catch (AmqpException e) {
            log.info("【策略模块-路由策略】   声明通道对应队列以及发送消息时出现了问题！");
            submit.setErrorMsg(e.getMessage());
            sendMsgUtil.sendWriteLog(submit);
            sendMsgUtil.sendPushReport(submit);
            throw new StrategyException(e.getMessage(),ExceptionEnums.UNKNOWN_ERROR.getCode());
        }


    }
}
```
