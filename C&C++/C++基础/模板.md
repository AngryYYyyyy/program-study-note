# 一、泛型编程

> 泛型编程是一种在软件工程中定义函数、类和数据结构的方式，使其能够独立于数据类型。换句话说，通过泛型编程，你可以为各种数据类型编写一段代码，而不需要为每种数据类型都写一个版本。泛型编程有助于实现代码的重用和类型安全。
>
> 在C++中，模板是实现泛型编程的主要工具。

## 1.1 优点

> - **代码重用**：你可以为多种数据类型编写一段代码，而不需要为每种数据类型都写一个版本。
> - **类型安全**：在编译时，模板确保类型的正确性，从而减少运行时错误的机会。
> - **性能优化**：模板代码在编译时进行实例化，这意味着在运行时几乎没有开销。

# 二、模板

## 2.1 函数模板

> 函数模板是C++中泛型编程的一部分，它允许我们为多种类型创建一个函数，而不需要为每种类型重写函数。这增强了代码的重用性并提供了类型安全。

### 2.1.1 函数模板格式

> template<typename T1, typename T2,......,typename Tn>
>
> 返回值类型 函数名(参数列表){}

```c++
template <typename T>//typename是用来定义模板参数关键字，也可以使用class
T max(T x, T y) 
{
    return (x > y) ? x : y;
}
```

### 2.1.2 函数模板原理

> 当你定义一个函数模板，你实际上并没有定义一个完整的、可以立即执行的函数。相反，你定义了一个如何生成函数的模板。只有当函数模板被实际调用时，编译器才会生成与特定类型相对应的函数。
>
> 当模板被实例化时，编译器会生成一个与特定类型相关的函数版本。这允许开发者编写通用的代码，而不牺牲性能。

### 2.1.3 函数模板的实例化

> 当你使用某种类型调用函数模板时，编译器会根据这个类型和函数模板生成一个特定的、完整的函数。这个过程称为模板实例化。

#### （1）隐式实例化

> 让编译器根据实参推演模板参数的实际类型

```c++
printValue(5.5);     // 使用隐式类型推导
```

#### （2）显式实例化

> 在函数名后的<>中指定模板参数的实际类型

```c++
printValue<int>(5);  // 使用显式类型
```

### 2.1.4 模板参数的匹配原则

> 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数。
>
> ==对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。==如果模板可以产生一个具有更好匹配的函数， 那么将选择模板。
>
> ==模板函数不允许自动类型转换，但普通函数可以进行自动类型转换==

## 2.2 类模板

### 2.2.1 类模板格式

```c++
template<class T1, class T2, ..., class Tn>
class 类模板名
{
 // 类内成员定义
}; 
//类模板中函数放在类外进行定义时，需要加模板参数列表
```

### 2.2.3 类模板的实例化

> 类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟<>，然后将实例化的类型放在<> 中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。

## 2.3 非类型模板参数

> 在C++模板编程中，模板参数不仅仅可以是类型，还可以是非类型参数。非类型模板参数是一个在编译时期具有固定值的参数。它允许用户在模板中使用特定的常量值，而不是类型。

### 2.3.1 非类型模板格式

```c++
template <typename Type, int constantValue>
class ClassName 
{ /* ... */ };
```

### 2.3.2 使用范围

> ==非类型模板参数可以是整数类型、指针、引用、指向成员的指针。==不过，C++标准明确禁止了某些类型作为非类型参数，如浮点数、类对象、字符串等。

```c++
template <typename T, int size>
class Array 
{
    T arr[size];
};

int main() {
    Array<int, 5> arr;
    return 0;
}

```



# 三、模板的特化

> 在原模板类的基础上，针对特殊类型所进行特殊化的实现方式
>
> 一般情况下如果函数模板遇到不能处理或者处理有误的类型，为了实现简单通常都是将该函数直接给出。

## 3.1 函数模板特化

> 必须要先有一个基础的函数模板 
>
> 关键字template后面接一对空的尖括号<> 
>
>  函数名后跟一对尖括号，尖括号中指定需要特化的类型 
>
>  函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。

```c++
template <typename T>
void print(const T& data) {
    std::cout << "General template: " << data << std::endl;
}
template <>
void print<int>(const int& data) {
    std::cout << "Specialized template for int: " << data << std::endl;
}
```

## 3.2 类模板特化

### 3.2.1 全特化

> 将模板参数列表中所有的参数都确定化。

```c++
template <typename T1，typename T2>
class MyClass {};

template <>
class MyClass<int,int> {};
```



### 3.2.2 偏特化

#### （1）部分特化

> 将模板参数类表中的一部分参数特化

```c++
template <typename T1, typename T2>
class MyClass {};

template <typename T>
class MyClass<T, int> {};

```

#### （2）==参数更进一步的限制==

```c++
template <typename T1, typename T2>
class MyClass {};

template <typename T1, typename T2>
class MyClass<T1*, T2*> {};
```

# 四、模板分离编译

## 4.1 分离编译

> 分离编译是一个编程概念，指的是将一个程序分为多个源文件，每个源文件都可以单独编译。这样做的好处是允许多个程序员并行工作，提高编译速度（因为只需要重新编译更改的部分），并提高代码的模块性和可读性。

## 4.2 模板分离编译

> 模板分离编译是指将模板的声明和定义分开放在不同的文件中。但与普通的C++函数和类的分离编译（即声明在头文件，定义在源文件）不同，模板有其特殊之处。
>
> 首先，让我们明白一个事实：模板不是真正的函数或类，直到它们被实例化。==编译器需要看到模板的完整定义才能为特定的类型实例化它。==
>

### 4.2.1 常见做法

> 一种常见的方法是==在头文件中声明和定义模板==，这样任何包含该头文件的源文件都可以实例化该模板。
>

### 4.2.2 分离编译尝试

`my_template.h`:
```cpp
template <typename T>
class MyTemplate {
public:
    void doSomething(T value);
};
```

`my_template.cpp`:
```cpp
#include "my_template.h"

template <typename T>
void MyTemplate<T>::doSomething(T value) {}
```

在另一个文件`main.cpp`中：
```cpp
#include "my_template.h"

int main() {
    MyTemplate<int> obj;//试图为特定的类型实例化一个模板类。但它并不真正地为你创建这个类，除非它看到模板类的所有成员函数的完整定义。
    obj.doSomething(5);
    return 0;
}
```

> 这样编译会导致一个链接错误，因为`main.cpp`在编译时不知道`MyTemplate<int>::doSomething`的定义。