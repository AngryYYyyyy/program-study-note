# 学习目标

> 学习yum工具，进行软件安装
>
> 掌握vim编辑器使用，学会vim的简单配置
>
> 掌握gcc/g++编译器的使用，并了解其过程、原理
>
> 掌握简单gdb使用于调试
>
> 掌握简单的Makefifile编写，了解其运行思想
>
> 学习 git 命令行的简单操作, 能够将代码上传到 Github 上

# Linux 软件包管理器-yum

#### 什么是软件包

> 在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.
>
> 但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.
>
> ==软件包和软件包管理器, 就好比 "App" 和 "应用商店" 这样的关系==.
>
> **yum(Yellow dog Updater, Modifified)是Linux下非常常用的一种包管理器**. 主要应用在Fedora, RedHat, 
>
> Centos等发行版上.

**注意事项**：

> 在执行以下命令时，需要以root用户或具有sudo权限的用户身份运行

#### 如何使用yum安装软件包

>  yum install 软件包

#### 如何查看软件包

> yum list  包括已安装和未安装，由于包的数目可能非常之多,考虑使用 grep 命令筛选
>
> yum list installed 查看已安装的软件包

#### 如何卸载软件包

> yum remove 软件包

#### 其他yum命令

> yum update`：更新系统中已安装的所有软件包到最新版本
>
> yum upgrade：升级系统中已安装的软件包到最新版本，包括依赖关系
>
> yum search <keyword>：在所有可用软件包中搜索包含指定关键字的软件包
>
> yum info <package_name>：显示指定软件包的详细信息
>
> yum list updates：列出可用更新的软件包
>
> yum clean all：清除yum缓存中的所有头文件和软件包
>
> yum repolist：显示当前配置的所有仓库列表
>
> yum check-update：检查可用的软件包更新
>
> yum groupinstall <group_name>：安装指定软件包组
>
> yum grouplist：列出可用的软件包组
>
> yum makecache：命令是用于将服务器的软件包信息缓存到本地的命令

# Linux开发工具

### 1、Linux编辑器-vim使用

> Vim是一款常用的文本编辑器，常用于Linux系统中的终端中编辑文本文件。它是Vi编辑器的加强版，Vi是Unix系统原生的文本编辑器，而Vim则在Vi的基础上增加了很多功能和命令。Vim的使用方法较为复杂，但是功能非常强大，可以实现快速编辑、文本处理、代码编写等多种功能。

#### 1）vim基本模式

- **正常/普通/命令模式(Normal mode)**

> 控制屏幕光标的移动，实现字符、字或行的删除，移动复制某区段，进入Insert mode或者last line mode等功能

- **插入模式(Insert mode)**

> 文字输入

- **末行模式(last line mode)**

> 文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作

#### 2）vim模式切换

<img src="D:\笔记\C++\linux系统编程网络编程\image-20230510123230955.png" alt="image-20230510123230955" style="zoom:67%;" />

#### 3）vim正常模式命令集

- **移动光标**

> 「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格
>
> 按「 $ 」：移动到光标所在行的“行尾”
>
> 按「^」：移动到光标所在行的“行首”
>
> 按「w」：光标跳到下个字的开头
>
> 按「b」：光标回到上个字的开头
>
> 按「#l」：光标移到该行的第#个位置，如：5l,56l
>
> 按［gg］：进入到文本开始
>
> 按［shift＋g］：进入文本末端

- **删除文字**

> 「x」：每按一次，删除光标所在位置的一个字符
>
> 「#x」：例如，「6x」表示删除光标所在位置的“后面（包含自己在内）”6个字符
>
> 「dd」：删除光标所在行
>
> 「#dd」：从光标所在行开始删除#行

- **复制**

> 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。
>
> 「#yw」：复制#个字到缓冲区
>
> 「yy」：复制光标所在行到缓冲区。
>
> 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。
>
> 「#p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。

- **替换**

> 「r」：替换光标所在处的字符。
>
> 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。

- **撤销上一次操作**

> 「u」：回到上一个操作，按多次“u”可以执行多次回复。
>
> 「ctrl + r」: 撤销的恢复

- **跳至指定的行**

> 「ctrl」+「g」列出光标所在行的行号。
>
> 「#G」：例如，「15G」，表示移动光标至文章的第15行行首

- **注释**

> **单行注释**：在要注释的行前面插入注释符号（如`//`、`#`等），将该行注释掉。
>
> **块注释**：按下`Ctrl + V`进入可视块模式，使用HJKL选择要注释的行，然后按下`I`，输入注释符号（如`//`、`#`等），再按下`Esc`键。去注释，则进入可视块模式下，按下`d`键或`x`键删除选中的注释符号

#### 4）vim末行模式命令集

- **查找字符**

> 「/关键字」: 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。（正向）
>
> 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。（反向）

- **保存文件**

> 「w」: 在冒号输入字母「w」就可以将文件保存起来

- **离开vim**

> 「q」：按「q」就是退出，如果无法离开vim，可以在「q」后跟一个「!」强制离开vim
>
> 「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件

- **替换字符**

> %s/被替换/替换/g

- **增加窗口**

> [vs 文件名] ：增加一个文件窗口，可以按ctrl w w切换

#### 5）简单vim配置

- **配置文件的位置**

> 在目录 /etc/ 下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效。
>
> 而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：“.vimrc”。例如，/root目录下，通常已经存在一个.vimrc文件,如果不存在，则创建之。
>
> 切换用户成为自己执行 su ，进入自己的主工作目录,执行 cd ~
>
> 打开自己目录下的.vimrc文件，执行 vim .vimrc

- **插件**

> 要配置好看的vim，原生的配置可能功能不全，可以选择安装插件来完善配置，保证用户是你要配置的用户

### 2、Linux编译器-gcc/g++使用（以gcc为例）

#### 1）gcc过程/原理

- **预处理**

> 宏替换、文件展开、去注释、条件编译



**实例**：gcc –E hello.c –o hello.i

> 选项“-E”,该选项的作用是让 gcc 在预处理结束后停止编译过程
>
> 选项“-o”是指目标文件,“.i”文件为已经过预处理的C原始程序

- **编译**

> 检查代码的规范性、是否有语法错误等，把代码翻译成汇编语言
>
> 实例：gcc –S hello.i –o hello.s

**拓展：**

> 1. 词法分析（Lexical Analysis）：将源代码划分为词法单元（Tokens）的过程。词法分析器会扫描源代码，识别出关键字、标识符、运算符、常量等，并生成相应的词法单元序列。
> 2. **语法分析**（Syntax Analysis）：根据语法规则检查词法单元序列的语法正确性，并**构建语法分析树（Parse Tree）**。语法分析树表示源代码的结构和语法规则，它将代码按照语法规则分解为语法单元，并建立它们之间的关系。语法分析树是后续阶段（如语义分析、代码生成）的基础。
> 3. 语义分析（Semantic Analysis）：对语法分析树进行进一步的语义检查。语义分析器会检查类型匹配、变量声明和使用、函数调用等语义相关的问题，并进行错误检测和纠正。
> 4. 中间代码生成（Intermediate Code Generation）：将语法分析树转换为中间表示形式，通常是一种抽象的、与具体机器无关的中间代码。中间代码便于后续优化和目标代码生成。
> 5. 代码优化（Code Optimization）：对中间代码进行优化，旨在提高程序的执行效率、减少资源消耗、减小程序体积等。优化技术包括常量折叠、循环优化、代码移动等。
> 6. 目标代码生成（Code Generation）：将优化后的中间代码转换为目标机器的机器代码。目标代码生成器会根据目标机器的特性和指令集生成可执行的机器代码。
> 7. 符号表管理（Symbol Table Management）：维护程序中的符号表，记录变量、函数、类等的信息，用于语义分析和代码生成阶段的引用和解析。
> 8. 错误处理（Error Handling）：在编译过程中，对于词法、语法和语义错误的处理和报告。

- **汇编**

> 汇编阶段是把编译阶段生成的“.s”文件转成目标代码,生成机器可识别代码
>
> 实例：gcc –c hello.s –o hello.o

- **链接**

> 链接库函数和头文件
>
> 实例：gcc hello.o –o hello

#### 2）gcc指令

**格式**：gcc [选项] 要编译的文件 [选项] [目标文件]

**功能**：编译

**选项**：

> -E  只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面
>
> -S 编译到汇编语言不进行汇编和链接
>
> -c 编译到目标代码
>
> -o  文件输出到文件
>
> -static 此选项对生成的文件采用静态链接

#### 3）函数库

- **静态库**

> 静态库是指编译链接时,**把库文件的代码全部加入到可执行文件中**,因此生成的文件比较大,但在运行时也
>
> 就不再需要库文件了，其后缀名一般为“.a”

- **动态库**

> 动态库与之相反,**在编译链接时并没有把库文件的代码加入到可执行文件中**,而是在程序执行时由运行时
>
> 链接文件加载库,这样可以节省系统的开销，动态库一般后缀名为“.so”，gcc 在编译时默认使用动态库

### 3、Linux调试器-gdb使用

> 程序的发布方式有两种，debug模式和release模式
>
> Linux gcc/g++出来的二进制程序，默认是release模式
>
> 要使用gdb调试，必须在源代码生成二进制程序的时候, 加上-g选项

#### **1）进入**

> gdb 源文件

#### **2）调试命令**

> list／l  行号：显示binFile源代码，接着上次的位置往下列，每次列10行。
>
> list／l 函数名：列出某个函数的源代码。
>
> r或run：运行程序。
>
> n 或 next：单条执行。
>
> s或step：进入函数调用
>
> break(b) 行号：在某一行设置断点
>
> break 函数名：在某个函数开头设置断点
>
> info break ：查看断点信息。
>
> ﬁnish：执行到当前函数返回，然后挺下来等待命令
>
> print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数
>
> p 变量：打印变量值。
>
> set var：修改变量的值
>
> continue(或c)：从当前位置开始连续而非单步执行程序
>
> run(或r)：从开始连续而非单步执行程序
>
> delete breakpoints：删除所有断点
>
> delete breakpoints n：删除序号为n的断点
>
> disable breakpoints：禁用断点
>
> enable breakpoints：启用断点
>
> info(或i) breakpoints：参看当前设置了哪些断点
>
> display 变量名：跟踪查看一个变量，每次停下来都显示它的值
>
> undisplay：取消对先前设置的那些变量的跟踪
>
> until X行号：跳至X行
>
> breaktrace(或bt)：查看各级函数调用及参数
>
> info（i) locals：查看当前栈帧局部变量的值
>
> quit：退出gdb

# Linux项目自动化构建工具-make命令/Makefile文件

> `make`是一个常用的构建工具，用于自动化编译和构建程序。它通过读取`Makefile`文件中的规则和命令，根据文件的依赖关系和更新时间来判断哪些文件需要重新编译，并执行相应的编译和源代码链接操作。`Makefile`通常会包含显式规则（明确指定目标文件和依赖关系）、隐晦规则（根据文件名推导规则）、变量定义（用于设置编译器和连接器选项）、文件指示（用于包含其他Makefile或指定伪目标）以及注释（用于提供说明和文档）

#### 1、依赖关系/依赖方法

- **依赖关系**

> 依赖关系指定了目标文件所依赖的其他文件。当一个目标的依赖关系发生变化时，`make`命令会重新构建该目标。

- **依赖方法/构建规则**

> 构建规则定义了如何生成目标文件的命令。构建规则可以包括编译命令、链接命令以及其他需要执行的命令。

**举例**：

```c
test:test.o //test依赖test.o
	gcc test.o -o test;//构建规则 gcc test.* -option test.*
test.o:test.s//test.o依赖test.s
	gcc -c test.s -o test.o;
test.s:test.i
	gcc -S test.i -o test.s;
test.i:test.c
	gcc -E test.c -o test.i;
.PHONY:clean//声明伪目标（phony target）,目标不对应真实的文件，而是表示一组操作或命令，将忽略这些目标对应的文件是否存在或更新，而始终执行相应的命令
clean:
	rm -f test.*;   //项目清理
```

> 如果目标文件需要两个依赖文件，可以在目标文件对应的规则中列出这两个依赖文件
>
> 如果需要生成两个目标文件，可以通过.PHONY：all  all：file1 file2  来实现
>
> 依赖方法也可以使用：gcc -o   \$@目标文件   $^依赖文件文件
>

#### 2、make原理

> `make`的工作原理是==基于文件的依赖关系==，它可以自动追踪文件之间的依赖关系，并根据文件的更新状态来执行相应的构建操作`make`工具可以智能地判断哪些文件需要重新构建，避免不必要的编译，提高构建效率。它只重新构建有更新的文件，以及与更新文件相关的依赖文件，从而节省时间和资源

- **判断文件状态**：

> `make`根据目标和依赖关系中的文件的时间戳来判断哪些文件需要重新构建。如果目标文件不存在、依赖文件有更新，或目标文件的时间戳早于依赖文件的时间戳，`make`认为目标文件需要重新构建。

- **递归构建**：

> 在执行命令过程中，`make`可能会遇到其他目标文件的依赖关系，此时它会递归地执行相应的构建操作，以确保所有的依赖关系都被满足。

#### 3、实现进度条

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#define NUM 101//0-100
#define STYLE '#'
void process()
{
    char bar[NUM];
    memset(bar, '\0', sizeof(bar));//置为'\0'
    const char *lable = "|/-\\";
    int cnt = 0;
    while(cnt <= 100)
    {
        printf("加载中:[%-100s][%d%%][%c]\r", bar, cnt, lable[cnt%4]);//   /r回车  平常我们所指的换行是/r+/n
        fflush(stdout);//刷新缓冲区
        bar[cnt++] = STYLE;
        usleep(200000);//头文件unistd.h 单位是微秒
    }
    printf("\n");
}
int main()
{
    process();
    return 0;
}
```



# Linux版本管理工具-git

> Git是一个分布式版本控制系统，用于跟踪和管理软件项目的代码变更。它可以记录项目中的每个修改，并提供了分支管理、版本回退、团队协作等功能

#### 1、git add example.txt

> 添加文件：将你的项目文件添加到Git仓库中，可以一次性添加多个文件，或者使用通配符来添加符合条件的文件

#### 2、git commit -m "Add example.txt"

> 提交更改：使用`git commit`命令提交文件的更改，并添加一个描述信息

#### 3、git push 

> 命令将本地提交推送到远程仓库

#### 4、其他git命令

> - git init：初始化一个新的Git仓库。
> - git status：查看Git仓库的状态，显示已修改但未提交的文件。
> - git log：查看Git提交历史，显示每个提交的作者、日期和提交信息。
> - git branch：管理分支，包括创建、删除、切换分支等操作。
> - git remote：管理远程仓库连接，包括添加、删除、重命名远程仓库等操作。
> - git pull：从远程仓库拉取最新代码到本地仓库。
> - git clone 远程仓库克隆到本地