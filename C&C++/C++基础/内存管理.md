# 一、C/C++内存分布

## 1.1 内存分布区域

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230910191853812.png" alt="image-20230910191853812" style="zoom:50%;" />

### （1）代码段

> - 这里存储了程序的二进制代码。
> - 常量
> - 这部分是只读的，防止程序意外地修改自己的指令。

### （2）**数据段**

>  通常包含了==全局变量和静态变量==

### （2）堆

> - 这是==动态内存分配的区域==。使用C中的`malloc()`和`free()`或C++中的`new`和`delete`可以在堆上分配和释放内存。
> - 通常，堆的起始地址比较低（但高于数据段和代码段），随着内存的动态分配，它会逐渐向高地址增长。

### （3）栈

> - 用于==存储局部变量、函数参数、返回地址和进行函数调用的相关信息==。
> - 栈是自上而下的数据结构，它从高地址开始并向低地址增长。每次函数调用都会在栈上为其参数、局部变量、返回地址等信息创建一个新的栈帧。

### （4）**内核空间**

> 高效的I/O映射方式，用于装载一个共享的动态内存库。

### （5）**内存映射段**

> 高效的I/O映射方式，用于装载一个共享的 **动态内存库**。用户可使用系统接口 创建共享共享内存，做进程间通信

## 1.2 测试

```c++
int globalVar = 1;//数据段
static int staticGlobalVar = 1;//数据段
void Test()
{
    static int staticVar = 1;//数据段
    int localVar = 1;//栈区
    int num1[10] = { 1, 2, 3, 4 };//栈区
    //虽然*char2的值存储在栈上，但是表达式*char2本身不占用额外的存储空间；它是对数组首元素的一个引用。
    char char2[] = "abcd";//栈区
    const char* pChar3 = "abcd";//栈区
    int* ptr1 = (int*)malloc(sizeof(int) * 4);//栈区
    int* ptr2 = (int*)calloc(4, sizeof(int));//栈区
    int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);//栈区
    free(ptr1);
    free(ptr3);
}
1. 选择题：
    选项: A.栈  B.堆  C.数据段(静态区)  D.代码段(常量区)
        globalVar在哪里？__C__   staticGlobalVar在哪里？__C__
        staticVar在哪里？___C_   localVar在哪里？__A__
        num1 在哪里？__A__

        char2在哪里？__A__   *char2在哪里？__A_
        pChar3在哪里？__A__      *pChar3在哪里？__D__
        ptr1在哪里？__A__        *ptr1在哪里？__B__
2. 填空题：
sizeof(num1) = __40__;   
sizeof(char2) = __5__;      strlen(char2) = __4__;
sizeof(pChar3) = __4/8__;     strlen(pChar3) = _4___;
sizeof(ptr1) = __4/8__;
3. sizeof 和 strlen 区别？
    //sizeof 用于获取数据类型或对象的字节大小，而 strlen 用于获取字符串的长度
```



# 二、C/C++动态内存管理

## 2.1 C语言动态内存管理

### （1）malloc

> 为指定==字节数==的未初始化的内存块分配空间。

```c++
void* malloc(size_t size);
```

### （2）calloc

> 为指定==数量的指定大小的元素==分配空间，并将分配的内存初始化为 0。

```c++
void* calloc(size_t num, size_t size);
```

### （3）realloc

> 重新==调整==之前调用 `malloc` 或 `calloc` ==分配的内存块的大小==。
>
> 如果传递给 `realloc` 的指针是 `NULL`，它就像 `malloc` 一样工作。
>
> 如果 `realloc` 无法在原位置扩展内存，它==可能会分配一个新的内存块==，移动旧内容到新的位置，然后释放旧的内存块。

```c++
void* realloc(void* ptr, size_t size);
```

### （4）free

> 释放之前通过 `malloc`, `calloc` 或 `realloc` 分配的内存

```c++
void free(void* ptr);
```



## 2.2 C++动态内存管理

### 2.2.1 new/delete操作内置类型

> 对于内置数据类型（如 `int`, `float`, `double` 等），`new` 主要用于分配内存，而 `delete` 主要用于释放内存。
>
> 没有任何构造函数或析构函数被调用

```c++
int* ptr = new int[3];  // 分配一个整数的内存

float* array = new float[10];  // 分配10个浮点数的内存

delete ptr;  // 释放内存
delete[] array;  // 释放数组的内存

```

### 2.2.2 new/delete操作自定义类型

> 对于自定义数据类型（类或结构体），`new` ==不仅分配内存，还调用对象的构造函数==。同样，`delete` ==不仅释放内存，还调用对象的析构函数==。

```c++
class MyClass {
public:
    MyClass() {
        std::cout << "Constructor called!" << std::endl;
    }
    ~MyClass() {
        std::cout << "Destructor called!" << std::endl;
    }
};

MyClass* obj = new MyClass();  // 这会打印 "Constructor called!"

delete obj;  // 这会打印 "Destructor called!"

```

## 2.3 动态内存管理实现原理

### 2.3.1 malloc底层原理

> **初始请求**:
>
> - 当程序第一次调用 `malloc` 时，`malloc` 从操作系统==请求一大块内存==。
> - 从这大块内存中，`malloc` ==返回一个指向所需大小的内存块的指针，并保留剩余的内存以供后续使用==。
>
> **后续请求**:
>
> - 对于后续的 `malloc` 调用，它首先==检查预先分配的内存==，看是否有足够的空间来满足请求。
> - 如果有==足够==的空间，`malloc` 就从那里==分配内存==，而不是请求新的内存。
> - 如果==没有足够==的空间，`malloc` 会再次==从操作系统请求更多的内存==。
>
> **释放内存**:
>
> - 当 `free` 被调用时，==内存块被标记为可用==，并在后续的 `malloc` 调用中被重用。
> - 为了跟踪哪些内存块是空闲的，`malloc` 和 `free` 使用了一种数据结构（通常是链表）来跟踪堆上的空闲块。
>
> **合并和分割**:
>
> - 为了应对==内存碎片化==，`malloc` 可能会==合并相邻的空闲块或分割大块以满足小的分配请求==。
>
> **与操作系统交互**:
>
> - 当 `malloc` 需要更多内存时，它通常使用系统调用，如 `sbrk` (在某些系统上) 或 `mmap` (在许多现代系统上) 来增加堆的大小。

### 2.3.2 new和delete的实现原理

#### （1） operator new

> `operator new` 是一个用于分配内存的==运算符==。当你使用 `new` 关键字创建对象时，这个运算符被调用。
>
> 默认的 `operator new` 的工作流程是：
> - ==通过 `malloc` 从堆中分配所需数量的内存。==
> - 如果分配成功，则返回分配内存的指针。
> - 如果分配失败并且内存不足，它将抛出 `std::bad_alloc` 异常。
>

#### （2）operator delete

> `operator delete` 用于释放由 `operator new` 分配的内存。当你使用 `delete` 关键字销毁对象时，这个运算符被调用。
>
> 默认的 `operator delete` 的工作流程是：
> - 释放由 `operator new` 分配的内存。
> - ==使用 `free` 函数释放内存。==
>

#### （3）与构造函数和析构函数的关系

> 当你使用 `new` 创建一个对象时，不仅会调用 `operator new` 来分配内存，还会调用对象的构造函数来初始化该对象。
>
> 相应地，当你使用 `delete` 销毁对象时，不仅会调用对象的析构函数，还会调用 `operator delete` 来释放内存。

## 2.4 定位new

> 定位 `new` (也称为"placement `new`") 是 C++ 中的一个特殊版本的 `new` 运算符，允许程序员==指定对象应该在何处构造==，即==提供一个已经分配的内存块的地址作为对象的存储位置==。这与常规的 `new` 运算符不同，后者会分配内存并返回相应的内存地址。
>
> 定位 `new` 的一个典型应用是在==预先分配的内存池中创建对象，这样可以避免动态内存分配带来的开销==。

### 2.4.1 语法

```cpp
new (address) Type (constructor arguments);
```

> 其中，`address` 是指定的内存地址，`Type` 是对象的类型，`constructor arguments` 是传递给构造函数的参数。
>

**示例**

```cpp
#include <iostream>
#include <new> // 必须包含此头文件来使用定位new

class MyClass {
public:
    MyClass() {
        std::cout << "MyClass constructed at " << this << std::endl;
    }
};

int main() {
    // 预先分配的内存块
    char buffer[sizeof(MyClass)];

    // 使用定位new在buffer中构造MyClass对象
    MyClass* obj = new (buffer) MyClass();

    // 手动调用析构函数
    obj->~MyClass();
    // 注意：这里不需要使用delete，因为内存没有通过常规的new动态分配

    return 0;
}
```

### 2.4.2 注意事项

> ==必须手动调用对象的析构函数来销毁它。==
>
> 不要对通过定位 `new` 创建的对象使用 `delete`，因为这会导致未定义的行为。`delete` 会尝试释放对象的内存，但这块内存并没有通过常规的 `new` 动态分配，所以结果是未定义的。

# 三、常见面试题

## （1）malloc/free和new/delete的区别

> malloc/free是函数，new/delete是操作符
>
> new 在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成 空间中资源的清理
>
> ==malloc/free需要强转类型==
>
> malloc申请空间失败时，返回的是nullptr，因此使用时需要判空，new不需要，但是new需要捕获异常

## （2）什么是内存泄漏，内存泄漏的危害

> 内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，==失去了对该段内存的控制==，因而造成了内存的浪费
>
> 长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现 内存泄漏会导致响应越来越慢，最终卡死。

## （3）内存泄漏分类

> ==堆内存泄漏(Heap leak)==
>
> 堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一 块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。
>
> ==系统资源泄漏==
>
> 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。

## （4）如何检测内存泄漏

> 1. **Valgrind**: 
>     - Valgrind是一个用于内存错误检测的强大工具。其中的`Memcheck`工具可以检测内存泄漏、读写越界等错误。
>     - 使用：
>       ```
>       valgrind --leak-check=yes your_program
>       ```
>     - Valgrind会给出详细的报告，显示内存泄漏的位置及详细信息。
>
> 2. **AddressSanitizer**:
>     
>     - AddressSanitizer (ASan) 是GCC和Clang编译器的一部分，用于检测各种内存错误。
>     - 使用：
>       ```bash
>       g++ -fsanitize=address -fno-omit-frame-pointer -g your_program.cpp
>       ./a.out
>       ```
>     - 运行程序后，ASan会在控制台打印有关内存泄漏的详细信息。
>     
> 3. **Visual Studio**:
>     - 对于使用Visual Studio的Windows开发者，它内置了一个内存泄漏检测器。
>     - 为了启用此功能，需要包含头文件 `<crtdbg.h>` 并在`main`函数开始时调用 `_CrtSetDbgFlag` 函数。
>
> 4. **手动跟踪**:
>     - 你可以重载 `new` 和 `delete` 操作符，来跟踪分配和释放的内存。
>     - 这种方法通常需要维护一个全局的数据结构，如散列表或树，来跟踪当前分配的所有内存块。
>

## （5）如何避免内存泄漏

> 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。
>
>  采用RAII思想或者智能指针来管理资源。 
>
> 内存泄漏检测。

