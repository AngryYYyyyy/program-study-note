# 后台管理模块

## 一、后台管理模块介绍

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/4efbf9c985d543fcae2c3a17e0c83187.png)

现在要完成短信管理平台，这个平台就是对各种数据做维护。

整个认证和授权方面的操作，会基于Shiro去实现。

至于页面方面，这边已经准备好了一套页面。

## 二、搭建后台管理模块

因为前期咱们主要是完成对用户的权限控制这个方面。

所以前期咱们不涉及其他模块，也不去注册到Nacos等等。

到了需要使用的使用，再引入依赖，编写好配置即可。

构建项目：

1、构建webmaster作为后台管理模块，还是普通的maven项目

2、暂时只导入web的starter依赖即可

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

3、编写启动类…………

4、将准备好的静态页面资源，基于本地磁盘的文件夹，复制到项目的static目录下。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/24fd7665d43e4d789ec787e101554073.png)

复制ok之后，启动项目，访问默认的index.html即可![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/9e2b50aafe1144fea47d23e1917091fb.png)

## 三、设计权限库表

之前的表结构都是为了完成整套发送短信的核心业务。

现在需要完成后台管理模块的权限，所以需要设计一套权限管理的库表结构。

其中市场上已经有一套很完成的权限控制方式，RBAC。

直接按照经典五张表设置权限控制。

用户表，角色表，菜单表，用户角色表，角色菜单表

### 3.1 用户表

**sms_user，用户表**

| **序号** | **列名** | **数据类型** | **长度** | **空？** | **默认值** | **说明**                |
| -------------- | :------------- | :----------------- | -------------- | -------------- | ---------------- | ----------------------------- |
| 1              | id             | bigint             | 20             | 否             |                  | 主键                          |
| 2              | username       | varchar            | 32             | 否             |                  | 用户名                        |
| 3              | password       | varchar            | 64             | 否             |                  | 用户登录密码                  |
| 4              | salt           | varchar            | 32             | 否             |                  | 认证时的盐                    |
| 5              | nickname       | varchar            | 32             | 是             |                  | 昵称                          |
| 6              | created        | timestamp          | 0              | 是             |                  | 创建时间，默认系统时间        |
| 7              | create_id      | bigint             | 11             | 是             |                  | 创建人id                      |
| 8              | updated        | timestamp          | 0              | 是             |                  | 修改时间，默认系统时间        |
| 9              | update_id      | bigint             | 11             | 是             |                  | 修改人id                      |
| 10             | is_delete      | tinyint            | 11             | 否             | 0                | 是否删除 0-未删除 ， 1-已删除 |
| 11             | extend1        | varchar            | 255            | 是             |                  | 备用字段1                     |
| 12             | extend2        | varchar            | 255            | 是             |                  | 备用字段2                     |
| 13             | extend3        | varchar            | 255            | 是             |                  | 备用字段3                     |
| 14             | extend4        | varchar            | 255            | 是             |                  | 备用字段4                     |

### 3.2 角色表

**sms_role，用户表**

| **序号** | **列名** | **数据类型** | **长度** | **空？** | **默认值** | **说明**                |
| -------------- | :------------- | :----------------- | -------------- | -------------- | ---------------- | ----------------------------- |
| 1              | id             | bigint             | 20             | 否             |                  | 主键                          |
| 2              | name           | varchar            | 32             | 否             |                  | 角色名                        |
| 3              | created        | timestamp          | 0              | 否             |                  | 创建时间，默认系统时间        |
| 4              | create_id      | bigint             | 11             | 是             |                  | 创建人id                      |
| 5              | updated        | timestamp          | 0              | 是             |                  | 创建时间，默认系统时间        |
| 6              | update_id      | bigint             | 11             | 是             |                  | 修改人id                      |
| 7              | is_delete      | tinyint            | 11             | 否             |                  | 是否删除 0-未删除 ， 1-已删除 |
| 8              | extend1        | varchar            | 255            | 是             |                  | 备用字段1                     |
| 9              | extend2        | varchar            | 255            | 是             |                  | 备用字段2                     |
| 10             | extend3        | varchar            | 255            | 是             |                  | 备用字段3                     |
| 11             | extend4        | varchar            | 255            | 是             |                  | 备用字段4                     |

### 3.3 菜单表

**sms_menu，用户表**

| **序号** | **列名** | **数据类型** | **长度** | **空？** | **默认值** | **说明**                |
| -------------- | :------------- | :----------------- | -------------- | -------------- | ---------------- | ----------------------------- |
| 1              | id             | bigint             | 20             | 否             |                  | 主键                          |
| 2              | name           | varchar            | 32             | 否             |                  | 菜单名                        |
| 3              | parent_id      | bigint             | 20             | 否             |                  | 父菜单id                      |
| 4              | url            | varchar            | 256            | 是             |                  | 跳转的连接地址                |
| 5              | icon           | varchar            | 64             | 是             |                  | 按钮的小图标                  |
| 6              | type           | int                | 11             | 否             |                  | 菜单的类型                    |
| 7              | sort           | int                | 11             | 是             | 1000             | 菜单的排序规则                |
| 8              | created        | timestamp          | 0              | 是             |                  | 创建时间，默认系统时间        |
| 9              | create_id      | bigint             | 11             | 是             |                  | 创建人id                      |
| 10             | updated        | timestamp          | 0              | 是             |                  | 修改时间，默认系统时间        |
| 11             | update_id      | bigint             | 11             | 是             |                  | 修改人id                      |
| 12             | is_delete      | tinyint            | 11             | 否             |                  | 是否删除 0-未删除 ， 1-已删除 |
| 13             | extend1        | varchar            | 255            | 是             |                  | 备用字段1                     |
| 14             | extend2        | varchar            | 255            | 是             |                  | 备用字段2                     |
| 15             | extend3        | varchar            | 255            | 是             |                  | 备用字段3                     |
| 16             | extend4        | varchar            | 255            | 是             |                  | 备用字段4                     |

### 3.4 关系表

用户和角色的关联表

角色和菜单的关键表

没什么说的，就是一个没有主键的关系表

### 3.5 库表脚本

这里我将5张表的构建脚本还有最最基本的数据，放到了IDEA的webmaster里面的resources下。

有一个sql目录，里面提供了脚本和数据。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/ea6380ea67084d00a18c17abe16a19b5.png)

## 四、整合Shiro

### 4.1 梳理Shiro整合流程

首先了解Shiro在Web项目中的一个处理流程

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/1f3c2d4e453845aab2db7136f7432199.png)

开始SpringBoot整合Shiro

首先导入Shiro的web-starter依赖。

```xml
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring-boot-web-starter</artifactId>
    <version>1.4.0</version>
</dependency>
```

之后查看一下提供的AutoConfiguration的配置

发现了一个核心的内容，过滤器链

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/dd9a533b39cc425093f08b7e49b38796.png)

可以自己实现ShiroFilterChainDefinition的类，自定义过滤器链。

在经过过滤器链时，如果验证当前用户是否登录成功过？以及是否拥有相应的权限，通过SecurityManager整体的做统筹，与数据库交互做验证需要通过Realm去实现。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/95066a04da9f45dc85832d3352051a09.png)

### 4.2 整合Shiro

需要准备三个内容

1、准备过滤器链

```java
/**
 * 设置过滤器链的规则。
 * @return
 */
@Bean
public ShiroFilterChainDefinition shiroFilterChainDefinition(){
    //1、 构建ShiroFilterChainDefinition实现类
    DefaultShiroFilterChainDefinition shiroFilter = new DefaultShiroFilterChainDefinition();

    //2、配置上过滤器链
    Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();
    // anon代表放行，使用的是AnonymousFilter
    filterChainDefinitionMap.put("/sys/user/login","anon");
    filterChainDefinitionMap.put("/index.html","anon");
    filterChainDefinitionMap.put("/login.html","anon");
    filterChainDefinitionMap.put("/logout","logout");
    filterChainDefinitionMap.put("/**","authc");
    // 设置
    shiroFilter.addPathDefinitions(filterChainDefinitionMap);

    //3、返回配置好的过滤器链
    return shiroFilter;
}
```

2、准备SecurityManager

```java
@Bean
public DefaultWebSecurityManager securityManager(ShiroRealm shiroRealm){
    //1、构建安全管理器
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();

    //2、设置Realm进去
    securityManager.setRealm(shiroRealm);

    //3、返回安全管理器
    return securityManager;
}
```

3、准备自定义Realm（模拟数据库操作）

```java
/**
 * 自定义Realm
 * @author zjw
 * @description
 */
@Component
public class ShiroRealm extends AuthorizingRealm {

    {
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
        credentialsMatcher.setHashAlgorithmName("MD5");
        credentialsMatcher.setHashIterations(1024);
        this.setCredentialsMatcher(credentialsMatcher);
    }

    /**
     * 认证
     * @param token
     * @return
     * @throws AuthenticationException
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        //1、基于token拿到用户名
        String username = (String) token.getPrincipal();

        //2、基于用户名获取用户信息(模拟数据库操作)
        if(username == null || !username.equals("admin")) {
            //3、查询完毕后，查看用户是否为null，为null就直接返回即可
            return  null;
        }
        String password = "b39dc5da02d002e6ac581e5bb929d2e5";
        String salt = "09a8424ed5bf4373af6530fec2b29c0f";
        //4、不为null，说明用户名正确，封装AuthenticationInfo返回即可,设置密码加密方式和信息
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo("用户信息",password,"shiroRealm");
        info.setCredentialsSalt(ByteSource.Util.bytes(salt));

        //5、返回
        return info;
    }

    /**
     * 授权
     * @param principals
     * @return
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
}
```

4、没有登录需要跳到登录页，没有权限，需要跳到提示页，提供这两个页面的位置和配置

```yml
shiro:
  # 默认登录页面
  loginUrl: /login.html
  # 没有权限的页面
  unauthorizedUrl: unauthorized.html
```

## 五、MyBatis Generator

### 5.1 MyBatis Generator介绍和基本使用

这里是基于MyBatis官网提供的Generator插件生成表对应的实体类，和MyBatis对应的mapper接口和xml文件，这里除了MyBatis Generator你也可以采用MyBatis Plus。如果是功能丰富，MyBatis Plus功能自然更强劲。MyBatis Generator都是很直观的文件，可控性很强，可以随时修改。

然后去官网查看Generator如何使用

mybaits.org直接访问即可

在Products里面，找到核心组件Generator

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/786ca9151770428ebf728a3324924604.png)

通过文档查看，使用Generator的方式很多，这里采用maven的方式

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/4d3cf4cda0294df49e45550c43a1b836.png)

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-maven-plugin</artifactId>
            <version>1.4.2</version>
        </plugin>
    </plugins>
</build>
```

导入插件后，可以查看到右侧maven中，多了这个可以执行的命令

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/eb2624427fe440bcaee82d2219c53117.png)

尝试执行generate命令，发现执行报错，查看日志发现

```java
// 日志报错，说下述文件在resources下。
generatorConfig.xml does not exist
```

按照要求在resources下构建generatorConfig.xml文件，内容根据官网提示直接赋值

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/2fb9c55c97944fb2b4ede097a9b441fc.png)

最终基于官网的提示，编写了暂时最终版的generatorConfig.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>

<!--    所有信息都在context里，id是唯一标识，targetRuntime在Mybatis3的环境-->
    <context id="beaconCloud" targetRuntime="MyBatis3">
<!--        去除注释-->
        <commentGenerator>
            <property name="suppressAllComments" value="true" />
        </commentGenerator>

        <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                        connectionURL="jdbc:mysql://114.116.226.76:3306/beacon_cloud?characterEncoding=utf-8"
                        userId="root"
                        password="ZhengJinWei123!">
        </jdbcConnection>



        <javaTypeResolver >
<!--            是否将decimal类型转换为Java中的BigDecimal，默认false-->
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>
<!--        将表对应的实体类生成，指定好位置-->
        <javaModelGenerator targetPackage="com.mashibing.webmaster.entity" targetProject="src/main/java">
            <property name="enableSubPackages" value="true" />
<!--            字符串get时，去掉两边空格-->
            <property name="trimStrings" value="true" />
        </javaModelGenerator>
<!--        生成xml文件-->
        <sqlMapGenerator targetPackage="mapper"  targetProject="src/main/resources">
            <property name="enableSubPackages" value="true" />
        </sqlMapGenerator>

        <!--        生成Mapper接口-->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.mashibing.webmaster.mapper"  targetProject="src/main/java">
            <property name="enableSubPackages" value="true" />
        </javaClientGenerator>

<!--        生成那些表对应的信息-->
        <table tableName="sms_user" domainObjectName="SmsUser" />

    </context>
</generatorConfiguration>
```

基于sms_user表做测试，发现么得问题。

同时记住，执行生成文件时，需要给插件导入好MySQL的驱动

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-maven-plugin</artifactId>
            <version>1.4.2</version>
            <dependencies>
                <dependency>
                    <groupId>mysql</groupId>
                    <artifactId>mysql-connector-java</artifactId>
                    <version>5.1.49</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```

### 5.2 生成Mapper内容，并且配置MyBatis信息

修改generatorConfig.xml文件，指定好全部的库表信息

在后面追加上现在需要生成的这三张表

```xml
<table tableName="sms_user" domainObjectName="SmsUser" />
<table tableName="sms_role" domainObjectName="SmsRole" />
<table tableName="sms_menu" domainObjectName="SmsMenu" />
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/4049f4d4acfd4166804fffef8550d297.png)

导入MyBatis需要的相应依赖，完成基本的配置

1、导入依赖

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.49</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.10</version>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.2</version>
</dependency>
```

2、完成配置

2.1、启动类扫描Mapper接口

```java
@MapperScan(basePackages = "com.mashibing.webmaster.mapper")
```

2.2、配置文件

```yml
# MyBatis和dataSource配置
spring:
  datasource:
    driver-class-name: org.gjt.mm.mysql.Driver
    url: jdbc:mysql://114.116.226.76:3306/beacon_cloud?characterEncoding=utf-8
    username: root
    password: ZhengJinWei123!
    type: com.alibaba.druid.pool.DruidDataSource
# MyBatis
mybatis:
  mapper-locations: classpath:mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
```

3、测试效果

3.1、导入starter-test依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
</dependency>
```

3.2、测试Mapper

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SmsUserMapperTest {

    @Resource
    private SmsUserMapper userMapper;

    @Test
    public void findById(){
        SmsUser smsUser = userMapper.selectByPrimaryKey(1);
        System.out.println(smsUser);
    }

}
```

## 六、完善Shiro配置

之前配置Shiro时，自定义的Realm类没有实现与数据库交互，这里完成一下与数据库交互的操作。

1、完成SmsUserService的封装

```java
@Service
public class SmsUserServiceImpl implements SmsUserService {

    @Resource
    private SmsUserMapper userMapper;

    @Override
    public SmsUser findByUsername(String username) {
        //1、封装查询条件
        SmsUserExample example = new SmsUserExample();
        SmsUserExample.Criteria criteria = example.createCriteria();
        criteria.andUsernameEqualTo(username);
        //2、基于userMapper查询
        List<SmsUser> list = userMapper.selectByExample(example);
        //3、返回
        return list != null ? list.get(0) : null;
    }
}
```

2、测试userService

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SmsUserServiceTest {

    @Autowired
    private SmsUserService smsUserService;

    @Test
    public void findByUsername() {
        SmsUser smsUser = smsUserService.findByUsername("admin");
        System.out.println(smsUser);
    }
}
```

3、完善ShiroRealm的认证操作

```java
@Autowired
private SmsUserService userService;

/**
 * 认证
 * @param token
 * @return
 * @throws AuthenticationException
 */
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    //1、基于token拿到用户名
    String username = (String) token.getPrincipal();

    //2、基于用户名获取用户信息(模拟数据库操作)
    SmsUser smsUser = userService.findByUsername(username);

    //3、查询完毕后，查看用户是否为null，为null就直接返回即可
    if(smsUser == null){
        // 用户名错误
        return null;
    }

    //4、不为null，说明用户名正确，封装AuthenticationInfo返回即可,设置密码加密方式和信息
    SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(smsUser,smsUser.getPassword(),"shiroRealm");
    info.setCredentialsSalt(ByteSource.Util.bytes(smsUser.getSalt()));

    //5、返回
    return info;
}
```

## 七、完成认证操作

### 7.1 解决静态资源问题

发现请求过来后，所有的js之类的资源全部给Shiro拦截，需要让Shiro针对这种静态资源放行

发现所有的静态资源都放在了public的目下，让Shiro针对这个资源做anon放行即可

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/3c6a8b8519bb468fa890e2cd04477ca5.png)

针对ShiroConfig中的过滤器链，添加放行的资源路径信息

```java
/**
 * 设置过滤器链的规则。
 * @return
 */
@Bean
public ShiroFilterChainDefinition shiroFilterChainDefinition(){
    //1、 构建ShiroFilterChainDefinition实现类
    DefaultShiroFilterChainDefinition shiroFilter = new DefaultShiroFilterChainDefinition();

    //2、配置上过滤器链
    Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();
    // anon代表放行，使用的是AnonymousFilter
    filterChainDefinitionMap.put("/public/**","anon");
    filterChainDefinitionMap.put("/sys/user/login","anon");
    filterChainDefinitionMap.put("/index.html","anon");
    filterChainDefinitionMap.put("/login.html","anon");
    filterChainDefinitionMap.put("/logout","logout");
    filterChainDefinitionMap.put("/**","authc");
    // 设置
    shiroFilter.addPathDefinitions(filterChainDefinitionMap);

    //3、返回配置好的过滤器链
    return shiroFilter;
}
```

### 7.2 生成验证码

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/5d81e9b8fe0c42fc85fbdd62b4fc4faf.png)

发现验证码的路径也没Shiro拦截了，需要放行

直接在ShiroConfig中，将kaptcha.jpg路径放行即可。

为了生成验证码，选择一些开源的项目实现，这里选择的是：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/f7d9ed690b3c485f83878eedd9556c82.png)

导入依赖

```xml
<dependency>
    <groupId>com.github.axet</groupId>
    <artifactId>kaptcha</artifactId>
    <version>0.0.9</version>
</dependency>
```

配置kaptcha生成规则

```java
/**
 * 验证码生成规则
 * @author zjw
 * @description
 */
@Configuration
public class KaptchaConfig {

    @Bean
    public DefaultKaptcha kaptcha(){
        //1、直接构建DefaultKaptcha
        DefaultKaptcha kaptcha = new DefaultKaptcha();

        //2、设置配置信息
        Properties properties = new Properties();
        // 验证码生成位数为4位。
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH,"4");
        Config config = new Config(properties);
        kaptcha.setConfig(config);

        //3、返回对象
        return kaptcha;
    }
}
```

声明Controller，提供返回验证码的接口

```java
@Controller
public class KaptchaController {

    private final String JPG = "jpg";

    @Autowired
    private DefaultKaptcha kaptcha;

    @GetMapping("/captcha.jpg")
    public void captcha(HttpServletResponse resp){
        //1、验证码图片不需要做存储和缓存
        resp.setHeader("Cache-Control","no-store, no-cahe");
        //2、设置响应头信息
        resp.setContentType("image/jpg");
        //3、生成验证码文字
        String text = kaptcha.createText();
        //4、基于文字生成对应的图片
        BufferedImage image = kaptcha.createImage(text);
        //5、写回验证码图片信息
        try {
            ServletOutputStream outputStream = resp.getOutputStream();
            ImageIO.write(image,JPG,outputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


}
```

### 7.3 完成认证

首先在页面基于抓包，查看到了页面发送请求时，携带了JSON参数![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/9967c0ed9add41ddb9c067b3d31da628.png)

同时，请求路径默认也是没拦截的，请求路径也需要Shiro放行![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/b0fa49fd17e548c79cdfecb29feaeee1.png)

还有就是验证码需要在登录的时候做验证，需要在生成验证码同时，将正确的验证码存储到会话中。

1、需要在生成验证码的Controller基于Shiro的Session对验证码做存储

```java
@GetMapping("/captcha.jpg")
public void captcha(HttpServletResponse resp){
    //1、验证码图片不需要做存储和缓存
    resp.setHeader("Cache-Control","no-store, no-cahe");
    //2、设置响应头信息
    resp.setContentType("image/jpg");
    //3、生成验证码文字
    String text = kaptcha.createText();
    // 认证需要验证验证码的准确性，基于Shiro将text做存储
    SecurityUtils.getSubject().getSession().setAttribute(WebMasterConstants.KAPTCHA,text);
    //4、基于文字生成对应的图片
    BufferedImage image = kaptcha.createImage(text);
    //5、写回验证码图片信息
    try {
        ServletOutputStream outputStream = resp.getOutputStream();
        ImageIO.write(image,JPG,outputStream);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

2、放行登录的接口路径

在ShiroConfig中追加当前路径

```java
filterChainDefinitionMap.put("/sys/login","anon");
```

3、准备一个接口文档

```json
# 登录接口文档
请求路径 POST    http://localhost:8080/sys/login

# 请求参数 ，JSON格式
username = string    # 用户名，非空
password = string    # 密码，非空
kaptcha = string     # 验证码，非空
rememberMe = boolean # 记住我，允许为空

# 处理流程
1、请求参数的非空校验
2、基于验证码校验请求是否合理
3、基于用户名和密码做Shiro的认证操作
4、根据Shiro的认证，返回响应信息

# 响应的数据结构
SUCCESS:
{
  "code": 0,
  "msg": ""
}
FAIL:
{
  "code": 错误码,
  "msg": "错误信息"
}
```

4、完成认证流程代码

```java
@RestController
@RequestMapping("/sys")
@Slf4j
public class SmsUserController {


    @PostMapping("/login")
    public ResultVO login(@RequestBody @Valid UserDTO userDTO, BindingResult bindingResult) {
//        * 1、请求参数的非空校验
        if (bindingResult.hasErrors()) {
            // 参数不合法，响应对应的JSON信息
            log.info("【认证操作】参数不合法，userDTO = {}", userDTO);
            return R.error(ExceptionEnums.PARAMETER_ERROR);
        }
//        * 2、基于验证码校验请求是否合理
        String realKaptcha = (String) SecurityUtils.getSubject().getSession().getAttribute(WebMasterConstants.KAPTCHA);
        if (!userDTO.getCaptcha().equalsIgnoreCase(realKaptcha)) {
            log.info("【认证操作】验证码不正确，kapacha = {}，realKaptcha = {}", userDTO.getCaptcha(), realKaptcha);
            return R.error(ExceptionEnums.KAPACHA_ERROR);
        }
//        * 3、基于用户名和密码做Shiro的认证操作
        UsernamePasswordToken token = new UsernamePasswordToken(userDTO.getUsername(),userDTO.getPassword());
        token.setRememberMe(userDTO.getRememberMe());
        try {
            SecurityUtils.getSubject().login(token);
        } catch (AuthenticationException e) {
//        * 4、根据Shiro的认证，返回响应信息
            log.info("【认证操作】用户名或密码错误，ex = {}", e.getMessage());
            return R.error(ExceptionEnums.AUTHEN_ERROR);
        }
        // 到这，代表认证成功
        return R.ok();
    }


}
```

## 八、首页数据展示

### 8.1 用户信息展示

主要是在首页中，有个欢迎xxx。在index.html中第40行查看到当前内容。

原来是user.username，修改为user.nickname

```html
<div style="float:left;color:#fff;padding:15px 10px;">欢迎 {{user.nickname}}</div>
```

还需要去找一下，user是在什么位置发送请求获取到。

找到index.html引入的index.js文件，内部有vue去请求后台，拿登录的用户信息。

之前是r.user，这里我修改为了r.data。

```js
getUser: function () {
    $.getJSON("sys/user/info?_" + $.now(), function (r) {
        vm.user = r.data;
    });
},
```

实现功能，先准备接口文档

```json
# 登录接口文档
请求路径 GET    http://localhost:8080/sys/user/info

# 请求参数
无

# 处理流程
获取当前登录用户的信息，设置到返回结果中

# 响应的数据结构
SUCCESS:
{
  "code": 0,
  "msg": "",
  "data": {
    "nickname": "昵称"
  }
}
FAIL:
{
  "code": 错误码,
  "msg": "错误信息"
}
```

完成查询用户昵称接口

```java
/**
 * 查询登录用户的信息
 * @return
 */
@GetMapping("/user/info")
public ResultVO info(){
    //1、基于SecurityUtils获取用户信息
    Subject subject = SecurityUtils.getSubject();
    SmsUser smsUser = (SmsUser) subject.getPrincipal();
    if(smsUser == null){
        log.info("【获取登录用户信息】 用户未登录！！");
        return R.error(ExceptionEnums.NOT_LOGIN);
    }

    //2、封装结果返回
    Map<String,Object> data = new HashMap<>();
    data.put("nickname",smsUser.getNickname());
    return R.ok(data);
}
```

### 8.2 导航菜单信息展示

首先导航菜单信息是在数据库中的sys_menu中维护的。

其中sys_menu的字段type有三个值，0，1，2

* 0：当前是一个父级菜单，他下面有具体的其他菜单信息
* 1：当前是一个跳转链接的菜单，他附属于某一个父级菜单
* 2：具体的权限信息，在用户做具体操作时，根据当前按钮去匹配后续的权限信息

所以现在需要展示导航菜单，值需要0和1两个即可。

在排查页面时，发现依然是在index.js中，有查询当前用户拥有的菜单信息接口请求

```js
getMenuList: function (event) {
    $.getJSON("sys/menu/user?_" + $.now(), function (r) {
        vm.menuList = r.data;
    });
},
```

需要查看一下，页面是如何解析的这个menuList，根据他解析的方式，提供对应的JSON信息。

通过查看他的父级菜单的递归内部的list集合，大致有一个数据的结构

```json
{
    "code": 0,
    "msg": "",
    "data": [
        {"id": 1,"parentId": 0,"url": "","icron": "fa fa-cog", "type": 0,"list": [
   			{"id": 2,"parentId": 1,"url": "sys/user.html","icron": "fa fa-cog", "type": 1},
			{"id": 3,"parentId": 1,"url": "sys/role.html","icron": "fa fa-cog", "type": 1}
			…………
        ]},
		{"id": 56,"parentId": 0,"url": "","icron": "fa fa-cog", "type": 0,"list":[
		……
    ]
}
```

1、准备一个接口文档

```json
# 登录接口文档
请求路径 GET    http://localhost:8080/sys/menu/user

# 请求参数
无

# 处理流程
查询当前用户的导航菜单信息。
基于用户的id，根据角色表信息查询到菜单表中的详细内容
封装为具体的下述的这种结构

# 响应的数据结构
SUCCESS:
{
    "code": 0,
    "msg": "",
    "data": [
        {"id": 1,"parentId": 0,"url": "","icron": "fa fa-cog", "type": 0,"list": [
   		{"id": 2,"parentId": 1,"url": "sys/user.html","icron": "fa fa-cog", "type": 1},
		{"id": 3,"parentId": 1,"url": "sys/role.html","icron": "fa fa-cog", "type": 1}
		…………
        ]},
	{"id": 56,"parentId": 0,"url": "","icron": "fa fa-cog", "type": 0,"list":[
	……
    ]
}

FAIL:
{
  "code": 错误码,
  "msg": "错误信息"
}

```

2、开始编码

2.1、Controller层

```java
/**
 * 查询当前登录用户的菜单信息
 * @return
 */
@GetMapping("/menu/user")
public ResultVO menuUser() {
    // 基于用户的id，根据角色表信息查询到菜单表中的详细内容
    SmsUser smsUser = (SmsUser) SecurityUtils.getSubject().getPrincipal();
    if (smsUser == null) {
        log.info("【获取用户菜单信息】 用户未登录！！");
        return R.error(ExceptionEnums.NOT_LOGIN);
    }
    // 封装为具体的下述的这种结构
    List<Map<String, Object>> data = menuService.findUserMenu(smsUser.getId());
    if (data == null){
        log.error("【获取用户菜单信息】 查询用户菜单失败！！ id = {}",smsUser.getId());
        return R.error(ExceptionEnums.USER_MENU_ERROR);
    }
    // 返回结果
    return R.ok(data);
}
```

2.2、Service层

```java
@Override
public List<Map<String, Object>> findUserMenu(Integer id) {
    //1、将多表查询的结果直接映射，只查询type为0和type为1的数据， 查询到的结果顺序，是type正序排序
    List<Map<String, Object>> list = menuMapper.findMenuByUserId(id);

    //2、封装外层的父级菜单封装到当前的List集合
    List<Map<String, Object>> data = new ArrayList<>();
    //3、使用迭代器遍历所有的菜单信息，封装父级菜单
    ListIterator<Map<String, Object>> parentIterator = list.listIterator();
    while (parentIterator.hasNext()) {
        Map<String, Object> menu = parentIterator.next();
        if ((int) menu.get("type") == 0) {
            // 是父级菜单
            data.add(menu);
            parentIterator.remove();
        } else {
            break;
        }
    }
    //4、存放二级菜单
    for (Map<String, Object> parentMenu : data) {
        List<Map<String, Object>> sonMenuList = new ArrayList<>();
        ListIterator<Map<String, Object>> sonIterator = list.listIterator();
        while (sonIterator.hasNext()) {
            Map<String, Object> sonMenu = sonIterator.next();
            if ((long) parentMenu.get("id") == (long) sonMenu.get("parentId")) {
                sonMenuList.add(sonMenu);
                sonIterator.remove();
            }
        }
        parentMenu.put("list", sonMenuList);
    }
    //5、返回data
    return data;
}
```

2.3、Mapper层

```xml
<!--    /**-->
<!--    * 根据用户id查询当前用户的一级和二级菜单-->
<!--    * @param id-->
<!--    * @return-->
<!--    */-->
<!--    List<Map<String, Object>> findMenuByUserId(@Param("userId") Integer id)-->
<select id="findMenuByUserId" resultType="java.util.Map">
    select
        m.id id, m.name, m.parent_id parentId, m.url, m.icon, m.type
    from
        sms_menu m
    inner join sms_role_menu rm on m.id = rm.menu_id
    inner join sms_user_role ur on ur.role_id = rm.role_id
    where
        ur.user_id = 1
        and m.type in (0,1)
    order by m.type
</select>
```

### 8.3 解决页面跳转问题

发现因为查询菜单信息时，并没有返回页面需要的Permission信息，但是页面在跳转时，会基于是否传递了

Permission信息，决定是否能够跳转。将这个判断注释掉

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/7b344b6239a3491c9cc282ff7dea106a.png)

再次测试页面。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/61d57b934db9414b8ce084b233516bac.png)

## 九、搜索功能

### 9.1 搜索页面展示&分析

首先要完成短信搜索功能，页面跳转是根据数据库走的，直接在数据库中，将按钮跳转的页面直接修改一波![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/89f95de038f24771a2eda457eed184c4.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/fcc1b204d1494f028b229bbe1dfea880.png)

通过页面的抓包，可以看到页面需要两个数据。

一个是公司信息，也就是客户。（超级管理员看全部）

根据几个查询条件，去ES中做分页检索。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/61108c1e46554909a25da60f5407ddc3.png)

### 9.2 展示公司信息

登录的用户和客户信息是分开的。

这里用户和客户信息应当是一对多的关系。

为了让表之间建立联系，需要让客户信息中追加一个外键，直接利用extend1这种预留的扩展字段，作为用户id。

在查询公司信息时，如果当前用户是超级管理员，查询全部公司信息。

如果不是超级管理员，直接只让查询当前登录用户绑定的公司信息。

接口文档：

```json
接口路径：
	GET 	http://localhost:8080/sys/clientbusiness/all
请求参数：
	无
业务需求：
	在查询公司信息时，如果当前用户是超级管理员，查询全部公司信息。

	如果不是超级管理员，直接只让查询当前登录用户绑定的公司信息。
响应数据：
{
	"code": 0,
	"msg": "",
	"data" [
		{"id": 1,"corpname": "贾楷瑞科技公司"},
		…………
	]
}
```

#### 9.2.1 提供查询角色信息

这里就是根据用户的Id，查询角色的名称

```sql
select 
	name
from 
	sms_role sr
inner join 
	sms_user_role sur
on
	sr.id = sur.user_id
where 
  	sur.user_id = #{userId}
```

#### 9.2.2 提供查询客户信息

提供两个查询

```java
@Service
public class ClientBusinessServiceImpl implements ClientBusinessService {

    @Resource
    private ClientBusinessMapper clientBusinessMapper;

    @Override
    public List<ClientBusiness> findAll() {
        List<ClientBusiness> list = clientBusinessMapper.selectByExample(null);
        return list;
    }

    @Override
    public List<ClientBusiness> findByUserId(Integer userId) {
        ClientBusinessExample example = new ClientBusinessExample();
        example.createCriteria().andExtend1EqualTo(userId + "");
        List<ClientBusiness> list = clientBusinessMapper.selectByExample(example);
        return list;
    }
}
```

#### 9.2.3 测试接口

完成Controller的整体操作

```java
@Autowired
private SmsRoleService roleService;

@Autowired
private ClientBusinessService clientBusinessService;


@GetMapping("/sys/clientbusiness/all")
public ResultVO all(){
    //1、拿到当前登录用户的信息
    SmsUser smsUser = (SmsUser) SecurityUtils.getSubject().getPrincipal();
    if(smsUser == null){
        log.info("【获取客户信息】 用户未登录！！");
        return R.error(ExceptionEnums.NOT_LOGIN);
    }
    Integer userId = smsUser.getId();
    //2、查询当前用户的角色信息
    Set<String> roleNameSet = roleService.getRoleName(userId);

    //3、根据角色信息查询数据即可。
    List<ClientBusiness> list = null;
    if(roleNameSet != null && roleNameSet.contains(WebMasterConstants.ROOT)){
        // 查询全部即可
        list = clientBusinessService.findAll();
    }else{
        // 根据用户id查询指定的公司信息
        list = clientBusinessService.findByUserId(userId);
    }
    List<ClientBusinessVO> data = new ArrayList<>();
    for (ClientBusiness clientBusiness : list) {
        ClientBusinessVO vo = new ClientBusinessVO();
        BeanUtils.copyProperties(clientBusiness,vo);
        data.add(vo);
    }
    //4、响应数据
    return R.ok(data);
}
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/5505dd8498254583bb38d7245d2b65fd.png)

### 9.3 完成短信内容搜索

#### 9.3.1 短信内容搜索接口分析

首先点击查询按钮时，页面会发送一个请求，通过抓包的形式，看一下传递了哪些数据

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/b45ad2c3dfc740d486b23d87977935f6.png)

接口文档

```json
# 搜索短信内容接口
请求路径：
	GET 	http://localhost:8080/sys/search/list

请求参数：
	from：猜测是页码,但是，他是起始索引
	size：每页展示数据条数
	content：全文检索短信内容（高亮）
	mobile：前缀匹配
	starttime：开始时间
	stoptime：结束时间
	clientID：客户ID

业务操作：
	正常接收参数，调用搜索模块完成短信内容的查询
	高亮啥的…………

响应数据格式：
{
	"code": 0,
	"msg": "",
	"rows": [
		{"corpname": "xx公司","sendTimeStr": 时间戳,"reportState": 0,"operatorId": 0,"errorCode": "发送失败原因","srcNumber": "106912387623347823","destMobile": "18010000000","messageContent": "【xx】您的…………"},
		{"corpname": "xx公司","sendTimeStr": 时间戳,"reportState": 0,"operatorId": 0,"errorCode": "发送失败原因","srcNumber": "106912387623347823","destMobile": "18010000000","messageContent": "【xx】您的…………"}
		…………
	],
	"total": 17

}
```

#### 9.3.2 完成搜索功能

正常编写Controller，映射请求，完成基本业务代码的编写

##### 9.3.2.1 参数相关校验

优先完成参数的校验，登录的用户查询的客户ID，要能否匹配上，或者没有传递客户ID，就查询当前登录用户所包含的全部客户ID。

```java
@RestController
@Slf4j
public class SearchController {

@Autowired
private SmsRoleService roleService;

@Autowired
private ClientBusinessService clientBusinessService;

@GetMapping("/sys/search/list")
public ResultVO list(@RequestParam Map map){
    //1、判断当前登录用户的角色，能否查询对应的客户信息
    //1.1 查看用户是否登录
    SmsUser smsUser = (SmsUser) SecurityUtils.getSubject().getPrincipal();
    if(smsUser == null){
        log.info("【获取客户信息】 用户未登录！！");
        return R.error(ExceptionEnums.NOT_LOGIN);
    }
    String clientIDStr = (String) map.get("clientID");
    Long clientID = null;
    if(!StringUtils.isEmpty(clientIDStr)){
        clientID = Long.parseLong(clientIDStr);
    }
    //1.2 拿到用户的id标识，查看用户的角色是否是管理员
    Set<String> roleNames = roleService.getRoleName(smsUser.getId());
    if(roleNames != null && !roleNames.contains(WebMasterConstants.ROOT)){
        //1.3 如果不是管理员，需要查询当前用户对应的公司信息，匹配参数中的公司id是否一致
        // 查询当前登录用户所包含的全部客户id（公司信息）
        List<ClientBusiness> clients = clientBusinessService.findByUserId(smsUser.getId());
        // 查看请求参数中携带的clientID
        if(clientID == null){
            // 客户没有传递clientID，查询当前用户锁拥有的全部客户的短信信息
            List<Long> list = new ArrayList<>();
            for (ClientBusiness client : clients) {
                list.add(client.getId());
            }
            map.put("clientID",list);
        }else{
            boolean flag = false;
            // 客户传递了clientID，判断当前登录用户是否包含当前clientID
            for (ClientBusiness client : clients) {
                if (client.getId() == clientID) {
                    // 满足当前登录用户的操作，可以查询
                    flag = true;
                    break;
                }
            }
            if (!flag){
                // 请求参数不满足当前登录用户的信息
                log.info("【搜索短信信息】 用户权限不足！！");
                return R.error(ExceptionEnums.SMS_NO_AUTHOR);
            }
        }
    }

  
    //2、调用搜索模块查询数据，返回total和rows

    //3、判断返回的total，如果total为0，正常返回

    //4、如果数据正常，做返回数据的封装

    //5、响应数据
    return null;
}
```

##### 9.3.2.2 完成调用search&数据封装

```java
@RestController
@Slf4j
public class SearchController {

    @Autowired
    private SmsRoleService roleService;

    @Autowired
    private SearchClient searchClient;

    @Autowired
    private ClientBusinessService clientBusinessService;

    @GetMapping("/sys/search/list")
    public ResultVO list(@RequestParam Map map) {
        // 省略参数校验
        //2、调用搜索模块查询数据，返回total和rows
        Map<String, Object> data = searchClient.findSmsByParameters(map);

        //3、判断返回的total，如果total为0，正常返回
        Long total = Long.parseLong(data.get("total") + "");
        if (total == 0) {
            return R.ok();
        }
        //4、如果数据正常，做返回数据的封装，声明SearchSmsVO的实体类，
        List<Map> list = (List<Map>) data.get("rows");
        List<SearchSmsVO> rows = new ArrayList<>();
        try {
            BeanUtils.copyProperties(list, rows);
        } catch (Exception e) {
            e.printStackTrace();
        }

        //5、响应数据
        return R.ok(total, rows);
    }


}
```

##### 9.3.2.3 测试webMaster端的Controller

问题1：没有导入Nacos依赖。

导入好Nacos依赖，配置启动类和配置文件。

问题2：没有给FeignClient的接口添加注解

给FeignClient接口添加PostMapping以及，给参数追加好RequestBody

情况1：在调用Search服务查询短信记录时，map中传递的clientID可能有多种多样的形式，可能是空串，可能是数值，可能是ArrayList
情况2：时间传递的都是时间戳，需要自己转换一波。

##### 9.3.2.4 完成搜索模块

在搜索模块中映射WebMaster中的searchClient接口，并接收好参数。在Service中，拿到全部参数，并且对ClientID做一些转换

```java
@Override
public Map<String, Object> findSmsByParameters(Map<String, Object> parameters) {
    //1、声明SearchRequest(后期需要根据传递的时间指定查询哪些索引，如果没传，可以指定默认查询前三个月)
    SearchRequest request = new SearchRequest(SearchUtils.getCurrYearIndex(),"");

    //2、封装查询条件
    //2.1 参数全部取出来
    Object fromObj = parameters.get("from");
    Object sizeObj = parameters.get("size");
    Object contentObj = parameters.get("content");
    Object mobileObj = parameters.get("mobile");
    Object startTimeObj = parameters.get("starttime");
    Object stopTimeObj = parameters.get("stoptime");
    Object clientIDObj = parameters.get("clientID");

    //2.2 clientID需要单独操作一下。
    List<Long> clientIDList = null;
    if(clientIDObj instanceof List){
        // 传递的是个集合
        clientIDList = (List) clientIDObj;
    }else if(!ObjectUtils.isEmpty(clientIDObj)){
        clientIDList = Collections.singletonList(Long.parseLong(clientIDObj + ""));
    }

    //3、执行查询

    //4、封装数据

    //5、返回数据
    return null;
}
```

下面准备完成条件的封装以及查询操作，并完成数据的封装，最后找页面做显示

参数封装的代码

```java
@Override
public Map<String, Object> findSmsByParameters(Map<String, Object> parameters) {
    //1、声明SearchRequest(后期需要根据传递的时间指定查询哪些索引，如果没传，可以指定默认查询前三个月)
    SearchRequest request = new SearchRequest(SearchUtils.getCurrYearIndex(), "");

    //2、封装查询条件
    //2.1 参数全部取出来
    Object fromObj = parameters.get("from");
    Object sizeObj = parameters.get("size");
    Object contentObj = parameters.get("content");
    Object mobileObj = parameters.get("mobile");
    Object startTimeObj = parameters.get("starttime");
    Object stopTimeObj = parameters.get("stoptime");
    Object clientIDObj = parameters.get("clientID");

    //2.2 clientID需要单独操作一下。
    List<Long> clientIDList = null;
    if (clientIDObj instanceof List) {
        // 传递的是个集合
        clientIDList = (List) clientIDObj;
    } else if (!ObjectUtils.isEmpty(clientIDObj)) {
        clientIDList = Collections.singletonList(Long.parseLong(clientIDObj + ""));
    }
    //2.3 条件封装
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    // ========================封装查询条件到boolQuery========================================
    //2.3.1、关键字
    if (!ObjectUtils.isEmpty(contentObj)) {
        boolQuery.must(QueryBuilders.matchQuery("text", contentObj));
        // 高亮。设置给sourceBuilder
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("text");
        highlightBuilder.preTags("<span style='color: red'>");
        highlightBuilder.postTags("</span>");
        sourceBuilder.highlighter(highlightBuilder);
    }

    //2.3.2、手机号
    if (!ObjectUtils.isEmpty(mobileObj)) {
        boolQuery.must(QueryBuilders.prefixQuery("mobile", (String) mobileObj));
    }

	//2.3.6 分页查询
    sourceBuilder.from(Integer.parseInt(fromObj + ""));
    sourceBuilder.size(Integer.parseInt(sizeObj + ""));

    //2.3.3、开始时间
    if(!ObjectUtils.isEmpty(startTimeObj)){
        boolQuery.must(QueryBuilders.rangeQuery("sendTime").gte(startTimeObj));
    }

    //2.3.4、结束时间
    if(!ObjectUtils.isEmpty(stopTimeObj)){
        boolQuery.must(QueryBuilders.rangeQuery("sendTime").lte(stopTimeObj));
    }

    //2.3.5、客户id
    if(clientIDList != null){
        boolQuery.must(QueryBuilders.termsQuery("clientId",clientIDList.toArray(new Long[]{})));
    }


    // ========================封装查询条件到boolQuery========================================
    sourceBuilder.query(boolQuery);
    request.source(sourceBuilder);

    //3、执行查询

    //4、封装数据

    //5、返回数据
    return null;
}
```

查询操作，并完成数据的封装

```java
@Override
public Map<String, Object> findSmsByParameters(Map<String, Object> parameters) throws IOException {
    //1、声明SearchRequest(后期需要根据传递的时间指定查询哪些索引，如果没传，可以指定默认查询前三个月)
    SearchRequest request = new SearchRequest(SearchUtils.getCurrYearIndex(), "");

    //2、封装查询条件
    //2.1 参数全部取出来
    Object fromObj = parameters.get("from");
    Object sizeObj = parameters.get("size");
    Object contentObj = parameters.get("content");
    Object mobileObj = parameters.get("mobile");
    Object startTimeObj = parameters.get("starttime");
    Object stopTimeObj = parameters.get("stoptime");
    Object clientIDObj = parameters.get("clientID");

    //2.2 clientID需要单独操作一下。
    List<Long> clientIDList = null;
    if (clientIDObj instanceof List) {
        // 传递的是个集合
        clientIDList = (List) clientIDObj;
    } else if (!ObjectUtils.isEmpty(clientIDObj)) {
        clientIDList = Collections.singletonList(Long.parseLong(clientIDObj + ""));
    }
    //2.3 条件封装
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    // ========================封装查询条件到boolQuery========================================
    //2.3.1、关键字
    if (!ObjectUtils.isEmpty(contentObj)) {
        boolQuery.must(QueryBuilders.matchQuery("text", contentObj));
        // 高亮。设置给sourceBuilder
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("text");
        highlightBuilder.preTags("<span style='color: red'>");
        highlightBuilder.postTags("</span>");
        sourceBuilder.highlighter(highlightBuilder);
    }

    //2.3.2、手机号
    if (!ObjectUtils.isEmpty(mobileObj)) {
        boolQuery.must(QueryBuilders.prefixQuery("mobile", (String) mobileObj));
    }

    //2.3.3、开始时间
    if(!ObjectUtils.isEmpty(startTimeObj)){
        boolQuery.must(QueryBuilders.rangeQuery("sendTime").gte(startTimeObj));
    }

    //2.3.4、结束时间
    if(!ObjectUtils.isEmpty(stopTimeObj)){
        boolQuery.must(QueryBuilders.rangeQuery("sendTime").lte(stopTimeObj));
    }

    //2.3.5、客户id
    if(clientIDList != null){
        boolQuery.must(QueryBuilders.termsQuery("clientId",clientIDList.toArray(new Long[]{})));
    }

    //2.3.6 分页查询
    sourceBuilder.from(Integer.parseInt(fromObj + ""));
    sourceBuilder.size(Integer.parseInt(sizeObj + ""));


    // ========================封装查询条件到boolQuery========================================
    sourceBuilder.query(boolQuery);
    request.source(sourceBuilder);

    //3、执行查询
    SearchResponse resp = restHighLevelClient.search(request, RequestOptions.DEFAULT);

    //4、封装数据
    long total = resp.getHits().getTotalHits().value;
    List<Map> rows = new ArrayList<>();
    for (SearchHit hit : resp.getHits().getHits()) {
        Map<String, Object> row = hit.getSourceAsMap();
        List sendTime = (List) row.get("sendTime");
        String sendTimeStr = listToDateString(sendTime);
        row.put("sendTimeStr",sendTimeStr);
        row.put("corpname",row.get("sign"));
        rows.add(row);
    }
    //5、返回数据
    Map<String, Object> result = new HashMap<>();
    result.put("total",total);
    result.put("rows",rows);
    return result;
}

private String listToDateString(List sendTime) {
    String year = sendTime.get(0) + "";
    Integer monthInt = (Integer) sendTime.get(1);
    Integer dayInt = (Integer) sendTime.get(2);
    Integer hourInt = (Integer) sendTime.get(3);
    Integer minuteInt = (Integer) sendTime.get(4);
    Integer secondInt = (Integer) sendTime.get(5);

    String month = monthInt / 10 == 0 ? "0" + monthInt : monthInt + "";
    String day = dayInt / 10 == 0 ? "0" + dayInt : dayInt + "";
    String hour = hourInt / 10 == 0 ? "0" + hourInt : hourInt + "";
    String minute = minuteInt / 10 == 0 ? "0" + minuteInt : minuteInt + "";
    String second = secondInt / 10 == 0 ? "0" + secondInt : secondInt + "";
    return year + "-" + month + "-" + day + " " + hour + ":" + month + ":" + second;
}
```

页面做显示，高连显示没效果。 时间是因为之前的序列化方式，导致ES存储格式无法做筛选

```java
@GetMapping("/sys/search/list")
public ResultVO list(@RequestParam Map map) {
    //1、判断当前登录用户的角色，能否查询对应的客户信息
    //1.1 查看用户是否登录
    SmsUser smsUser = (SmsUser) SecurityUtils.getSubject().getPrincipal();
    if (smsUser == null) {
        log.info("【获取客户信息】 用户未登录！！");
        return R.error(ExceptionEnums.NOT_LOGIN);
    }
    String clientIDStr = (String) map.get("clientID");
    Long clientID = null;
    if (!StringUtils.isEmpty(clientIDStr)) {
        clientID = Long.parseLong(clientIDStr);
    }
    //1.2 拿到用户的id标识，查看用户的角色是否是管理员
    Set<String> roleNames = roleService.getRoleName(smsUser.getId());
    if (roleNames != null && !roleNames.contains(WebMasterConstants.ROOT)) {
        //1.3 如果不是管理员，需要查询当前用户对应的公司信息，匹配参数中的公司id是否一致
        // 查询当前登录用户所包含的全部客户id（公司信息）
        List<ClientBusiness> clients = clientBusinessService.findByUserId(smsUser.getId());
        // 查看请求参数中携带的clientID
        if (clientID == null) {
            // 客户没有传递clientID，查询当前用户锁拥有的全部客户的短信信息
            List<Long> list = new ArrayList<>();
            for (ClientBusiness client : clients) {
                list.add(client.getId());
            }
            map.put("clientID", list);
        } else {
            boolean flag = false;
            // 客户传递了clientID，判断当前登录用户是否包含当前clientID
            for (ClientBusiness client : clients) {
                if (client.getId() == clientID) {
                    // 满足当前登录用户的操作，可以查询
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                // 请求参数不满足当前登录用户的信息
                log.info("【搜索短信信息】 用户权限不足！！");
                return R.error(ExceptionEnums.SMS_NO_AUTHOR);
            }
        }
    }


    //2、调用搜索模块查询数据，返回total和rows
    Map<String, Object> data = searchClient.findSmsByParameters(map);

    //3、判断返回的total，如果total为0，正常返回
    Long total = Long.parseLong(data.get("total") + "");
    if (total == 0) {
        return R.ok(0L,null);
    }
    //4、如果数据正常，做返回数据的封装，声明SearchSmsVO的实体类，
    List<Map> list = (List<Map>) data.get("rows");
    List<SearchSmsVO> rows = new ArrayList<>();
    // 遍历集合，封装数据
    for (Map row : list) {
        SearchSmsVO vo = new SearchSmsVO();
        try {
            BeanUtils.copyProperties(vo,row);
        } catch (Exception e) {
            e.printStackTrace();
        }
        rows.add(vo);
    }

    //5、响应数据
    return R.ok(total, rows);
}
```

高亮的结果不是在返回的source里，而是单独的highlight里面，需要单独的设置给响应结果中。

主要是搜索模块封装数据没有封装对。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/01d6777cbc7d4230ba48b5d8e8155282.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1690528726017/5ae9a162613c4ddb84aca453001aa3c8.png)
