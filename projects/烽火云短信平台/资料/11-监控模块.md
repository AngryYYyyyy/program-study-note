# 监控模块

## 一、需求分析

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/601eed8b4424455f94c5332b1d4cff88.png)

监控模块主要是要完成一些定时任务的操作，并不是监控CPU或者内存之类的。

这里主要完成两个定时任务：

* 监控大量的队列消息数量，在出现消息堆积时，第一时间做出反应。
* 监控客户剩余的金额，如果金额少于某个数值，需要第一时间给客户发送信息或者邮件通知。

在分布式微服务环境下的分布式调度，一般的选择就俩：

* Elastic-Job
* XXL-Job

这里因为Elastic-Job依赖于Zookeeper，使用成本太高了。不选择Elastic-Job。

XXL-Job依赖MySQL，直接上XXL-Job操作更简单。

最终基于XXL-Job去实现上述的两个业务操作。

## 二、搭建XXL-Job

这里依然是基于Docker的形式，将XXL-Job搭建起来，优先准备一个docker-compose.yml文件

这里的MySQL直接使用虚拟机安装8.x的MySQL服务，尝试了MySQL5.7，发现xxl-job:2.3.1不支持，直接将版本升级到8.x的MySQL

```yml
version: '3.1'
services:
  mysql:
    image: mysql:8.0.24
    container_name: mysql
    ports:
      - 3306:3306
    environment:
      - MYSQL_ROOT_PASSWORD=root
    volumes:
      - ./data/:/var/lib/mysql/
```

在这个MySQL中创建一个xxl_job的库，然后导入这个脚本，创建好表。

```sql
#
# XXL-JOB v2.3.1
# Copyright (c) 2015-present, xuxueli.

CREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci;
use `xxl_job`;

SET NAMES utf8mb4;

CREATE TABLE `xxl_job_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_desc` varchar(255) NOT NULL,
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
  `schedule_type` varchar(50) NOT NULL DEFAULT 'NONE' COMMENT '调度类型',
  `schedule_conf` varchar(128) DEFAULT NULL COMMENT '调度配置，值含义取决于调度类型',
  `misfire_strategy` varchar(50) NOT NULL DEFAULT 'DO_NOTHING' COMMENT '调度过期策略',
  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
  `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
  `trigger_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
  `trigger_last_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '上次调度时间',
  `trigger_next_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '下次调度时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
  `trigger_code` int(11) NOT NULL COMMENT '调度-结果',
  `trigger_msg` text COMMENT '调度-日志',
  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
  `handle_code` int(11) NOT NULL COMMENT '执行-状态',
  `handle_msg` text COMMENT '执行-日志',
  `alarm_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
  PRIMARY KEY (`id`),
  KEY `I_trigger_time` (`trigger_time`),
  KEY `I_handle_code` (`handle_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_log_report` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',
  `running_count` int(11) NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',
  `suc_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',
  `fail_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_logglue` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_registry` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(255) NOT NULL,
  `registry_value` varchar(255) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
  `title` varchar(12) NOT NULL COMMENT '执行器名称',
  `address_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
  `address_list` text COMMENT '执行器地址列表，多地址逗号分隔',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '账号',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `role` tinyint(4) NOT NULL COMMENT '角色：0-普通用户、1-管理员',
  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_username` (`username`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `xxl_job_lock` (
  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
  PRIMARY KEY (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, 'xxl-job-executor-sample', '示例执行器', 0, NULL, '2018-11-03 22:21:31' );
INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, '测试任务1', '2018-11-03 22:21:31', '2018-11-03 22:21:31', 'XXL', '', 'CRON', '0 0 0 * * ? *', 'DO_NOTHING', 'FIRST', 'demoJobHandler', '', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2018-11-03 22:21:31', '');
INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);
INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( 'schedule_lock');

commit;
```

这里是准备的是xxl-job的yml文件

```yml
version: '3.1'
services:
  xxl-job:
    restart: always
    image: xuxueli/xxl-job-admin:2.3.1
    container_name: xxl-job
    volumes:
      - ./logs/:/data/applogs
    ports:
      - 8080:8080
    environment:
      PARAMS: '
        --spring.datasource.url=jdbc:mysql://192.168.11.88:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8
        --spring.datasource.username=root
        --spring.datasource.password=root'
```

当启动成功后，查看日志

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/89cc37739e4d422fb49e45476b9f076c.png)

没有问题后，直接访问8080端口。

需要指定好路径： http://192.168.11.88/xxl-job-admin

默认的用户名和密码是admin，123456![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/53671d55ed4c48288078248e29104cff.png)

整理一下遇到的坑：

* xxl-job的2.3.1对MySQL的5.7版本支持不好。
* 安装MySQL8.x的时候，发现无法连接，最后发现是虚拟机防火墙的问题，需要启动再关闭防火墙。
* 采用docker启动时，报错，ipv4什么的错误，只需要重启docker即可。

## 三、搭建监控模块

### 3.1 搭建工程

构建工程：…………

导入依赖：

```xml
<dependencies>
    <!--        web-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--        nacos注册-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--        nacos配置-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--        公共模块-->
    <dependency>
        <groupId>com.mashibing</groupId>
        <artifactId>beacon-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

编写启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class MonitorStarterApp {

    public static void main(String[] args) {
        SpringApplication.run(MonitorStarterApp.class,args);
    }

}
```

编写配置文件

```yml
# 服务名称
spring:
  application:
    name: beacon-monitor
  # 多环境
  profiles:
    active: dev
  # nacos注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 114.116.226.76:8848
      # nacos配置中心地址:
      config:
        server-addr: 114.116.226.76:8848
        file-extension: yml
        # beacon-monitor-dev.yml
# ===============nacos====================
# 端口号
server:
  port: 18888
```

启动项目测试

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/36640faef68d44d6bf05bf6252cd045b.png)

### 3.2 注册XXL-JOB服务

导入依赖

```xml
<!--        xxl-job的依赖-->
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
    <version>2.3.1</version>
</dependency>
```

编写配置文件

```yml
# xxl-job的基本配置
xxl:
  job:
    admin:
      ## 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行"执行器心跳注册"和"任务结果回调"；为空则关闭自动注册；
      addresses: http://192.168.11.88:8080/xxl-job-admin
    ### 执行器通讯TOKEN [选填]：非空时启用；
    accessToken:
    executor:
      ### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册
      appname: xxl-job-executor-sample
      ### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。
      address:
      ### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 "执行器注册" 和 "调度中心请求并触发任务"；
      ip:
      ### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；
      port: 9999
      ### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；
      logpath: ./xxl-job/jobhandler
      ### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；
      logretentiondays: 30
```

编写配置类

```java
@Configuration
@Slf4j
public class XxlJobConfig {

    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;

    @Value("${xxl.job.accessToken}")
    private String accessToken;

    @Value("${xxl.job.executor.appname}")
    private String appname;

    @Value("${xxl.job.executor.address}")
    private String address;

    @Value("${xxl.job.executor.ip}")
    private String ip;

    @Value("${xxl.job.executor.port}")
    private int port;

    @Value("${xxl.job.executor.logpath}")
    private String logPath;

    @Value("${xxl.job.executor.logretentiondays}")
    private int logRetentionDays;


    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        log.info(">>>>>>>>>>> xxl-job config init.");
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
        xxlJobSpringExecutor.setAppname(appname);
        xxlJobSpringExecutor.setIp(ip);
        xxlJobSpringExecutor.setPort(port);
        xxlJobSpringExecutor.setAccessToken(accessToken);
        xxlJobSpringExecutor.setLogPath(logPath);
        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
        return xxlJobSpringExecutor;
    }
}
```

启动测试，发现出现了 The access token is wrong的错误，咱们是按照官方文档走的，正常来说没问题。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/067e815b4ccc45ed8fd2f9d95600b3da.png)

查看Github上的Issue

https://github.com/xuxueli/xxl-job/issues/3008![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/df0da67a6b0442b084019fb94e7815b2.png)

更改xxl-job的调度中心，将2.3.1的版本修改为2.3.0。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/210e0fac68a74bb283eb6a132f0964ff.png)

重新启动容器后，查看调度中心的注册机器信息

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/4605b6ee4865425ea7e285a65bef9845.png)

### 3.3 测试任务调度

发现XXL-JOB提供了很多种方式去执行定时任务。

可以基于XXL-JOB平台提供的一个简单方式，直接编写业务逻辑到调度中心。方式很简单，但是不推荐。

另外一个方式就是在执行器（SpringBoot工程）里面去编写好需要执行的任务的业务逻辑。同时在调度中心中指定好cron表达式，以及一些任务执行的高级特性。

在执行器端直接编写具体任务，并且任务的对象需要交给Spring容器管理

```java
@Component
@Slf4j
public class TestTask {

    @XxlJob("test")
    public void test(){
        // 编写任务逻辑
        log.info("Hello World!");
    }
}
```

搞定之后，在XXL-JOB的调度中心里面，维护好任务的执行周期和各种高级特性![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/646647f1c9de4873b3ee88518c1ea852.png)

启动任务后，查看效果

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1687712589082/cdce6728e1b84eba872fdc2a1df58da1.png)

## 四、监控队列消息

这里需要对核心业务中的一些队列做监控，主要是两个方向：

* api模块对接策略模块的sms_pre_send_topic
* 策略模块对接短信网关模块的sms_gateway_topic_channelId

导入依赖：

```xml
<!--        RabbitMQ依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
<!--        openFeign-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
<!--        JavaMail-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

```

编写定时任务逻辑

```java
/**
 * 监控队列中的消息个数，如果队列消息超过10000条，直接发送短信，通知。
 * @author 郑大仙丶
 * @version V1.0.0
 */
@Component
@Slf4j
public class MonitorQueueMessageCountTask {

    String text = "<h1>您的队列消息队列堆积了，队名为%s，消息个数为%s</1>";

    // 队列消息限制
    private final long MESSAGE_COUNT_LIMIT = 10000;

    // 查询队列名称的固定pattern
    private final String QUEUE_PATTERN = "channel:*";

    // 得到需要截取channelID的索引地址
    private final int CHANNEL_ID_INDEX = QUEUE_PATTERN.indexOf("*");

    // 注入RabbitMQ的ConnectionFactory
    @Autowired
    private ConnectionFactory connectionFactory;

    @Autowired
    private CacheClient cacheClient;

    @Autowired
    private MailUtil mailUtil;

    @XxlJob("monitorQueueMessageCountTask")
    public void monitor() throws MessagingException {
        //1、拿到所有的队列名称
        Set<String> keys = cacheClient.keys(QUEUE_PATTERN);



        //2、需要基于channel去操作
        Connection connection = connectionFactory.createConnection();
        Channel channel = connection.createChannel(false);
        listenQueueAndSendEmail(channel,RabbitMQConstants.SMS_PRE_SEND);
        for (String key : keys) {
            // 封装队列名称
            String queueName = RabbitMQConstants.SMS_GATEWAY + key.substring(CHANNEL_ID_INDEX);
            listenQueueAndSendEmail(channel, queueName);
        }




    }

    private void listenQueueAndSendEmail(Channel channel, String queueName) throws MessagingException {
        // 队列不存在，直接构建，如果已经存在，直接忽略
        try {
            channel.queueDeclare(queueName,true,false,false,null);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //3、拿到对应队列的消息，确认消息数量，超过限制，及时通知

        long count = 0;
        try {
            count = channel.messageCount(queueName);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if(count > MESSAGE_COUNT_LIMIT){
            //4、通知的方式就是发送短信。
            mailUtil.sendEmail(queueName + "队列消息堆积",String.format(text,queueName,count));
        }
    }


}
```

JavaMail的工具类：

```java
@Component
@RefreshScope
public class MailUtil {

    @Value("${spring.mail.username}")
    private String from;

    @Value("${spring.mail.tos}")
    private String tos;

    @Autowired
    private JavaMailSender javaMailSender;


    public void sendEmail(String subject,String text) throws MessagingException {
        // 构建MimeMessage对象
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();

        // 给邮件指定信息
        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage);
        helper.setFrom(from);
        helper.setTo(tos.split(","));
        helper.setSubject(subject);
        helper.setText(text);

        // 发送邮件
        javaMailSender.send(mimeMessage);
    }


}
```
