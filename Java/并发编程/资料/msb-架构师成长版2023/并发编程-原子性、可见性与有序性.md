# 并发编程-原子性、可见性与有序性

## 一、CPU的可见性

### 1.1 缓存一致性问题的出现

为了弥补处理器与主内存之间的性能差距，CPU引入了高级缓存机制。当CPU从主内存中拉取数据时，会将数据暂存于高速缓存中，以便于后续操作能够快速地从缓存中访问数据，从而避免了与主内存的频繁且耗时的交互，显著提升了处理效率。

随着现代硬件技术的进步，现代CPU通常采用多核设计，每个核都拥有自己的专属高速缓存。这种设计虽然提升了单核的处理能力，但同时也带来了新的挑战：当多个核心同时操作同一数据时可能会导致数据不一致的问题。即若一个核心对数据进行了修改，而这个修改未能及时反映到其他核心的缓存中，就可能导致各核心之间的数据不一致，从而影响程序的正确性和性能。为了解决这一问题，现代CPU架构采用了各种一致性协议和策略，如MESI协议，确保不同核心的缓存之间能够有效地同步数据。

### 1.2 CPU的高速缓存模型

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1700651989089/29e2184a9c6843ab8122a8ec0f01493b.png)

### 1.3 CPU缓存行

数据在高速缓存中不是以独立项来存储的，他的数据都存储在缓存行中，CacheLine。缓存行是CPU高速缓存的最小存储单位。

目前主流的CPU缓存的缓存行通常是64字节。

比如剖析开高速缓存，里面就是多个缓存行组成滴。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1700651989089/073e658170334167bd2750743a549176.png)

比如Java中一个long类型是8字节，一个缓存行最多就可以缓存8个Long类型数据。

### 1.4 MESI协议

MESI协议是一种缓存一致性协议，广泛用于现代多核处理器的设计中，以确保各个CPU核心之间缓存数据的一致性。MESI代表四种状态：修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）。这些状态帮助处理器管理各个核心的缓存，并在核心间有效地同步数据。下面详细解释这些状态：

1. **修改（Modified）**：
   - 此状态表示缓存行的数据已被当前CPU核心修改，但尚未写回到主内存中。
   - 此时，该数据在其他CPU核心的缓存中不存在，当前核心独占这个数据。
   - 由于数据仅在当前核心的缓存中存在且已被修改，这避免了数据冲突或不一致的问题。

2. **独占（Exclusive）**：
   - 表示当前核心缓存了数据，并且该数据未被修改，与主内存中的数据一致。
   - 该状态下的数据仅由当前CPU核心独占，尚未共享给其他核心。
   - 此状态数据安全，无并发修改的风险，允许当前核心读取或写入数据。

3. **共享（Shared）**：
   - 此状态表示缓存行的数据被多个CPU核心共享，并且所有核心的缓存数据与主内存中的值保持一致。
   - 任何核心都可以读取这个数据，但如果任一核心需要修改数据，必须首先将其他核心的缓存中该数据标记为无效（通过一致性协议的操作），然后才能进行修改。

4. **无效（Invalid）**：
   - 表示缓存行的数据是无效的，此状态下的数据不能被读取或写入。
   - 如果处理器需要访问该数据，它必须重新从主内存中加载数据，确保获取的是最新且有效的数据。

通过这些状态，MESI协议确保即使在多核处理器环境下，各个核心的缓存数据也能保持一致性，从而避免了数据冲突和一致性错误。这种机制是现代多核CPU高效运行的关键部分。

### 1.5 MESI是如何保证缓存一致性

MESI协议确保缓存一致性的机制基于每个缓存行的状态和处理器核心之间的通信。这种通信通常通过一种称为缓存一致性协议的机制实现，它使得处理器核心能够监听对共享数据的访问并作出适当响应。下面是如何通过不同状态的监听任务实现缓存一致性的详细说明：

1. **修改（Modified）状态的监听任务**：
   - 当一个缓存行处于修改状态时，该行的数据已被某个核心修改并且未同步到主内存。
   - 如果有其他核心尝试读取相同的内存地址，拥有该缓存行的核心必须在允许读取发生之前将数据写回主内存，并可能将自己的缓存行状态改为共享（Shared），以保证其他核心读取的是最新数据。

2. **独占（Exclusive）状态的监听任务**：
   - 当一个缓存行处于独占状态时，表明该数据只被一个核心缓存，并且数据未被修改，与主内存一致。
   - 如果有其他核心尝试读取这一内存地址，该核心必须将缓存行状态改为共享（Shared），允许多个核心共享未被修改的数据。

3. **共享（Shared）状态的监听任务**：
   - 在共享状态下，缓存行的数据被多个核心共享。
   - 如果有核心尝试修改这个缓存行的数据，所有其他核心中的相同缓存行必须被标记为无效（Invalid），以确保只有一个核心能写入新值，并在写入之后，其他核心需要重新从主内存加载新的数据值。

4. **无效（Invalid）状态的监听任务**：
   - 当缓存行处于无效状态时，任何试图读取或写入该缓存行的操作都需要从主内存重新加载数据，以确保操作的数据是最新且有效的。

通过这些详细的监听和响应机制，MESI协议能够动态地维护多个核心之间的数据一致性，防止了数据冲突和过时数据的问题，这对于现代多核处理器的高效运行是至关重要的。这种机制不仅提高了性能，也增加了程序的可靠性和正确性。

### 1.6 CPU写优化层面对MESI协议的影响

在现代CPU设计中，写优化技术如写缓冲器（Store Buffer）和无效化队列（Invalidate Queue）对MESI协议的实现和性能有重要影响。这些技术旨在提高处理器的效率，但同时也引入了缓存一致性的挑战。下面是这些技术如何影响MESI协议的具体解释：

1. **写缓冲器（Store Buffer）**:
   - 写缓冲器允许CPU将写操作暂存，而不是直接写入到L1缓存。这可以显著减少写操作的延迟，因为CPU不需要等待每次写操作完全完成。
   - 然而，如果数据还在写缓冲器中未被推送到L1缓存，其他核心对同一缓存行的读取可能无法触发必要的MESI状态变化（如将其他核心的缓存行标记为无效）。这可能导致数据不一致性。
2. **无效化队列（Invalidate Queue）**:
   - 无效化队列处理来自其他核心的无效化消息，这些消息通知一个核心其缓存中的数据已经过时。
   - 通过将无效化消息暂存于队列中，CPU可以继续执行其他操作，而不需要立即处理这些无效化消息。这减少了写操作的等待时间，但也可能导致延迟处理无效化，从而延迟更新缓存状态。

为了确保在使用写缓冲器和无效化队列的情况下维持缓存一致性，某些操作（如临界区内的操作）可能需要使用Lock前缀指令。

当使用Lock前缀指令时，执行的写操作将直接写回主内存，并确保相关的MESI协议操作（如无效化其他核心的缓存行）被立即触发，从而保持数据一致性。

这些优化技术在提高CPU性能的同时，也增加了维护缓存一致性的复杂性。MESI协议及其实现需要与这些技术紧密协作，确保即使在优化写操作的情况下，多核处理器之间的数据仍然保持一致。这种协调是现代多核处理器设计的关键部分，确保了性能与一致性的平衡。

## 二、CPU的原子性

在现代多核CPU中确保操作的原子性是非常重要的，尤其是在并发环境中。操作如简单的`i++`看似单一，但在CPU层面分解为多步骤，每一步都可能被其他核心的操作打断。这就是为什么CPU需要支持确保原子性的指令，例如通过`cmpxchg`（比较并交换）和`lock`指令。

### 1. cmpxchg 指令
- `cmpxchg`指令是用于比较并交换操作的CPU指令。它将寄存器中的值与内存中的值进行比较，如果相同，就用新值更新内存位置。
- 这个指令通常用于实现锁和同步原语，如CAS操作，它在并发编程中非常关键。

### 2. lock 指令
- `lock`前缀是用于保证指令执行原子性的CPU指令前缀。它确保附加的指令（如`cmpxchg`）在多核环境中安全执行，不受其他核心干扰。
- 使用`lock`前缀的指令在执行时，会禁止其他所有处理器访问相同的内存地址。

### 锁的两种机制：
1. **总线锁**：
   - 总线锁是通过阻止其他所有处理器访问系统总线来实现的。当处理器在执行带`lock`前缀的指令时，它会锁住总线，确保对内存的独占访问。
   - 这种方法虽然有效，但效率低下，因为它阻止了所有其他处理器的内存访问，无论它们是否访问相同的内存区域。

2. **缓存锁**：
   - 缓存锁是通过在缓存一致性协议（如MESI）中标记缓存行状态来实现的。当使用缓存锁时，CPU不是锁住整个总线，而是确保缓存行的独占访问。
   - 这种方式效率更高，因为它只限制对特定缓存行的访问，而不影响其他核心访问其它内存地址。

在处理器使用这些机制时，选择哪种锁的机制取决于具体操作的上下文和硬件的支持能力。在不能有效使用缓存锁的情况下，总线锁成为必要选择，尽管它的性能开销更大。通过这些复杂的锁机制和原子操作指令，现代CPU能够有效地在多核环境中运行复杂的多线程程序，同时保持数据一致性和操作的原子性。这些技术的应用极大地提高了多核处理器的性能和并发程序的可靠性。

**Lock前缀指令** 在Intel官方的一些文档信息：https://www.felixcloutier.com/x86/lock

## 三、CPU的有序性

在现代多核CPU中，指令重排序是提高执行效率的一种常用技术。处理器会根据执行单元的可用性、数据依赖关系以及其他因素自动调整指令的执行顺序。这种重排序遵循“as-if-serial”原则，确保在单线程环境下，即使指令顺序被改变，程序的执行结果仍与其编写顺序相同。然而，在多线程环境中，重排序可能会导致不同线程间的数据访问出现不一致性，从而影响程序的正确性。

为了控制和管理多线程环境下的指令重排序，以及确保内存操作的有序性和可见性，引入了内存屏障（又称内存围栏）。内存屏障是一种特殊的指令，用于在指定操作之间创建一个同步点，确保屏障前的操作在屏障后的操作之前完成。这对于维护跨多个处理器核心的数据一致性至关重要。

在x86架构中，常见的内存屏障包括：

1. **lfence（加载屏障）**:
   - `lfence`指令用于确保在该指令之后的所有加载操作（读操作）必须在屏障前的所有加载操作完成后才能执行。
   - 它主要用于防止加载操作之间的重排序。

2. **sfence（存储屏障）**:
   - `sfence`指令用于确保在该指令之前的所有存储操作（写操作）完成后，屏障后的存储操作才能执行。
   - 这个屏障用于控制写操作的执行顺序。

3. **mfence（全能屏障）**:
   - `mfence`是一种更强的屏障，结合了`lfence`和`sfence`的功能。
   - 它确保所有在屏障之前的加载和存储操作都完成后，才能开始执行屏障之后的任何加载或存储操作。

这些内存屏障对于编写多线程程序是非常重要的，特别是在涉及共享资源和需要严格操作顺序的场景中。通过适当使用这些屏障，开发者可以确保内存操作的正确顺序和数据在多核处理器之间的正确同步，从而避免由于编译器或处理器优化引起的潜在错误。

https://gee.cs.oswego.edu/dl/jmm/cookbook.html

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1700651989089/ae3649e78d1e4ba0bbd975c530636687.png)

mfence最终依然是 **lock前缀指令** 。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1700651989089/3771e17eb3eb429ea504487b6ab772e9.png)

## 四、JMM-Java内存模型

### JMM的关键特性

1. **原子性**：
   - 在Java中，基本的读写访问（如对非`long`和`double`类型的变量的读取和写入）是原子操作。
   - 对于复合操作（如递增操作`i++`），JMM不保证原子性，除非使用同步机制（如`synchronized`或`ReentrantLock`）。
   - Java的`Atomic`类（如`AtomicInteger`）使用了底层的CAS（比较并交换）操作，这通常是通过汇编语言中的`cmpxchg`指令实现，有时前面带有`lock`前缀以保证跨多个处理器的操作的原子性。

2. **可见性**：
   - Java提供`volatile`关键字，当一个变量被声明为`volatile`时，对这个变量的写会立即同步到主内存中，对这个变量的读会直接从主内存加载。
   - 这种行为通过禁止指令重排序和内存屏障来实现，确保不同线程之间对变量的操作具有可见性。

3. **有序性**：
   - 为了优化性能，编译器和处理器可能会对指令进行重排序。`volatile`变量的读写访问将作为内存屏障，禁止特定类型的指令重排序。
   - 对于`volatile`变量，写操作之前的所有操作在内存中的影响必须在写操作的影响之前发生，而写操作的影响必须在随后对该`volatile`变量的读操作的影响之前发生。

### 底层实现

- Java的`synchronized`关键字和`volatile`变量的行为背后，是对应的底层指令（如`lock`前缀指令和内存屏障）和协议（如MESI）的使用。这些机制确保了跨不同CPU和缓存架构的一致性和有序性。
- Java虚拟机（JVM）实现了这些规则，保证了Java程序在不同硬件平台上的行为一致性。通过抽象硬件的细节，JMM允许开发者编写在并发环境中安全且高效的代码，而不需要关心底层硬件的具体实现。

JMM是Java并发编程的核心部分，它的设计让Java程序能在各种平台上稳定运行，同时提供了必要的工具来处理多线程环境中的复杂性。通过了解JMM和相关的并发工具，Java开发者可以更好地理解和应用这些机制来编写正确和高效的多线程应用程序。
