# 一、面向过程与面向对象

## 1.1 面向过程

> - 基于“过程”的概念，主要关注完成的任务，按照步骤一步一步来进行。
> - 数据存储和函数是分开的。

## 1.2 面向过程

> - 基于“对象”的概念，主要关注对象和它们之间的交互。
> - 对象可以包含数据和操作数据的函数。
> - 通过封装、继承和多态提供代码复用。

# 二、类

## 2.1 类的定义

> C语言结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。
>
> 在C++中，类（Class）是面向对象编程的核心组成部分。它为现实生活中的实体和对象提供了一个模板或蓝图。
>
> 一个类描述了对象的属性（通常是变量或数据成员）和行为（通常是函数或方法）。
>
> C++中通过类可以将属性 以及方法进行完美结合，通过访问权限可以控制那些方法在类外可以被调用，即封装

```c++
class className
{
 // 类体：由成员函数和成员变量组成
}; 
```

## 2.2 类的访问限定符

> 描述数据成员和成员函数的可访问性。
>
> 使用这些访问修饰符可以实现**封装**，这是面向对象编程中的核心原则之一。封装确保对象的内部表示被隐藏起来，并仅通过清晰、定义明确的接口暴露必要的功能。这使得代码更容易维护，同时也为类提供了更好的控制权。
>
> 访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别

### （1）public

> - 定义为`public`的成员可以从任何地方访问，不论是类的内部还是外部。
> - 通常，一个类的主要接口（例如，构造函数和某些核心功能）都会被声明为公开的。

### （2）private

> - 定义为`private`的成员只能从类的内部访问。
> - 在C++中，这是类的默认访问修饰符。
> - 这用于封装和隐藏类的实现细节。

### （3）protected

> - 定义为`protected`的成员可以从类的内部和其派生类（子类）中访问，但不能从类的外部访问。
> - 这对于继承特别有用，允许子类访问基类中的特定成员，但仍然隐藏它们不被外部代码访问。

## 2.3 类的作用域

> 类定义了一个新的作用域，类的所有成员都在类的作用域中。==在类体外定义成员时，需要使用 :: 作用域操作符指明成员属于哪个类域==。

## 2.4 类的实例化

> 类的实例化在C++中意味着创建一个类的对象。一个类只是一个定义或原型，实例化它将创建一个实际的对象，该对象有类中定义的所有属性和行为。

## 2.5 类的对象大小

### 2.5.1 结构体对齐规则

> 第一个成员在与结构体偏移量为0的地址处。 
>
> 其他成员变量要对齐到对齐数的整数倍的地址处。 
>
> 注意：对齐数 = 编译器默认的一个对齐数与该成员大小的较小值。 ==VS中默认的对齐数为8==
>
> ==结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。== 
>
>  如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

### 2.5.2 类对象的存储方式

> 成员函数不会增加对象的大小，因为它们的代码存储在代码段中并在所有对象之间共享。==对象的大小主要取决于其成员变量，以及可能的对齐/填充字节和虚函数表指针（如果有虚函数的话）。==

#### （1）成员变量

> - 每个类对象的实例都包含它的成员变量。
> - 当你创建类的对象时，每个对象都有其自己的成员变量的一份拷贝。这些变量在内存的堆或栈中（取决于对象是动态分配的还是自动分配的）。
> - 如前所述，静态成员变量是一个例外，因为它们不属于特定的对象实例。它们在所有对象实例之间共享，并且存储在静态存储区域中。

#### （2）成员函数

> - 成员函数（包括构造函数和析构函数）的代码在程序的生命周期内只存储一次，在代码段或文本段中。当多个对象调用其成员函数时，它们都使用这段公共代码，但是`this`指针会根据特定的对象改变，这样函数知道它正在操作哪个对象的成员变量。
> - ==虚函数通过虚函数表（vtable）来实现。每个对象有一个指向其类的vtable的指针。vtable包含指向类的虚函数的指针。这是实现多态性的关键机制。==

### 2.5.3 相关面试题

#### （1） 为什么要进行内存对齐？

> - **性能优化**：对于许多计算机架构，访问对齐的内存比非对齐的内存更快。硬件访问内存时，通常在特定的地址边界上获取一个字或多个字节。如果数据跨越边界，可能需要额外的内存访问。
>   
> - **硬件限制**：一些硬件（如某些SPARC、RISC架构）不支持非对齐的访问；如果尝试这样做，会引发硬件异常。
>

#### （2） 什么是大小端？如何测试某台机器是大端还是小端，有没有遇到过要考虑大小端的场景？

> - **大端（Big-Endian）**：在多字节数据中，最高位字节在最低的内存地址处。
> - **小端（Little-Endian）**：在多字节数据中，最低位字节在最低的内存地址处。
>
> **大小端的考虑场景**:
>
> - **网络编程**：在网络数据传输中，通常使用大端格式，也称为网络字节顺序。
>
> - **文件I/O**：当读写二进制文件时，尤其是跨平台时。
>
> - **硬件交互**：与特定的硬件设备通信时，该设备可能有其自己的字节顺序规定。

**如何测试**:

```cpp
union //允许在相同的内存位置存储不同的数据类型
{
    int value;
    char byte[sizeof(int)];
} test;

test.value = 0x01020304;

if(test.byte[0] == 1) {
    printf("Big-Endian\n");
} else {
    printf("Little-Endian\n");
}
```

## 2.6 类的this指针

> `this` 是一个在 C++ 中常见的特殊指针，它代表了指向当前对象自身的指针。在类的非静态成员函数中，你可以使用 `this` 指针来引用当前对象及其成员。

### 2.6.1 this指针特性

> 对于类 `X`，`this` 的类型是 `X* const`，因此不能更改 `this` 指针所指向的位置，但可以修改它指向的对象的内容。
>
> ==`this`指针存在于函数的堆栈内存中。==

### 2.6.2 相关面试题

#### （1）**`this`指针存在哪里？**

> `this`指针存在于函数的堆栈内存中。当一个非静态成员函数被调用时，`this`指针作为该函数的一个隐式参数被传入。它不是对象的一部分，因此不占用对象的内存。`this`指针的值是在函数调用时决定的，指向调用该成员函数的对象。

#### （2）**`this`指针可以为空吗？**

在正常的情况下，`this`指针不会是`nullptr`。当你从一个对象上调用成员函数时，`this`指针被设置为指向该对象的地址。但是，在C++中，通过直接使用成员函数指针来调用一个类的非静态成员函数，而不为其提供有效的对象上下文，是可能的。在这种情况下，`this`指针的值可能是无效的，因为并没有通过this指针指向某一成员。但这是一个未定义行为，并且通常应该避免。

```cpp
class MyClass {
public:
    void printAddress() {
        std::cout << this << std::endl;//可以正常运行
    }
};

int main() {
    MyClass* ptr = nullptr;
    ptr->printAddress(); 
    return 0;
}
```

# 三、类的默认成员函数

## 3.1 类的六个默认成员函数

> 如果一个类中什么成员都没有，简称为空类。 空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
>
>  默认成员函数：用户没有显式实现，编译器会生成的成员函数称为默认成员函数。

![image-20230910153928625](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230910153928625.png)

```c++
class myClass
{
	myClass(){} //构造函数
	~myClass(){} //析构函数
    myClass(const&myClass copy){} //拷贝构造
    myClass& operator=(const&myClass copy) //赋值构造
};
```



## 3.2 构造函数

> 构造函数是一个特殊类型的类成员函数，当一个对象的生命周期开始时，它会被自动调用，用于初始化类的对象。

### 3.2.1 构造函数特性

> **自动调用**：当创建类的对象时，构造函数会自动被调用，且只能在该对象的声明周期内调用一次
>
> **无返回值**：构造函数不返回值，甚至不返回`void`。
>
> **可以重载**：类可以有多个构造函数，即构造函数可以重载。
>
> **初始化：**不是开空间创建对象，而是初始化对象
>
>  注意：==如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明==

### 3.2.2 默认构造函数

> 如果类中没有定义任何构造函数，编译器会自动为其提供一个默认的构造函数。但是，一旦用户为类定义了自己的构造函数，编译器将不再提供默认构造函数（除非用户明确地要求）。
>
> 默认的构造函数会对自定类型成员调用的他们自己的默认成员函数。
>
> 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。
>
> 注意：==无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数==。

### 3.2.3 初始化列表

> 初始化列表是C++中类构造函数的一种特性，允许在构造函数体执行之前初始化类的成员变量。
>
> 成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关

#### （1） 初始化常量成员
> 由于==常量成员在声明后不能再被修改，所以它们必须在初始化列表中被初始化==。

```cpp
class MyClass {
    const int myConst;
public:
    MyClass(int val) : myConst(val) { }
};
```

#### （2）初始化引用成员
> 同样地，==引用必须在创建时被初始化，并且之后不能改变引用的目标==。所以，引用成员必须在初始化列表中被初始化。

```cpp
class AnotherClass {
    int &ref;
public:
    AnotherClass(int &x) : ref(x) { }
};
```

#### （3） 用特定构造函数初始化成员对象
> ==当类的成员是其他类的对象时，你可能想使用那些对象的特定构造函数（没有默认构造函数）进行初始化。而构造函数只能调用一次==

```cpp
class MemberClass {
public:
    MemberClass(int x) { /* ... */ }
};

class ContainerClass {
    MemberClass member;
public:
    ContainerClass() : member(42) { }
};
```

### 3.2.4 explicit关键字

> 构造函数不仅可以构造与初始化对象，对于单个参数或者第一个参数无默认值的半缺省参数的构造函数，还具有类型转换的作用。
>
> 用explicit修饰构造函数，将会==禁止构造函数的隐式转换==。

## 3.3 析构函数

> 析构函数是一个特殊的成员函数，当一个对象的生命周期结束时，它会被自动调用，用于“清理”工作。

### 3.3.1 析构函数特性

> **自动调用**：析构函数在对象生命周期结束时自动被调用。对于局部对象，当控制流离开其作用域时；对于动态分配的对象，当使用 `delete` 关键字时；对于全局和静态对象，当程序结束时。
>
> **无参数无返回值**：析构函数不能有参数，也不能有返回值
>
> **可以重写**：可以（且经常需要）提供自己的版本来确保适当的资源清理
>
> **清理：**析构函数并不真正销毁对象的内存。它的主要职责是执行对象销毁前的清理操作，而实际的内存管理（分配和释放）是由编译器和/或运行时环境处理

### 3.3.2 默认析构函数

> 默认析构函数是当类中没有为其明确定义析构函数时，编译器自动生成的析构函数。
>
> 默认的析构函数会对自定类型成员调用的他们自己的默认析构函数。
>
> 如果类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数。

## 3.4 拷贝构造函数

> 只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型 对象创建新对象时由编译器自动调用。

### 3.4.1 拷贝构造函数特性

> 构造函数的一个重载形式
>
> 参数只有一个且必须是类类型对象的引用，传值过程是一种拷贝，会发生递归调用

### 3.4.2 默认拷贝构造函数

> 默认拷贝构造函数是当类中没有为其明确定义拷贝构造函数时，编译器自动生成的拷贝构造函数。
>
> 按内存存储按字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝

#### （1）浅拷贝

> 当进行浅拷贝时，只是复制对象的成员值，如果成员值是指针，则只复制指针值而不复制指针所指向的内容

#### （2）深拷贝

> 进行深拷贝时，不仅复制对象的所有成员值，而且为每个动态分配的资源创建一个新的副本。这意味着每个对象将有其独立的资源副本。

### 3.4.2 应用场景

```c++
//共发生三次拷贝
Date Test(Date d)//函数参数类型为类类型对象
{
 Date temp(d);//使用已存在对象创建新对象 
 return temp;//函数返回值类型为类类型对象
}
int main()
{
 Date d1(2022,1,13);
 Test(d1);
 return 0;
}
```



## 3.5 赋值运算符重载

### 3.5.1 运算符重载

> 运算符重载是C++中一个强大的特性，它允许开发者定义或重新定义大部分C++内置运算符的行为，使之适用于自定义的数据类型。

#### （1）基本规则

> ==**不是所有运算符都可以重载**：`.`, `.*`, `::`, `sizeof`等不能被重载==
>
> **保持语义一致性**：重载的运算符应该尽量保持与原有运算符相似的语义，以避免混淆。例如，不应该使`+`运算符执行减法。
>
> **至少有一个操作数是用户定义的类型**：例如，我们不能重载整数的`+`运算符。
>
> **重载的运算符应该作为类的成员函数或非成员（但友元）函数来定义**。成员函数的第一个参数为隐藏的this。

### 3.5.2 赋值运算符重载

#### （1）赋值运算符重载格式

> 参数类型：const T&，传递引用可以提高传参效率 
>
> 返回值类型：T&，this指向的对象函数结束后不会销毁，返回引用可以提高返回的效率，==有返回值目的是为了支持连续赋值== 
>
> ==检测是否自己给自己赋值==
>
> 返回*this ：要复合连续赋值的含义

#### （2）赋值运算符重载特性

> 赋值运算符只能重载成类的成员函数不能重载成全局函数
>
> 用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝，如果类中未涉及到资源管理，赋值运算符是否实现都可以，一旦涉及到资源管理则必须要实现，即需要深拷贝

### 3.5.3 前置++和后置++

#### （1）前置`++`

> 先增加值，然后返回对象的引用

```c++
 // 前置 ++
    Integer& operator++() {
        ++value;
        return *this;
    }
```



#### （2）后置`++`

> ==先保存对象的当前状态，然后增加其值，并返回旧的对象值==

```c++
// 后置 ++
    // 注意这里的额外的int参数。它只是用于在重载中区分前置和后置++，实际在调用时并不需要为它提供值。
	//并且返回的值是临时对象，不能用引用
    Integer operator++(int) {
        Integer temp(*this); // 保存当前的值
        ++value;             // 增加当前的值
        return temp;         // 返回旧的值
    }
```

## 3.6 取地址及const取地址操作符重载

### 3.6.1 const成员

#### （1）成员函数

> 当你在一个成员函数声明后面使用`const`关键字时，它表明这个成员函数不会修改调用它的对象。
>
> 如果一个对象被声明为`const`，则只能调用该对象的`const`成员函数

#### （2）数据成员

> 当你声明一个数据成员为`const`时，这意味着它的值一旦在构造函数中初始化后就不能再被修改。
>
> `const`数据成员必须在构造函数的初始化列表中被初始化，并且不能在其他地方或其他函数中被修改。

### 3.6.2 取地址及const取地址操作符重载

> 在C++中，取地址运算符(`operator&`)和`const`取地址运算符都可以被重载。但是，这种做法通常并不推荐，因为它可能导致意想不到的副作用和混淆。

```c++
MyClass* operator&() {
        std::cout << "Overloaded address-of operator called!" << std::endl;
        return this;
    }
//处理const对象
const MyClass* operator&() const {
        std::cout << "Overloaded address-of operator for const objects called!" << std::endl;
        return this;
    }
```







