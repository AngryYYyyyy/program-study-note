# 学习目标

> 掌握常见特殊类的设计方式

# 特殊类设计

### 1、请设计一个类，不能被拷贝

> 拷贝只会放生在两个场景中：拷贝构造函数以及赋值运算符重载，因此想要让一个类禁止拷贝， 只需让该类==不能调用拷贝构造函数以及赋值运算符重载==即可。

```c++
class CopyBan
{
    // ...
    CopyBan(const CopyBan&)=delete;
    CopyBan& operator=(const CopyBan&)=delete;
    //...
};
```



### 2、请设计一个类，只能在堆上创建

> 将类的==构造函数私有，拷贝构造、赋值操作符成私有==。防止别人调用拷贝在栈上生成对象和声明对象。
>
>  ==提供一个静态的成员函数==，在该静态成员函数中完成堆对象的创建

```c++
class HeapOnly {
private:
    // 私有构造函数
    HeapOnly() {}
    // 私有拷贝构造函数
    HeapOnly(const HeapOnly&) {}
    // 私有赋值操作符
    HeapOnly& operator=(const HeapOnly&) { return *this; }
public:
    // 公共的静态成员函数用于创建对象
    static HeapOnly* CreateInstance() {
        return new HeapOnly();
    }
    // 允许对象自行销毁
    void DestroyInstance() {
        delete this;
    }
};
```

> 也可以通过析构函数私有

### 3、请设计一个类，只能在栈上创建

> - **操作符`new`和`delete`的删除**：通过将`operator new`和`operator delete`设为`delete`，禁止了使用`new`和`delete`对该类进行动态内存分配和释放。这意味着尝试在堆上创建这个类的实例会导致编译错误。
> - **公开构造和析构函数**：构造函数和析构函数仍然是公开的，这意味着类的对象可以在栈上正常创建和销毁。

```c++
class StackOnly {
protected:
    // 通过重载全局的new和delete来防止在堆上分配
    void* operator new(size_t) = delete;
    void operator delete(void*) = delete;

    // 也可以私有化new[]和delete[]如果需要防止数组形式的动态分配
    void* operator new[](size_t) = delete;
    void operator delete[](void*) = delete;

public:
    // 公开构造函数和析构函数
    StackOnly() {}
    ~StackOnly() {}
};

// 使用示例
int main() {
    // 正确：在栈上创建
    StackOnly obj;
    // 错误：尝试在堆上创建，会因为new操作符被删除而编译错误
    // StackOnly* objPtr = new StackOnly(); // 编译错误
    return 0;
}
```



### 4、请设计一个类，不能被继承

> final关键字，final修饰类，表示该类不能被继承。

```c++
class A  final
{
    // ....
};
```



### 5、请设计一个类，只能创建一个对象(单例模式)



# 设计模式

> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。
>
> 目的是为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 
>
> 设计模式使代码编写真正工程化

### 1 单例模式

#### 1.1饿汉模式

> 程序启动时就创建一个唯一的实例对象

特点：简单、初始化顺序不确定，如果有依赖关系就会出现问题。饿汉对象初始化慢且多个饿汉单例对象会影响程序启动

```c++
class Sigelton
{
public:
    Sigelton& GetInstance()
    {
        return _insrance;
    }
private:
    Sigelton(const Sigelton&)=delete;
    Sigelton& operator=(const Sigelton&)=delete;
private:
    static Sigelton* _instance;
}
Sigelton* Sigelton::_instance=new Sigelton;
```



#### 1.2 懒汉模式

> 第一次调用时创建对象，需要注意加锁（双检查）

特点：相对复杂、能控制初始化顺序，延迟加载初始化，不影响程序启动

```c++
class Sigelton
{
public:
    Sigelton& GetInstance()
    {
        if(nullptr==_instance)
        {
            _instance=new Sigelton;
        }
        return _instance;
    }
private:
    Sigelton(const Sigelton&)=delete;
    Sigelton& operator=(const Sigelton&)=delete;
private:
    static Sigelton* _instance;
}
Sigelton* Sigelton::_instance=nullptr;
```





