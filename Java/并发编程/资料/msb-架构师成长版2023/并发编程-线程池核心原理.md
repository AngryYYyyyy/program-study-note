# 一、线程池的业务场景应用

## 1.异步处理

在现代应用开发中，异步处理是提高性能和用户体验的关键技术。通过异步处理，可以==将那些耗时的任务放在后台执行，从而不会阻塞主线程，保持应用界面的响应性==。例如，发送邮件通常需要与SMTP服务器交互，而发送短信则需与运营商的服务对接。这些任务由于涉及外部系统交互，可能存在不确定的延迟，甚至有时候会失败。在这种情况下，将这些任务异步化处理不仅合理，而且有助于提升整体应用性能。

### （1）使用 Spring Boot 的 `@Async` 进行异步处理

在 Spring Boot 中，`@Async` 注解提供了一个简洁有效的方式来执行异步任务。这种机制的背后是利用了线程池来管理和执行这些后台任务。当你标注一个方法为 `@Async` 时，Spring 会自动将该方法的调用放入线程池中执行，这样调用者就不需要等待方法执行完成。

#### 本质解析
- `@Async` 的实现本质上是通过 Spring 的任务执行框架，它==默认使用一个简单的线程池==（如果你没有显式配置的话）来执行这些被标记的方法。
- 实际上，Spring 允许开发者自定义线程池，通过在配置类中定义 `Executor` Bean，然后将其指定给 `@Async` 使用。这样，开发者可以根据实际的业务需求和资源限制，优化线程池的配置。

### （2）配置自定义线程池
为了更有效地管理异步任务，你可以根据任务的特性配置合适的线程池。例如，可以设置线程池的核心线程数、最大线程数、队列容量等，以适应不同的负载需求。

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("Async-");
        executor.initialize();
        return executor;
    }
}
```

在上面的配置中，我们定义了一个名为 `taskExecutor` 的线程池。`@EnableAsync` 注解激活了 Spring Boot 的异步方法执行能力，并且可以通过 `@Async("taskExecutor")` 明确指定使用哪一个线程池执行异步方法。

## 2.并行IO处理

在现代软件开发中，有效地处理并行 I/O 操作是提高应用性能的一个关键技术手段。尤其是在微服务架构中，==一个业务处理流程可能依赖于多个服务的数据==。通过并行化这些 I/O 操作，可以显著减少总的响应时间。

一个典型的场景是，你需要从三个不同的服务并行获取数据，然后将这些数据整合在一起。为了实现这种并行处理，可以使用 `CountDownLatch` 和 `ThreadPoolExecutor`。以下是这种方法的详细步骤和实现：

### （1）定义 `CountDownLatch`
`CountDownLatch` 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程等待。

- **初始化**：`CountDownLatch` 的计数器被初始化为你需要完成的任务数量，这里是三个。

### （2）创建 `ThreadPoolExecutor`
`ThreadPoolExecutor` 用于管理一个线程池。这个线程池可以并行执行各个 I/O 任务。

- **配置线程池**：根据需要并行执行的任务数量和系统资源，合理配置核心线程数、最大线程数和工作队列。

### （3）执行并行任务
为每个服务调用分配一个任务，每个任务在执行完毕后都必须调用 `CountDownLatch.countDown()` 方法，这样主线程就知道该任务已完成。

### （4）等待所有任务完成
主线程调用 `CountDownLatch.await()` 方法阻塞等待，直到所有服务调用任务执行完毕（计数器减到零）。

下面是一个简单的示例，展示如何使用 `CountDownLatch` 和 `ThreadPoolExecutor` 来并行处理三个服务调用：

```java
import java.util.concurrent.*;

public class ParallelDataService {
    private final ExecutorService executor = Executors.newFixedThreadPool(3); // 创建线程池

    public void fetchData() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3); // 初始化CountDownLatch

        executor.execute(() -> {
            try {
                System.out.println("Fetching data from service A");
                // 模拟服务调用
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        });

        executor.execute(() -> {
            try {
                System.out.println("Fetching data from service B");
                // 模拟服务调用
                Thread.sleep(1200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        });

        executor.execute(() -> {
            try {
                System.out.println("Fetching data from service C");
                // 模拟服务调用
                Thread.sleep(800);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        });

        latch.await();  // 等待所有任务完成
        System.out.println("All services returned data.");
        executor.shutdown(); // 关闭线程池
    }

    public static void main(String[] args) throws InterruptedException {
        new ParallelDataService().fetchData();
    }
}
```

## 3.其他框架底层的线程池

在现代应用架构中，理解和配置底层的线程池对于确保应用的性能和可靠性至关重要。不同的框架和技术，如 RabbitMQ、OpenFeign 和 Tomcat，都使用线程池来处理并发任务，但每个技术的具体配置和考虑因素可能不同。以下是一些关键的框架和它们线程池配置的概览：

### （1）RabbitMQ
RabbitMQ 是一款广泛使用的开源消息队列系统，它的性能部分依赖于如何配置其消费者的线程行为。

- **单线程消费**：默认情况下，RabbitMQ 的消费者是以单线程模式工作的。这意味着一个消费者实例在同一时间内只会处理一条消息。
- **Prefetch 和并发设置**：通过调整 `prefetch` 设置，你可以控制消费者预取的消息数量，这直接影响到消息的处理速率。此外，通过设置 `maxconcurrent` 参数，可以指定允许并行处理的最大线程数，这可以显著提高消费能力，特别是在面对高吞吐量时。
- **业务逻辑考虑**：配置消费者的线程池时，应考虑到具体的业务逻辑。例如，如果消息处理涉及重IO操作或第三方服务调用，可能需要更多的线程来避免单个线程在等待过程中造成的处理瓶颈。

### （2）OpenFeign
OpenFeign 是一个声明式的Web服务客户端，它使得编写HTTP客户端变得更简单。

- **线程池配置**：在使用 OpenFeign 时，配置合适的线程池至关重要，尤其是当默认的线程配置不能满足性能要求时。在旧版本中，如果不明确配置线程池，可能会导致请求处理延迟增加，影响用户体验。
- **底层机制**：新版本的 OpenFeign 允许通过配置文件或编程方式更精细地控制线程池的行为，如设置超时、线程数上限等，以优化远程调用的性能。

### （3）Tomcat
Tomcat 是一个广泛使用的Java Web服务器，它内部使用线程池来处理并发的HTTP请求。

- **默认线程配置**：Tomcat 默认配置了200个核心线程，这对于中小规模应用通常足够。然而，对于高流量的大型应用，可能需要根据实际负载进一步调整线程池的大小。
- **性能调优**：通过调整 Tomcat 的 `maxThreads`、`minSpareThreads` 和其他相关参数，可以优化服务器的响应时间和处理能力，确保在用户负载高峰期依然能够保持良好的性能。

# 二、线程池核心属性&参数扫盲

在 Java 中，`ThreadPoolExecutor` 是 `ExecutorService` 接口的一个非常强大的实现，它提供了丰富的构造参数和方法，使得我们能够精细地控制线程池的行为和性能。了解线程池的核心属性和参数对于设计高效且健壮的多线程应用至关重要。

## 1.核心属性

#### `AtomicInteger ctl`
`ctl` 是 `ThreadPoolExecutor` 的一个核心字段，它使用 `AtomicInteger` 来控制线程池的状态和工作线程数量的原子操作。这个整数包含两部分信息：

- ==**高3位**==：表示线程池的运行状态。
  - **RUNNING** (-1<<29)：接受新任务并且处理阻塞队列中的任务。
  - **SHUTDOWN** (0)：不接受新任务，但处理阻塞队列中的任务。
  - **STOP** (1<<29)：不接受新任务，不处理阻塞队列中的任务，中断正在处理的任务。
  - **TIDYING** (2<<29)：所有任务都已终止，工作线程数为零，线程池即将转到终止状态。
  - **TERMINATED** (3<<29)：`terminated()` 方法已被调用，线程池彻底终止。

- ==**低29位**==：表示线程池中当前活跃的线程数量。

## 2.7个核心参数

1. **核心线程数（corePoolSize）**线程池中保持活跃的线程数量，即使它们处于空闲状态。
   
2. **最大线程数（maximumPoolSize）**线程池允许创建的最大线程数量。这包括核心线程和非核心线程。
   
3. **最大空闲时间（keepAliveTime）**当线程数量超过核心线程数时，这是非核心线程在终止前可以处于空闲状态的最长时间。
   
4. **空闲时间单位（unit）**`keepAliveTime` 的时间单位，如 `TimeUnit.SECONDS`。
   
5. **阻塞队列（workQueue）**用于保存等待执行的任务的队列。常见的选择有 `LinkedBlockingQueue`, `SynchronousQueue`, `ArrayBlockingQueue` 等。
   
6. **线程工厂（threadFactory）**用于创建新线程的工厂。可以使用默认的工厂，或提供一个自定义的 `ThreadFactory` 实现。
   
7. **拒绝策略（handler）**当线程池和工作队列都满时，用于处理新提交的任务的拒绝策略。常见的策略有 `ThreadPoolExecutor.AbortPolicy`, `ThreadPoolExecutor.CallerRunsPolicy`, `ThreadPoolExecutor.DiscardPolicy`, 和 `ThreadPoolExecutor.DiscardOldestPolicy`。

## 3.实际应用

正确配置这些参数对于优化线程池的性能、资源使用和响应性至关重要。例如，对于==计算密集型任务==，您可能希望将核心线程数设置为可用处理器的数量。对于==I/O 密集型任务==，您可能需要更多的线程来处理不同的 I/O 操作。阻塞队列的选择和拒绝策略也将直接影响到系统在高负载下的表现。

理解和应用这些参数可以帮助开发者创建一个既高效又稳定的多线程环境，使得应用能够充分利用系统资源，同时保持良好的响应性和扩展性。

# 三、线程池提交任务流程

## 1.线程池工作线程的懒加载

线程池的设计通常包含了==懒加载==（lazy initialization）的机制，这意味着在线程池创建之初，它并不立即启动任何工作线程。工作线程的创建与启动是基于任务的提交和线程池的当前状态动态进行的。

## 2.线程池提交任务的处理流程

### （1）检查工作线程数量是否小于核心线程数
- 当一个任务提交到线程池时，线程池首先检查当前活跃的工作线程数量是否小于核心线程数。
- 如果小于核心线程数，线程池会立即创建一个新的工作线程来执行提交的任务，即使此时可能有空闲的工作线程。

### （2）将任务添加到阻塞队列
- 如果当前的工作线程数已达到或超过核心线程数，线程池会尝试将提交的任务加入到阻塞队列中。
- 阻塞队列充当了缓冲区的作用，用来保存那些暂时无法执行的任务。

### （3）检查阻塞队列状态和创建非核心线程
- 如果任务成功加入到阻塞队列中，线程池将依赖已有的工作线程来逐渐处理这些队列中的任务。
- 如果阻塞队列已满且当前工作线程数小于最大线程数，线程池会创建一个新的非核心线程来处理这个新提交的任务。

### （4）执行拒绝策略
- 如果当前工作线程数已达到最大线程数并且阻塞队列也已满，线程池无法处理新提交的任务。在这种情况下，线程池将执行预定义的拒绝策略。
- 拒绝策略包括直接抛出异常、运行任务的调用线程直接执行任务、静默丢弃任务、丢弃队列中最老的一个任务等。

注意：当一个任务被提交到线程池时，首先检查是否有空闲的工作线程可用来处理这个任务。如果==核心线程数设置为0==，则默认不会有任何核心线程在等待。因为没有核心线程，所以提交的任务会尝试直接放入线程池的阻塞队列中。阻塞队列在这里起到缓存任务的作用，等待有线程来处理这些任务。在任务成功加入阻塞队列后，线程池会检查是否有工作线程可以取任务执行。由于核心线程数为0，此时如果没有其他已存在的非核心工作线程，==线程池会创建一个非核心线程来处理队列中的任务==。这一步是必须的，否则任务将会无限期地停留在队列中而得不到处理。创建的非核心线程将按照配置的`keepAliveTime`参数进行管理。如果在指定的空闲时间后没有新的任务，这些非核心线程将会被终止，以释放系统资源。

## 3.核心线程与非核心线程的区别
核心线程和非核心线程由同样的方式创建（即通过`new Thread()`），只在定义上有所区别，但在实际技术层面上没有区别，线程池没有维护工作线程属性。
- **核心线程**：通常会一直保留在线程池中，即使它们处于空闲状态，除非设置了允许核心线程超时。
- **非核心线程**：通常存在超时机制，当这些线程空闲一定时间后（`keepAliveTime`），它们会被终止并从线程池中移除。

# 四、线程池处理任务流程

## 1.工作线程的行为

线程池中的工作线程主要有两种行为模式，取决于它们是核心线程还是非核心线程：

1. **核心线程的行为**：
   - 核心线程在没有任务执行时，通常会无限期地等待新任务（`WAITING`状态），这是通过调用阻塞队列的`take()`方法实现的，该方法会一直阻塞直到队列中出现新的任务。
2. **非核心线程的行为**：
   - 非核心线程在超出核心线程数后创建，它们在没有任务时会等待一定的`keepAliveTime`。如果在这段时间内，阻塞队列中没有新任务到来，这些线程将会超时退出（`TIMED_WAITING`状态），使用的是`poll(timeout, unit)`方法，超时后不再等待新任务。

## 2.线程的结束与销毁

- 对于线程池中的任何线程，无论核心还是非核心，它们的生命周期都受到其执行的`run()`方法的控制。线程的`run()`方法通常包装在`Worker`对象的`run()`方法中，它实现了一个循环来从阻塞队列中获取和执行任务。
- 当阻塞队列无法提供新任务时（对于非核心线程是超时返回），循环将终止，从而结束`run()`方法的执行，线程随之结束。
- 正常线程结束后，除非其他地方有引用保持，否则线程对象会变为垃圾回收的候选对象。

## 3.线程池的正确关闭

- 在使用线程池处理完任务后，非常重要的一步是调用`shutdown()`或`shutdownNow()`方法来关闭线程池。这些方法的调用确保了线程池的状态最终转变为`TERMINATED`，并且线程池中的所有线程都将被逐步终止。
- `shutdown()`方法会等待正在执行的任务完成，而不接受新任务；`shutdownNow()`尝试立即停止所有正在执行的任务并关闭线程池。



# 五、问题

## 1.线程池内存泄漏

**Worker引用链**: 线程池中的工作线程通过内部类`Worker`实现，它是`ThreadPoolExecutor`的一个非静态内部类。每个`Worker`实例都持有对其外部`ThreadPoolExecutor`实例的隐式引用。因此，只要这些`Worker`实例活跃，它们所引用的`ThreadPoolExecutor`也不会被垃圾回收。

**GC Roots和run方法**: 在Java中，活跃的线程被认为是GC Roots的一部分。这意味着只要线程处于活跃状态，执行它们的`run()`方法的栈桢中的所有局部变量都不会被回收。如果这些局部变量包括对其他对象的引用（如`Worker`或线程池实例），这些对象也会被保留在内存中。

## 2.线程池核心参数的设置

假设你的业务运行在一台4核8GB内存的服务器上，这里是如何设置线程池的一些建议：

#### 核心线程数
- **CPU密集型任务**：理想的核心线程数通常设置为CPU核心数加1（4+1=5），这样可以保证CPU的高效利用，同时留有一个线程处理CPU突然空闲下来时的情况。
- **IO密集型任务**：因为IO密集型任务涉及等待（如网络请求或磁盘操作），可以设置更高的线程数。一个起点是设置为CPU核心数的两倍（4*2=8），但最优值通常需要通过实际压力测试来确定。

#### 阻塞队列长度
- 依据系统可以接受的最大延迟和任务到达率来设定。如果每秒任务数预计为100，而系统可以容忍1秒的延迟，则队列长度可以设置为100。同时，要注意内存的使用，避免过长的队列导致内存溢出。

#### 最大线程数
- 建议设置为与核心线程数相同，特别是在CPU密集型任务中，以避免CPU过度的上下文切换。如果确实需要更多线程处理IO密集型任务，则最大线程数可以适当增加。

#### 拒绝策略
- 根据业务严格性选择适合的拒绝策略。例如，如果任务不是非常关键，可以选择`DiscardPolicy`或`DiscardOldestPolicy`。如果任务必须执行，可以使用`CallerRunsPolicy`，该策略会在提交任务的线程中运行任务。
