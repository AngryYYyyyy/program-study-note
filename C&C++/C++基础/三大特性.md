# 一、封装

## 1.1 封装的目的

> **隐藏实现细节**
>
> **对外提供简单的接口**

## 1.2 基本原则

> 在C++中，封装是通过使用`class`或`struct`关键字来实现的
>
> **使用访问修饰符**：C++提供了三种主要的访问修饰符：`public`, `private`, 和 `protected`。通过这些修饰符，你可以控制类的成员变量和成员函数的访问权限。
>
> - `public`：可以从类的任何对象访问的成员。
> - `private`：只能从类的方法中访问的成员。这是默认的访问级别。
> - `protected`：类似于`private`，但也可以在派生类中访问。
>
> **使用构造函数和析构函数**：构造函数和析构函数是特殊的成员函数，它们用于初始化和销毁对象，隐藏了对象创建和销毁的细节。

# 二、继承

## 2.1 继承概念

> 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。
>
> 继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用。

### 2.1.1 继承定义的格式

```c++
class 派生类:继承方式 基类
{};
```

**示例**：

```c++
class Person
{
public:
    void Print(){}
protected:
    string _name = "peter"; // 姓名
    int _age = 18;  // 年龄
};
// 继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。
class Student : public Person
{
protected:
    int _stuid; // 学号
};
```

### 2.1.2 继承方式和访问限定符

#### （1）==继承方式==

> private、public、protected

#### （2）访问限定符

> private、public、protected

#### （3）访问方式的转换

![image-20230910214809002](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230910214809002.png)



> ==基类private成员在派生类中无论以什么方式继承都是不可见的==
>
> 如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected

## 2.2 基类和派生类对象赋值转换

### 2.2.1 **从派生类到基类的转换**

> - ==派生类对象可以隐式地转换为基类对象。这称为“向上转型”。==
> - ==派生类的指针或引用可以隐式地转换为基类的指针或引用。==

![image-20230911115842973](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230911115842973.png)

```c++
class Base {};
class Derived : public Base {};

Derived d;
Base b = d;  // 有效，派生类对象隐式地转换为基类对象
Base* pb = &d;  // 有效，派生类对象的地址可以赋给基类指针
```

### 2.2.2 **从基类到派生类的转换**

> - 基类对象不能直接转换为派生类对象，因为基类可能没有派生类中的额外属性。
> - 基类的指针或引用可以通过`dynamic_cast`进行显式转换为派生类的指针或引用，但这需要运行时类型信息（RTTI）支持，并且只有==在基类指针或引用确实指向派生类对象==时转换才会成功。

```c++
Derived* pd = dynamic_cast<Derived*>(pb);  // 如果pb确实指向Derived对象，转换成功；否则，pd为nullptr
```



## 2.3 继承中的作用域

### 2.3.1 名称隐藏

> 如果派生类有一个与基类成员同名的成员，那么基类的该成员在派生类的作用域中会被隐藏，除非使用作用域解析运算符 `::`。

```c++
class Base {
public:
    void foo() {}
};

class Derived : public Base {
public:
    void foo(int) {}
};

Derived d;
d.foo();     // 错误：foo在此上下文中没有明确的定义
d.foo(10);   // 正确
d.Base::foo();  // 正确：调用基类的foo
```

## 2.4 派生类的默认成员函数

> 当派生类自身没有明确定义某些成员函数时，这些成员函数的行为将会如何？这与其基类的相关成员函数行为和特性有很大的关联。

![image-20230911115811338](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230911115811338.png)

### （1）**默认构造函数**

> - 如果派生类没有定义默认构造函数，编译器会为其提供一个。
> - 这个构造函数会首先调用基类的默认构造函数，然后按照声明的顺序调用派生类中的成员对象的默认构造函数。

### （2）**拷贝构造函数**

> - 如果派生类没有定义拷贝构造函数，编译器会为其提供一个。
> - 这个拷贝构造函数会首先调用基类的拷贝构造函数，然后按照声明的顺序调用派生类中的成员对象的拷贝构造函数。

### （3）**拷贝赋值操作符**

> - 如果派生类没有定义拷贝赋值操作符，编译器会为其提供一个。
> - 这个赋值操作符会首先调用基类的拷贝赋值操作符，然后按照声明的顺序调用派生类中的成员对象的拷贝赋值操作符。

### （4）**析构函数**

> - 如果派生类没有定义析构函数，编译器会为其提供一个。
> - ==当派生类对象被销毁时，这个析构函数首先执行派生类的析构函数体，然后调用派生类中的成员对象的析构函数（与声明的顺序相反），最后调用基类的析构函数。==

## 2.5 继承和友元

> 友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 

## 2.6 继承与静态成员

> 基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子 类，都只有一个static成员实例 。

## 2.7 复杂的菱形继承及菱形虚拟继承

### 2.7.1 单继承/多继承

#### （1）单继承

> 一个个子类只有一个直接父类时称这个继承关系为单继承

#### （2）多继承

> 一个子类有两个或以上直接父类时称这个继承关系为多继承

```
  DerA  DerB
    \  /
   DerAB
```

### 2.7.2 菱形继承

> 菱形继承，是多继承中一个有问题的模式。当两个派生类继承自同一个基类，然后又被一个类同时继承时，会引起歧义。

#### （1）形式

```
    Base
    /  \
  DerA  DerB
    \  /
   DerAB

```

**示例**

```c++
class Base 
{
public:
    int value = 0;
};

class DerA : public Base {};

class DerB : public Base {};

class DerAB : public DerA, public DerB {};


DerAB obj;
obj.value = 10;  // 错误：引用的 ‘value’ 是模糊的
//编译器不知道通过DerA修改value还是通过DerB修改value。
```

#### （2）问题

> 数据冗余和二义性

### 2.7.3 菱形虚拟继承

#### （1）虚继承

虚继承是一种特殊的继承方式，用于解决多重继承时可能出现的菱形继承问题（钻石问题）。当两个或多个派生类继承自同一个基类，并且又有一个类同时继承这几个派生类时，基类的一个实例会在最终的派生类中出现多次。这不仅会浪费空间，还可能导致数据不一致的问题。通过虚继承，可以确保基类仅在派生类中被创建一次，即使它被多次继承。

> 基类为派生类创建一个共享的实例，而不是每个派生类一个实例，即==基类只能有一个实例==。
>
> 虚继承会引入额外的内存开销和运行时开销。==为了支持动态解析到正确的基类地址==，派生类中通常会有一个==虚基类指针==。

```c++
class Base {
public:
    int value = 0;
};

class DerA : virtual public Base {};

class DerB : virtual public Base {};

class DerAB : public DerA, public DerB {};

```

#### （2）原理

> **虚基类表（Virtual Base Table, VBT）**：当一个类虚继承其基类时，编译器会为它生成一个虚基类表。这个表中存储的是从派生类对象到虚基类对象的偏移。
>
> **虚基类指针（Virtual Base Pointer, VBP）**：每个需要虚继承的类对象都有一个虚基类指针，这个指针指向虚基类表。
>
> **动态解析**：==当访问虚基类的一个成员时，编译器首先使用虚基类指针找到虚基类表，接着从该表中取得从派生类到虚基类的偏移，然后使用这个偏移来访问基类成员==。

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230911091424024.png" alt="image-20230911091424024" style="zoom:50%;" />

## 2.8 继承与组合

### 2.8.1 继承

#### （1）**定义**

> 继承是一种"是一个（is-a）"的关系。例如，`Bird` 是一个 `Animal`。这意味着 `Bird` 类可以继承 `Animal` 类的属性和方法。

#### （2）**特性**

> - 提供代码重用机制。
> - 支持多态。
> - 派生类继承了基类的所有属性和方法（除了私有属性和方法）。

#### （3）**问题**

> - 过度使用继承可能导致过于复杂的继承层次结构。
> - 容易打破封装，因为派生类依赖于其基类的实现。

### 2.8.2 组合

#### （1）**定义**

> 组合是一种"有一个（has-a）"的关系。例如，`Car` 有一个 `Engine`。这意味着 `Car` 类可以包含一个 `Engine` 类的对象作为其成员。

#### **（2）特性**

> - 提供了一个更加灵活的方式来组合对象，允许改变行为/功能而不需要更改现有的类。
> - 对象之间的关系通常可以在运行时更改。
> - 有助于遵循"单一职责原则"，因为每个类都聚焦于一个任务。

#### （3）**优势**

> - 通常更为灵活，因为系统的一部分可以更改而不影响其他部分。
> - 更容易理解和维护，因为组合关系比继承关系更直观。

总的来说，一般的设计原则是：==尽可能使用组合而不是继承==。这样的设计往往更加灵活且更易于维护。

## 2.9 相关面试题

### （1）什么是菱形继承？菱形继承的问题是什么？ 

> 在类继承的层次结构中，一个类被两个子类继承，而这两个子类又被另一个类同时继承。
>
> **数据冗余**：在上述情况下，D 的实例会有两份来自 A 的数据。这是因为 B 和 C 都分别包含了 A 的数据，并且 D 又从 B 和 C 中各继承了这些数据。
>
> **二义性**：如果 B 和 C 重写了 A 中的某个函数，且 D 的对象调用该函数，那么到底应该调用 B 中的版本还是 C 中的版本呢？

### （2）什么是菱形虚拟继承？如何解决数据冗余和二义性的 

> 通过使用关键字 `virtual`，我们可以告诉编译器，我们只希望有一个单独的、不重复的 A 类的成员数据拷贝。
>
> **数据冗余**：通过虚拟继承，D 的实例只会有一份 A 的数据，从而避免了数据的重复。
>
> **二义性**：虚拟继承确保了基类 A 只被构造一次，从而消除了来自多个路径的二义性问题。

### （3）继承和组合的区别？什么时候用继承？什么时候用组合？

# 三、多态

## 3.1 多态概念

> 多态意味着你可以使用一个接口来表示多种形式的数据

### 3.1.1 ==多态构成条件==

> 1. 使用继承。
> 2. 在基类中声明虚函数。
> 3. 在派生类中重写这个虚函数。

**示例**

```c++
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() {
        cout << "Animal speaks." << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "Dog barks." << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat meows." << endl;
    }
};

int main() {
    Animal* a;
    Dog d;
    Cat c;

    a = &d;		//派生类赋值基类
    a->speak();  // Outputs: Dog barks.

    a = &c;
    a->speak();  // Outputs: Cat meows.

    return 0;
}

```

### 3.1.2 虚函数

> ==虚函数允许我们通过基类指针或引用调用派生类的函数==

```c++
virtual void speak() {
        cout << "Animal speaks." << endl;
    }
```

### 3.1.3 虚函数重写

> ==当派生类提供其版本的基类的虚函数时，称为重写。==

#### （1）重写规则

> 重写的函数必须与基类的虚函数具有相同的函数签名。
>
> 在C++11及其后续版本中，我们可以使用关键字`override`确保函数确实重写了基类的虚函数。
>
> 重写的函数在派生类中自动成为虚函数，即使不使用`virtual`关键字。

#### （2）协变

> 在C++中，当派生类重写基类的虚函数时，返回类型通常必须与基类函数的返回类型相同。但C++允许一种例外，即==当虚函数返回基类的指针或引用时，派生类的重写版本可以返回派生类的指针或引用，这就是所谓的协变返回类型。==

#### （3）析构函数重写

> 实际上，析构函数不是真正"重写"的，但当我们说一个派生类"重写"其基类的析构函数时，我们通常意味着派生类为其对象提供了自己的析构逻辑。
>
> - 基类的析构函数应该是虚函数，这样当使用基类的指针或引用删除派生类的对象时，可以确保调用正确的析构函数，并且派生类的资源得到正确释放。
> - 派生类不需要显式地"重写"基类的析构函数；只要提供自己的析构函数即可。
> - 当派生类的对象被销毁时，首先会调用派生类的析构函数，然后再调用基类的析构函数。

```c++
class Base {
public:
    virtual ~Base() {
        cout << "Base destructor called" << endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived destructor called" << endl;
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;
}
//Derived destructor called
//Base destructor called
//这表明首先调用了派生类的析构函数，然后才是基类的析构函数。这也是为什么我们通常希望基类的析构函数是虚函数，以确保资源正确地释放。
//同样对于new Derived()，先调用基类，再是派生类
```

### 3.1.4 override/final

#### （1）`override`

> `override`关键字用于确保派生类中的函数确实重写了它在基类中的版本。使用`override`可以帮助检测错误，例如：如果基类的虚函数在派生类中没有正确地重写（例如，由于函数签名的微小差异），编译器会报告错误。

**示例**：

```cpp
class Base {
public:
    virtual void foo(int) {}
};

class Derived : public Base {
public:
    void foo(int) override {}  // 正确：重写了基类的foo函数
    // void foo(float) override {}  // 错误：函数签名不匹配
};

```

#### （2） `final`

> 1. ==**防止进一步的继承**==：当你不希望其他类继承某个特定的类时，可以在类声明之后使用`final`。
>
> 2. ==**防止重写**==：当你不希望派生类重写某个特定的虚函数时，可以在该函数的声明之后使用`final`。
>

**示例**：

```cpp
// 使用final防止进一步的继承
class Base final {
    // ...
};

// class Derived : public Base {};  // 错误：Base是final的，不能被继承

class AnotherBase {
public:
    virtual void someFunction() final {
        // ...
    }
};

class AnotherDerived : public AnotherBase {
    // void someFunction() {}  // 错误：someFunction在基类中是final的，不能被重写
};
```

## 3.2 重载、重写、隐藏

![image-20230911100011890](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230911100011890.png)

## 3.3 抽象类

> 抽象类是面向对象编程中的一个核心概念，用于表示一个高层次的、不能直接实例化的类。其目的主要是为了提供一个基础的、公共的界面，供其他类继承和实现。

### 3.3.1 纯虚函数

> ==纯虚函数是在基类中声明的虚函数，它没有具体的实现，而是由派生类提供具体实现。==

```c++
virtual ReturnType FunctionName(Parameters) = 0;
```

### 3.3.2 抽象类特性

> **实例化**：抽象类不能直接实例化。也就是说，你==不能创建一个抽象类的对象==。但你==可以创建指向抽象类的指针和引用==，这常常在多态中被用到。
>
> **派生类**：从抽象类派生出的类==必须实现所有的纯虚函数==，除非它自己也是一个抽象类。

```c++
class Shape {  // 这是一个抽象类
public:
    virtual void draw() = 0;  // 纯虚函数
    virtual double area() = 0;  // 纯虚函数
};

class Circle : public Shape {  // 派生类
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    void draw() override {
        // 实现draw函数
    }
    double area() override {
        return 3.14 * radius * radius;
    }
};

```

### 3.3.3 实现继承和接口继承

> 普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。
>
> ==虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。==
>
> 所以如果不实现多态，不要把函数定义成虚函数。

## 3.4 多态原理

> 多态的实现原理主要依赖于虚函数表和虚指针。当虚函数被调用时，程序会动态地确定要执行哪个函数，这使得我们能够在运行时调用派生类的函数，而不需要在编译时知道具体的类型。

### 3.4.1 虚函数表/虚指针

#### （1）虚函数表

> 当一个类含有虚函数时，编译器会为这个类生成一个虚函数表。这个表包含了该类所有的虚函数地址。

#### （2）虚指针

> 同时，==每一个类的对象在被创建时，都会含有一个虚指针（vptr）==，这个指针指向该类对应的虚函数表。如果一个派生类没有覆盖基类的虚函数，那么派生类的虚函数表中会存放基类虚函数的地址。

#### （3）动态绑定

> 当我们使用基类指针或引用调用虚函数时，实际上进行的是动态绑定。在运行时，==通过基类对象的虚指针找到对应的虚函数表，从表中取得实际要调用的函数地址，然后执行==。

#### （4）存储位置

> 1. ==**vtable**（虚函数表）: 存储在**数据段**==
>
> 2. **vptr**（虚指针）: 根据对象是如何分配的，它可以存储在**栈区**（对于局部对象）或**堆区**（对于动态分配的对象）。
>
> 3. ==**虚函数**: 它们的代码存储在**代码段**。==
>

### 3.4.2 动态绑定/静态绑定

#### （1）动态绑定

> ==动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。==
>
> 动态绑定是面向对象编程中的一个机制，它允许在运行时决定调用哪个对象的哪个方法。

#### （2）静态绑定

>  静态绑定又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态， 比如：函数重载

### 3.4.3 单继承和多继承的虚函数表

#### （1）单继承

```c++
class Base {
public:
    virtual void func1() {}
    virtual void func2() {}
};

class Derived : public Base {
public:
    virtual void func2() override {}
    virtual void func3() {}
};

```

> - `Base` 类有一个包含两个函数指针的虚函数表：一个指向`func1`，另一个指向`func2`。
> - `Derived` 类也有一个虚函数表，这个表包含三个函数指针：指向`Base`的`func1`、指向`Derived`的`func2`（因为它重写了`Base`的`func2`）以及指向`Derived`的`func3`。

#### （2）多继承

```c++
class Base1 {
public:
    virtual void func1() {}
    virtual void func2() {}
};

class Base2 {
public:
    virtual void func1() {}
    virtual void func2() {}
};


class Derived : public Base1,public Base2 {
public:
    virtual void func2() override {}
    virtual void func3() {}
};
```

> - `Base1` 类有一个包含两个函数指针的虚函数表：一个指向`func1`，另一个指向`func2`。
> - `Base2` 类有一个包含两个函数指针的虚函数表：一个指向`func1`，另一个指向`func2`。
> - `Derived` 类有两个虚函数表，第一个表包含三个函数指针：指向`Base1`的`func1`、指向`Derived`的`func2`以及指向`Derived`的`func3`。，第二个表包含三个函数指针：指向`Base2`的`func1`、指向`Derived`的`func2`以及指向`Derived`的`func3`。



## 3.5 相关面试题

![image-20230911122437744](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230911122437744.png)

















