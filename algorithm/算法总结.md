# 一、算法基础

## 1.什么是算法

算法(algorithm，[ˈælɡərɪðəm]，计算程序)：就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。

算法（algorithm）是解决一系列问题的清晰指令，也就是，能对一定规范的输入，在有限的时间内获得所要求的输出。

简单来说，算法就是解决一个问题的具体方法和步骤。

程序 = 算法+数据结构

### （1）特征

**可行性**：算法中执行的任何计算步骤都可以分解为基本可执行的操作步，即每个计算步都可以在有限时间里完成（也称之为有效性）。

**确定性**：算法的每一步都要有确切的意义，不能有二义性。例如“增加x的值”，并没有说增加多少，计算机就无法执行明确的运算。

**有穷性**：算法的有穷性是指算法必须在执行有限个步骤后终止。操作次数不宜过大，不能超过人们事先设定的时间限制。

**输入**：算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法已经给出了初始条件。

**输出**：一个算法可能有1个或多个输出，以反映输入数据加工后的代码，没有输出的算法是没有意义的！

### （2）**算法的评价**

通常一个好算法应该达到如下目标：

**正确性**：算法应该正确的解决问题。

**可读性**：算法应该具有较好的可读性，让人们理解算法的作用。

**健壮性**：输入非法数据时，算法也可以做出适当的反应，而不会产生奇奇怪怪的输出。

## 2.复杂度

时间复杂度和空间复杂度是衡量一个算法效率的重要标准。

### （1）基本操作数

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。

对基本操作的计数或是估测可以作为评判算法用时的指标。

### （2）时间复杂度

评估程序所需要的时间。

| 复杂度 | 标记符号              | 说明                                 |
| ------ | --------------------- | ------------------------------------ |
| 常量   | O(1)                  | 操作数量为常数，与输入数据的规模无关 |
| 对数   | O(log2 n)             | 与输入数据的比例是 log2（n）         |
| 线性   | O(n)                  | 与输入数据成正比                     |
| 平方   | O(n²)                 | 与输入数据规模的比例为平方           |
| 立方   | O(n³)                 | 与输入数据规模的比例为立方           |
| 指数   | O(2ⁿ)   O(kⁿ)   O(n!) | 快速增长，尽量减少这种代码           |

### （2）空间复杂度

评估程序所需要的储存空间。空间复杂度一般不作考虑，一般都优先考虑时间复杂度。

## 3.对数器

对数器是在计算机科学和编程竞赛中用来验证算法正确性的一种工具。其核心目的是通过与一个已知正确但效率较低的方法进行比较来测试一个新算法的正确性。这种方法特别适用于那些在提交给比赛评判系统后，系统只告诉你是否正确而不指出错误位置的情况。下面是对对数器的一个详细概念和使用方法的说明：

对数器是一种测试工具，用于比较两个方法的执行结果是否一致，从而验证被测试方法的正确性。它通常由以下几部分组成：
1. **待测方法（a）**：这是你开发的新方法，用于解决某个具体问题。
2. **对比方法（b）**：一个已知正确但复杂度较高的方法。这个方法的作用是作为标准来验证待测方法的正确性。
3. **随机样本生成器**：用于产生大量随机输入数据，以全面测试方法a和方法b。
4. **对比验证程序**：对比方法a和方法b的输出，确认两者是否一致。

主要用于开发过程中自我检验算法的正确性，特别是在没有外部错误反馈的环境中，如算法竞赛或独立测试场景。

在Java中生成一个随机数组，可以指定数组的最大长度和元素的最大值，你可以使用以下方法：

```java
import java.util.Random;
public class RandomArrayGenerator {
    public static int[] generateRandomArray(int maxLength, int maxValue) {
        Random random = new Random();
        // 随机生成数组的长度，从1到maxLength
        int length = random.nextInt(maxLength) + 1;
        int[] array = new int[length];
        
        // 填充数组，元素值范围为0到maxValue（包括0，不包括maxValue）
        for (int i = 0; i < length; i++) {
            array[i] = random.nextInt(maxValue);
        }
        return array;
    }
}
```

这段代码实现了一个名为`RandomArrayGenerator`的类，其中包含一个名为`generateRandomArray`的方法，该方法接收最大长度`maxLength`和最大值`maxValue`作为参数，然后返回一个随机生成的整数数组。数组的长度是随机的，介于1和`maxLength`之间，数组中每个元素的值介于0和`maxValue`（不包括`maxValue`）之间。

## 4.枚举

### （1）简介

枚举（Enumerate）是基于已有知识来猜测答案的一种问题求解策略。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

### （2）要点

**给出解空间**

建立简洁的数学模型。

枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素？

**减少枚举的空间**

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

**选择合适的枚举顺序**

根据题目判断。比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。

### （3）例题

题目：一个数组中的数互不相同，求其中和为0的数对的个数。

分析：

枚举两个数的代码很容易就可以写出来。

但是两个数是否都一定要枚举出来呢？枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数）的条件，如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。较为进阶地，在数据范围允许的情况下，我们可以使用桶记录遍历过的数。

```java
package conclusion.algorithm_basics.enums;

import java.util.Arrays;

/**
 * @Author ：AngryYYYYYY
 * @Date ：Created in 2024/8/12 21:54
 * @Description：计算数组中和为0的数对的个数。
 */
public class Solution01 {
    public static void main(String[] args) {
        // 示例数组
        int[] arr = {-3, -2, -1, 0, 1, 2, 3, 4};
        
        // 调用process方法，计算和为0的数对的个数
        int result = process(arr);
        
        // 输出结果
        System.out.println(result);
    }

    /**
     * 计算给定数组中和为0的数对的个数。
     *
     * @param array 输入的整数数组，元素互不相同
     * @return 和为0的数对的个数
     */
    private static int process(int[] array) {
        int answer = 0;

        // 找到数组中元素绝对值的最大值
        // 用于映射负数的索引
        int max = Arrays.stream(array).map(Math::abs).max().getAsInt();

        // 创建一个大小为2*max+1的布尔数组，用来记录数组中出现的元素
        boolean[] bucket = new boolean[2 * max + 1];

        // 遍历数组中的每个元素
        for (int i = 0; i < array.length; i++) {

            // 如果存在一个元素，使得当前元素和它的和为0，则计数器加1
            if (bucket[max - array[i]]) {
                answer++;
            }

            // 将当前元素标记为已出现
            bucket[max + array[i]] = true;
        }

        // 返回和为0的数对的个数
        return answer;
    }
}

```

## 5.模拟

### （1）简介

模拟就是用计算机来模拟题目中要求的操作。

模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。

### （2）要点

写模拟题时，遵循以下的建议有可能会提升做题速度：

- 在动手写代码之前，在草纸上尽可能地写好要实现的流程。
- 在代码中，尽量把每个部分模块化，写成函数、结构体或类。
- 对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 "YY-MM-DD 时：分" 把它抽取到一个函数，处理成秒，会减少概念混淆。
- 调试时分块调试。模块化的好处就是可以方便的单独调某一部分。
- 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

对于Java编程来说，要学习stream、集合、lambda以及String、Math、Arrays等工具类能够有效提高模拟的效率。

### （3）例题

华为od：

2024D-API 集群负载统计

2024D-整数对最小和

2024D-回收银饰

2024D-字符串分割（二）

2024D-GPU调度

2024D-整数分解

2024D-攀登者1

2024D-攀登者2（90%）

2024D-小明能到达的最大坐标值

2024D-素数之积

2024D-高效货运

2024D-结队编程

2024D-螺旋数字矩阵

2024D-灰度图恢复

2024D-来自异国的客人

2024D-数组去重和排序

2024D-学生重新排队（90%）

算法体系：

## 6.递归&分治

### （1）递归

递归（Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。

#### 引入

> 要理解递归，就得先理解什么是递归。

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。

以下是一些有助于理解递归的例子：

1. 如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。
2. 你今年几岁？答：去年的岁数加一岁，1999 年我出生。

递归在数学中非常常见。例如，集合论对自然数的正式定义是：1 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

```java
int func(int value) {
  if (value == 终止条件) return 最小子问题解;
  return func(缩小规模的value);
}
```

#### 为什么要写递归

1. 结构清晰，可读性强。例如，分别用不同的方法实现归并排序：

   ```java
   // 不使用递归的归并排序算法
   public void mergeSort(int[] a) {
       int n = a.length;
       for (int seg = 1; seg < n; seg += seg) {
           for (int start = 0; start < n - seg; start += seg + seg) {
               merge(a, start, start + seg - 1, Math.min(start + seg + seg - 1, n - 1));
           }
       }
   }
   
   // 使用递归的归并排序算法
   public void mergeSort(int[] a, int front, int end) {
       if (front >= end) return;
       int mid = front + (end - front) / 2;
       mergeSort(a, front, mid);
       mergeSort(a, mid + 1, end);
       merge(a, front, mid, end);
   }
   ```

   显然，递归版本比非递归版本更易理解。递归版本的做法一目了然：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug，且难以调试。

2. 练习分析问题的结构。当发现问题可以被分解成相同结构的小问题时，递归写多了就能敏锐发现这个特点，进而高效解决问题。

#### 递归的缺点

在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 **栈溢出** 的后果。

显然有时候递归处理是高效的，比如归并排序；**有时候是低效的**，比如简单递推场景，因为栈会消耗额外空间。例如，计算链表长度的例子：

```java
// 典型的递推遍历框架
public int size(Node head) {
    int size = 0;
    for (Node p = head; p != null; p = p.next) {
        size++;
    }
    return size;
}

// 使用递归实现
public int sizeRecursion(Node head) {
    if (head == null) return 0;
    return sizeRecursion(head.next) + 1;
}
```

#### 递归的优化

搜索优化和记忆化搜索

比较初级的递归实现可能递归次数太多，容易超时。这时需要对递归进行优化。

### （2）分治

分治（Divide and Conquer）的字面解释是「分而治之」，即将一个复杂的问题分解成两个或更多的相同或相似的子问题，直至子问题简单到可以直接求解，最终将这些子问题的解合并以解决原问题。

#### 过程

> 如果各子问题不独立，即分治法需要重复解决公共子问题，那么尽管分治法仍可使用，通常采用动态规划会更为合适。

分治算法的核心思想就是「分而治之」，其大致流程可分为三步：分解 -> 解决 -> 合并。

1. **分解**：将原问题分解为结构相同的子问题。
2. **解决**：递归地解决这些子问题，直至达到易于解决的边界。
3. **合并**：将各子问题的解整合为原问题的解。

适合采用分治法的问题通常具有以下特征：

- 问题的规模缩小到一定程度就可以简单直接解决。
- 问题可以分解为若干个规模较小的相同问题，即问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
- 分解出的子问题相互独立，即子问题间不包含重复的子问题。

以归并排序为例，假设实现归并排序的函数名为 `mergeSort`。这个函数的职责是对传入的数组进行排序。这个问题显然可以分解：对数组的左右两半分别排序，然后合并。

```java
void mergeSort(int[] array) {
  if (array.length <= 1) return;
  int mid = array.length / 2;
  int[] left = Arrays.copyOfRange(array, 0, mid);
  int[] right = Arrays.copyOfRange(array, mid, array.length);
  
  mergeSort(left);
  mergeSort(right);
  merge(left, right, array);
}
```

传给它半个数组，那么处理完后这半个数组就已经被排好了。注意到，`mergeSort` 与二叉树的后序遍历模板极其相似。因为分治算法的套路是 **分解 -> 解决（触底）-> 合并（回溯）**，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。

`merge` 函数的实现方式与两个有序链表的合并一致。

#### 要点

**理解函数的职责并信任它能完成任务**。避免深入探究函数的具体实现细节，否则容易陷入细节中无法自拔。函数的设计就是为了解决一部分问题，不需要一次性解决所有问题。

以遍历二叉树为例。

```java
void traverse(TreeNode root) {
  if (root == null) return;
  traverse(root.left);
  traverse(root.right);
}
```

这几行代码足以遍历任何一棵二叉树。对于递归函数 `traverse(root)`，只需相信给定根节点 `root`，它就能遍历整棵树。因此，只需要将节点的左右子节点传递给同一个函数即可。

同样的方法也适用于遍历 N 叉树，其递归遍历代码与二叉树的遍历类似，只是在处理子节点时使用循环，不过，对于 N 叉树，显然没有中序遍历：

```java
void traverseNaryTree(Node root) {
  if (root == null) return;
  for (Node child : root.children) {
    traverseNaryTree(child);
  }
}
```

#### 区别

递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

## 7.贪心

### （1）简介

贪心算法（Greedy Algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

### （2）证明
在使用贪心算法时，通常需要证明其正确性，即证明其传递性。

这里建议先不要去练习证明，因为贪心是最具自然智慧的算法，主要是通过阅历和经验进行提升。

### （3）要点

#### 特点

- 局部最优选择
- 无回溯

#### 常见题型
贪心算法在比赛和实际问题中有两种典型的应用场景：

1. **排序后选择**：将问题的元素按照某种标准排序，然后按顺序做出选择，例如活动选择问题。
2. **动态选择**：在处理过程中动态地选择当前最优解，如使用优先队列处理相关问题。

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

具体一些

- **资源分配问题**：如背包问题（在不同的场景下可能需要使用贪心算法、动态规划等不同策略）。
- **图的最小生成树**：如Prim算法和Kruskal算法。
- **图的最短路径问题**：如Dijkstra算法。
- **数据压缩**：如哈夫曼编码。

#### 与动态规划的区别
- **贪心算法**：通常只做出在某种意义上的局部最优解决策，并且一旦做出这些决策，就不会撤销。
- **动态规划**：保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法的效率通常高于动态规划，但是它的应用也更受限，因为它依赖于问题具有“贪心选择性质”（每步所做的贪心选择将导致全局最优解），这一性质并非所有问题都具备。

### （3）例题

华为od：

2024D-停车场车辆统计

2024D-虚拟游戏理财

2024D-贪心歌手

2024D-任务处理

2024D-小朋友来自多少小区

2024D-座位调整（边界判断模板）

2024D-分割均衡字符串

2024D-变换最小字符串

2024D-伐木工

2024D-停车找车位

2024D-社交距离

2024D-会议室占用时间

算法体系：

字符串拼接最小字典序

会议室安排

最低成本分割金条

## 8.排序

## 9.前缀和&差分

### （1）前缀和

前缀和是一个数组的元素的累计总和，通常用于减少重复的计算，是一种重要的预处理方式,提高区间和查询的效率。

#### 一维前缀和

前缀和数组`prefix[]`的第`i`项，代表原数组`arr[]`从第一个元素到第`i`个元素的总和。即：

$\[ \text{prefix}[i] = \sum_{j=1}^{i} \text{arr}[j] \]$

前缀和的计算公式可以表示为：

$\[ \text{prefix}[i] = \text{prefix}[i-1] + \text{arr}[i] \]$

其中，`prefix[0]`通常设为0，方便计算从数组第一个元素开始的和。

示例：求长度为n的数组的前缀和，并且作用于求区间和

```java
int n = arr.length;
int[] prefixAnd=new int[n+1];
prefixAnd[0]=0;
for(int i=1;i<=n;i++){
    prefixAnd[i]=prefixAnd[i-1]+array[i-1];
}
```

则[start,end]区间和为

```java
prefixAnd[end+1]-prefixAnd[start]
```

当然如果不处理则

```java
prefixAnd[end] - (start == 0 ? 0 : prefixSums[start - 1])
```

示例：如果该数组是环形数组，那么如何求[start,end]区间，注意start>end的情况会因为环形数组出现

如果start <= end

```java
prefixAnd[end] - (start == 0 ? 0 : prefixAnd[start - 1])
```

如果start>end转换为求取[start,n-1]和[0,end]

我们也可以扩容数组（n*2），例如{1,2,3,4}-->{1,2,3,4,1,2,3,4}并建立前缀和

```java
int n = arr.length;
prefixAnd = new int[2 * n];
prefixAnd[0] = arr[0];
for (int i = 1; i < 2 * n; i++) {
    prefixAnd[i] = prefixAnd[i - 1] + arr[i % n];
}
```

则[start,end]区间和为

start>end

```java
prefixAnd[end+n]- (start == 0 ? 0 : prefixAnd[start - 1])
```

start <= end

```java
prefixAnd[end]- (start == 0 ? 0 : prefixAnd[start - 1])
```



#### 二维/多维前缀和

对于二维或多维数组，前缀和的概念可以扩展以支持快速计算任意子矩阵或子体的和。在二维的情况下，如果有一个`m x n`的矩阵`matrix[][]`，其前缀和`prefix[][]`可以定义为：

$\[ \text{prefix}[i][j] = \sum_{p=1}^{i} \sum_{q=1}^{j} \text{matrix}[p][q] \]$

二维前缀和的计算公式为：

$\[ \text{prefix}[i][j] = \text{prefix}[i-1][j] + \text{prefix}[i][j-1] - \text{prefix}[i-1][j-1] + \text{matrix}[i][j] \]$

这里，`prefix[i-1][j]` 和 `prefix[i][j-1]` 分别是上方和左方的前缀和，而`prefix[i-1][j-1]`被加回因为它被计算了两次。

这种方法基于容斥原理，允许我们在常数时间内求出任意子矩阵的和，只需要一次简单的加减运算。使用二维前缀和可以有效处理二维空间的累加问题，尤其是在处理图像、统计和动态规划问题中非常有用。

二维前缀和的应用示例包括图像处理中的区域亮度计算、二维区间查询等。在多维情况下，前缀和的概念也可以类似地扩展，虽然随着维度的增加，计算和存储的复杂性也会增加。

### （2）差分

### （3）例题

#### 前缀和

华为od：

2024D-查找接口成功率最优时间段

2024D-分割数组的最大差值

2024D-环中最长字串2（需优化）

## 10.二分查找

### （1）简介

二分查找（binary search），也称为折半搜索（half-interval search）或对数搜索（logarithmic search），是一种在有序数组中查找特定元素的高效算法。它通过每次查找过程中将搜索区间减半，从而快速定位元素是否存在。

#### 工作原理
在升序数组中查找元素时：
1. 比较数组中间元素与目标值：
   - 如果中间元素等于目标值，搜索结束。
   - 如果中间元素小于目标值，继续在右侧子数组中搜索。
   - 如果中间元素大于目标值，继续在左侧子数组中搜索。

#### 复杂度

时间复杂度：最坏情况和平均情况为\(O(\log n)\)，其中 \(n\) 是数组长度。

空间复杂度：在迭代实现中，二分查找只需要常数空间\(O(1)\)。

### （2）实现

**优化：**

- 使用 `n >> 1` 替代 `n / 2` 可以减少指令数，尤其是当你确定 `n` 是非负数时。
- 通过计算 `left + (right - left) / 2` 而不是 `(left + right) / 2` 来避免潜在的整数溢出。
- 该实现为[]的写法，当然可以根据情况调整

```java
private static int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1); // 避免溢出，同时使用位运算提高效率
        if (arr[mid] < target) {
            left = mid + 1;  // 目标在右侧
        } else if (arr[mid] > target) {
            right = mid - 1; // 目标在左侧
        } else {
            return mid;      // 找到目标
        }
    }
    return -1;              // 未找到目标
}
```

二分搜索法不仅可用于在有序数组中查找元素，还可应用于解决一些涉及优化决策和答案区间的问题，如“最大值最小化”等二分答案的问题。这类问题通常要求我们找到满足特定条件的最优值，并且答案具有某种单调性，使得二分搜索成为理想的解决方案。

### （3）二分答案

"二分答案" 是一种解题策略，广泛应用于解决那些答案可能在一定范围内并且满足某种单调性条件的问题。在这种策略中，你不是去枚举每一个可能的答案来检验其正确性，而是通过二分搜索法来更高效地缩小答案的可能范围。

在“二分答案”的方法中，你通常会遇到这样一类问题：需要确定一个最优值（例如最大值最小、最小值最大），且这个最优值满足某种判断条件（如是否可行、是否符合要求等）。

#### 二分答案的适用条件

1. **固定的答案区间**：你知道可能的最大值和最小值，即答案存在于一个明确的区间内。
2. **单调性**：如果某个值是可行的，那么在这个值的一侧（取决于问题是求最大还是最小）的所有值也都是可行的。这种单调性是应用二分搜索的关键。
3. **判断函数**：该函数用于检验中间值 `mid` 是否满足题目条件。接着，通过调整搜索范围（上限或下限），逐步逼近答案。

#### 示例

考虑一个问题，比如确定一个最小的速度，使得在该速度或更高速度下，一个车辆可以在规定时间内完成一定距离的行驶。

假设速度范围是从 1 km/h 到 100 km/h。你会这样使用二分答案：

- **设定初始范围**：low = 1, high = 100。
- **二分搜索**：
  - 计算中值 `mid = (low + high) / 2`。
  - 通过一个函数 `canComplete(mid)` 检验在速度 `mid` 下是否可以完成任务。
  - 如果 `canComplete(mid)` 返回 true，说明至少可以在这个速度下完成任务，因此尝试更小的速度，即调整上限 `high = mid`。
  - 如果返回 false，说明即使是这个速度也不能完成任务，因此需要更高的速度，即调整下限 `low = mid + 1`。
- **终止条件**：当 `low` 与 `high` 相遇时，即找到了满足条件的最小速度。

与枚举所有可能值相比，二分答案大幅减少了计算次数，特别是在答案范围较大时。

通过二分答案，复杂的优化问题可以转化为一系列可操作的判断任务，从而有效地找到最优解。这种策略提高了解决问题的效率和可扩展性，是算法设计中的一种重要技巧。

### （4）最大值最小化

“最大值最小化”问题常见于如分配、装载、调度等场景，其中我们需要将一系列资源或任务分配到若干组中，使得各组中“最不理想”的情况尽可能地“最理想”。例如，分割数组、最大工作负载最小化等。

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做1，不满足看做0 ，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

#### 条件

要使用二分搜索解决这类问题，需确保以下条件：

1. **固定的答案区间**：必须知道可能的答案范围，即最小值和最大值。
   
2. **判断条件的可实现性**：需要一个有效的方法来判断任何一个给定的中间值是否可行（可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值的可行性）。
   
3. **答案的单调性**：如果一个特定的值是可行的，那么在一个方向上所有的值也应该是可行的（例如，如果某个载重量能承受，则更大的载重量也应当能承受）。

#### 实现策略
使用二分搜索来不断调整答案范围，直至找到最优解：

```java
//[)
int binarySearchMinimizeMax(int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isFeasible(mid)) {
            high = mid; // 如果mid可行，则可能的最大值可以更小
        } else {
            low = mid + 1; // 如果mid不可行，需要增加值
        }
    }
    return low; // low 和 high 会收敛到最小的可行解
}
```

适用于很多看似不是搜索问题的优化问题，尤其是在解的单调性可以被明确的情况下。

考虑一个问题，比如要将一组作业分配给k个工人，使得每个工人的最大工作量尽可能小。这里，我们可以使用二分搜索来确定这个“最大工作量”的最小可能值。

### （5）例题

华为od：

2024D-部门人力分配

2024D-项目排期

2024D-孙悟空吃蟠桃

2024D-小明找位置

## 11.倍增

## 12.构造

# 二、搜索

## 1.简介

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。

搜索是一些高级算法的基础。在 OI 中，纯粹的搜索往往也是得到部分分的手段，但可以通过纯粹的搜索拿到满分的题目非常少。

## 2.DFS（搜索）

### （1）引入

在搜索算法中，DFS通常指的是通过递归函数实现暴力枚举的算法，这在结构上与图论中的DFS算法相似，但并非完全相同。

这里的DFS依然保持“深度优先”的探索特点，即先探究一种可能性直到其最终结果，然后回溯至上一个决策点尝试另一种可能。

假设有一个问题：将正整数 $$n$$ 分解为3个不同的正整数的和，例如 $$6 = 1 + 2 + 3$$，且每一个数必须大于等于前一个数。要输出所有的分解方案。

如果不使用搜索技术，可以通过三重循环来解决问题：

```java
for (int i = 1; i < n + 1; i++) {
    for (int j = i; j < n + 1; j++) {
        for (int k = j; k < n + 1; k++) {
            if (i + j + k == n) System.out.printf("%d = %d + %d + %d%n", n, i, j, k);
        }
    }
}
```

如果要将数字分解为四个或更多个整数，仅仅增加更多的循环显然不是一个高效的解决方案，这时就需要考虑使用递归搜索。

### （2）DFS实现

该类搜索算法的特点在于将问题分为多个“层”，每层基于前几层的状态进行决策，直到达到目标状态。

例如，将正整数 $$n$$ 分解成小于等于 $$m$$ 个正整数之和，且后一个数至少与前一个数相等，输出所有方案。这可以通过递归的方式实现，每层决定一个整数部分，直至整个数被完全分解。

设一组方案将 $$n$$ 分解为 $$k$$ 个正整数 $$a_1, a_2, \ldots, a_k$$ 的和。我们在递归中记录三个状态变量：$$n - \sum_{j=1}^{i-1} a_j$$，即剩余未分配的和；$$a_{i-1}$$，即前一层的正整数，用于保证数的递增；和 $$i$$，即当前递归的深度，用于确保总数不超过 $$m$$。

为了记录方案，我们用 arr 数组，第 $$ i $$ 个表示 $$ a_i $$，注意到 arr 实际上是一个栈的概念。

递归搜索的Java实现代码如下：

```java
static int m;

// arr 用于记录方案
static int[] arr = new int[103];

//n：当前需要分解的数值。
//i：当前分解中的位置索引，即数组 arr 的索引。
//a：当前循环的起始数，保证递增。
public static void dfs(int n, int i, int a) {
    if (n == 0) {
        for (int j = 1; j <= i - 1; j++) System.out.printf("%d ", arr[j]);
        System.out.println();
    }
    if (i <= m) {
        for (int j = a; j <= n; ++j) {
            arr[i] = j;
            dfs(n - j, i + 1, j); 
        }
    }
}

// 主函数
final int N = new Scanner(System.in).nextInt();
m = new Scanner(System.in).nextInt();
dfs(N, 1, 1);
```

### （3）例题

华为od：

2024D-精准核酸检测（并查集）

2024D-生成哈夫曼树

2024D-可以组成网络的服务器

2024D-图像物体的边界

## 3.BFS（搜索）

### （1）简介

BFS 是图论中的一种遍历算法。

BFS 在搜索中也很常用，将每个状态对应为图中的一个点即可。

### （2）例题

华为od：

2024D-地图寻宝（BFS）

2024D-二叉树的广度优先遍历（DFS/BFS）

2024D-聚餐地点（BFS）

## 4.双向搜索

## 5.启发式搜索

## 6.A*

## 7.迭代加深搜索

## 8.IDA*

## 9.回溯法

### （1）简介

回溯法（Backtracking）是一种解决问题的算法，主要用于解决决策问题。它通过试探和回退的方式，逐步探索所有可能的解决方案，以找到所有或者特定的解。这种方法在深度优先搜索（DFS）和广度优先搜索（BFS）中尤为常见，尤其适用于解决组合、排列、分割等问题。

其核心思想是：“试错”——当探索到某一步时，发现当前方案不可行，则退回一步或几步，尝试其他可能的选项。

因此，它常被形象地描述为“走不通就回头”。

### （2）过程

1. **构造空间树**：首先定义问题的解空间，通常表现为树形结构，其中每个节点代表了解决方案中的一部分。
2. **进行遍历**：从根节点开始，按照深度优先搜索（DFS）的策略，探索每一条路径。
3. **边界条件判断**：在遍历过程中，如果遇到不满足条件的节点，就回退到上一步或者上几步，换一个分支继续探索。
4. **达到目标条件**：一旦找到一个解或者所有路径都探索完毕，算法结束。如果找到的是满足特定条件的解，则记录或输出结果。

### （3）例题

华为od：

2024D-表演赛游戏分组

2024D-找到它

## 10.Dancing Links

## 11.Alpha-Beta 剪枝

## 12.优化

# 三、动态规划

## 1.简介

动态规划（Dynamic Programming, DP）是一种通过将原问题分解为相对简单的子问题来解决复杂问题的方法。动态规划不是一种具体的算法，而是一种解决特定问题的策略，因此它广泛应用于多种数据结构和问题类型中。

此外，一些计数或非最优化问题的递推解法有时也被称为动态规划，尽管这种命名并不严格。事实上，动态规划与其他类型的递推有许多相似之处，了解它们之间的异同对学习十分有帮助。

### （1）引入

[P1216 [USACO1.5\] [IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1216)

观察下面的数字金字塔：

![img](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

任务是编写一个程序，找出从顶端到底部的一条路径，使得路径上的数字之和最大。每一步可以走到左下或右下。

例如，在上图中，路径 7→3→8→7→5 产生了最大的数字和。

最直接的方法是尝试所有可能的路径，但由于路径数目是 $O(2^n)$ 级别的，这种方法不可行。

注意到，对于任何一条最优路径，其每一步的决策都是最优的。例如，考虑路径 7→3→8→7，到达第四行第二个数时，没有其他路径可以得到更高的权值。

对每个点来说，下一步只有两种选择：左下或右下（如果存在）。因此，只需记录当前点的最大权值，并用这个最大权值来更新后续点的最大权值，从而减少问题的规模。

但这种方法可能存在子问题重复计算的问题，即同一个子问题可能会被多次求解。为解决这一问题，可以通过“记忆化”的方式存储每个子问题的解，确保每个子问题只被计算一次。

上述内容概述了动态规划的基本思想，接下来的部分将系统地介绍动态规划的各种策略和应用。

### （2）动态规划原理

动态规划适用于解决满足三个核心特性的问题：最优子结构、无后效性和子问题重叠。理解这些特性是掌握动态规划的关键。

#### 最优子结构

最优子结构是指一个问题的最优解包含其子问题的最优解。如果一个问题具有最优子结构，那么可以通过组合子问题的最优解来构造整个问题的最优解。这种特性是动态规划和贪心算法的共同点，但动态规划通常适用于子问题相互重叠且需要全局优化的情形。

意味着，要解决一个大问题的最优解，你可以依赖更小的子问题的最优解来构建。这就像搭建一座大楼，如果每一层都是坚固的，那么整座大楼自然也是坚固的。

为了利用最优子结构，可以采取以下步骤：

1. **确定选择**：证明问题的最优解开始于做出一个选择。
2. **分析子问题**：对于每个可能的首选项，假设其余部分已被解决，并确定由此产生的子问题。
3. **问题简化**：描述子问题空间，并尽量保持其简单。
4. **反证法**：证明每个子问题的解必须是最优的。如果某个子问题的解非最优，则可以用其最优解替换，导致原问题的解更优，与最优解的设定矛盾。

简单例子：找零问题

想象你是一个店主，需要给客人找零95美分。你的抽屉里有25美分、10美分、5美分和1美分的硬币。问题是：如何用最少的硬币数量完成找零？

如果我们用最优子结构的思维来看这个问题，我们会这样思考：

1. **确定选择**：首先选择一个硬币，这个选择应该是使剩下的找零金额最容易解决的硬币。例如，首先选择一个25美分的硬币，因为它值得最多。
2. **分析子问题**：选择了一个25美分硬币后，你现在需要找零70美分（95 - 25）。这个70美分的找零问题就是一个新的子问题。
3. **问题简化**：重复步骤1和2，每次都选择一个最大的硬币，直到找零金额为零。接下来，你可能会再选一个25美分，然后是20美分（两个10美分），最后是5美分。
4. **反证法**：如果你在任何步骤中选择了一个不同的硬币（如开始就用三个10美分而不是一个25美分），你最终将使用更多硬币。因此，每个子问题（如剩余70美分、45美分等）的解决方案都必须是最优的，否则，整个找零过程就不是最优的。

这个例子展示了如何通过解决每个小问题的最优解（最少硬币数量），逐步构建出整个问题的最优解。动态规划正是通过这种方式工作的，只不过它还会存储每个子问题的解，避免重复计算，提高效率。

#### 无后效性

无后效性意味着一旦某个子问题的解被确定后，它就不会被后续的决策影响。这是动态规划中的重要特性，它保证了一旦某个状态被计算，其结果就可以被存储并反复使用，而不需要考虑将来可能的变化。

#### 子问题重叠

动态规划的效率在很大程度上依赖于子问题的重叠性。在许多情况下，不同的递归计算路径会多次遇到同一子问题。通过记忆化技术（通常使用数组或哈希表存储已解决的子问题的解），可以避免重复计算，从而显著提高效率。

子问题的存储不仅节省了计算时间，也简化了问题解决过程，使我们能够仅通过查表来获取已解决子问题的结果，这是动态规划与普通递归或贪心算法的显著区别。

### （3）基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 有向无环图，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题。

## 2.记忆化搜索

记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

### （1）引入

[P1048 [NOIP2005 普及组\] 采药 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1048)

#### 朴素的 DFS做法

#### 优化

### （2）与递推的联系与区别

### （3）如何写记忆化搜索

#### 方法一

#### 方法二

所谓“无需外部变量”的 DFS 是指在递归过程中不依赖于类或全局作用域的变量来存储结果，而是通过递归的返回值来传递结果。

## 3.背包DP

## 4.区间DP

## 5.DAG上的DP

## 6.树形DP

## 7.状压DP

## 8.数位DP

## 9.计数DP

## 10.动态DP

## 11.概率DP

## 12.DP优化

## 13.其他DP方法

# 四、字符串

# 五、数学

# 六、数据结构

# 七、图论









