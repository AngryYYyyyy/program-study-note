



# 容器

# 一、容器概述

> 容器，置物之所也。

容器（Container）是指一些数据结构（Data Structures）的抽象，用于存储和组织数据。

容器提供了一系列操作，比如添加、删除、查找、排序等，这些操作可以方便地对容器中的元素进行操作，通过使用STL（Standard Template Library）提供的容器，可以大大简化程序的编写和维护，提高开发效率和程序性能。

# 二、STL各大容器的结构与分类

## 2.1序列式容器

> 所谓序列式容器，其中元素都可序（order），但未必有序（sorted）

序列式容器（Squence Containers），其底层逻辑为线性序列的数据结构，里面存储的是元素本身。

与关联式容器(Associattive Containers)不同，序列式容器中的元素是按照它们在容器中出现的顺序进行组织和访问的，而不是按照它们的值进行排序

STL提供了多种序列式容器，包括`vector`、`deque`、`list`、`forward_list`、`array`和`string`（由于历史原因不在STL库中）等，如下表

|       容器       | 简要说明                                                     | 文档链接                                      |
| :--------------: | :----------------------------------------------------------- | :-------------------------------------------- |
|    **vector**    | vector是一个动态数组，支持快速随机访问和在末尾进行添加和删除操作。它可以自动扩容以适应需要，并提供了一些有用的成员函数，如push_back、pop_back等 | https://cplusplus.com/reference/vector/       |
|    **deque**     | deque是一个双端队列，支持在两端进行添加和删除操作，并支持快速随机访问。它的内部实现使用了多个定长数组，因此可以避免vector的频繁扩容 | https://cplusplus.com/reference/deque/        |
|     **list**     | list是一个双向链表，支持在任意位置进行添加和删除操作，但不支持快速随机访问。它的优势在于插入和删除操作的效率较高，不需要像vector一样进行数组的移动 | https://cplusplus.com/reference/deque/        |
| **forward_list** | forward_list是一个单向链表，与list类似，但只能从头部开始遍历。由于只需要一个指针来表示下一个节点，因此它的内存占用较小，但无法在任意位置进行删除操作。 | https://cplusplus.com/reference/forward_list/ |
|    **array**     | array是一个定长数组，与普通的C数组类似，但提供了一些STL的支持，如begin、end等 | https://cplusplus.com/reference/array/        |
|    **string**    | string是一个特殊的容器，用于存储和操作字符串。它底层使用字符数组实现，但提供了很多便利的成员函数，如substr、find等 | https://cplusplus.com/reference/string/       |

> 注意：list和forward_list的元素存储在物理结构上是分散的，其余容器元素存储是连续的
>

## 2.2关联式容器

关联式容器是一种使用键值对`pair<key,value>`存储数据的数据结构，其中每个元素都是通过其关键字进行索引,在数据检索时比序列式容器效率更高。

STL提供了多种关联式容器,包括set、multiset、map、multimap、undered_set、undered_multiset、undered_map、undered_multimap

| 容器                         | 简要说明                                                     | 文档链接                                       |
| ---------------------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| set/multiset                 | set 和 multiset 容器是基于红黑树实现的，元素按照键值自动排序，不允许键值重复。set 容器中元素的键值就是元素本身，而 multiset 容器则允许重复的键值。 | https://cplusplus.com/reference/set/           |
| map/multimap                 | map 和 multimap 容器也是基于红黑树实现的，元素按照键值自动排序，键值不允许重复。map 容器中每个元素包含一个键和一个值，而 multimap 容器则允许重复的键值。 | https://cplusplus.com/reference/map/           |
| undered_set/underedmulti_set | unordered_set 和 unordered_multiset 容器是基于哈希表实现的，元素不按照键值排序，但可以快速访问元素。键值必须是可哈希的，不允许键值重复，而 unordered_multiset 容器则允许重复的键值 | https://cplusplus.com/reference/unordered_set/ |
| undered_map/underedmulti_map | unordered_map 和 unordered_multimap 容器也是基于哈希表实现的，元素不按照键值排序，但可以快速访问元素。键值必须是可哈希的，键值不允许重复，而 unordered_multimap 容器则允许重复的键值 | https://cplusplus.com/reference/unordered_map/ |



## 2.3容器适配器

> 修改某物接口，形成另一种风貌

在C++ STL中，容器适配器（Container Adapter）是一种特殊的容器，其目的是提供一种新的容器类型，通过限制或增强其操作，从而满足特定的需要。容器适配器提供了不同于常规STL容器的操作方法，以及更加灵活的内部实现方式，可以用来实现一些特定的数据结构或算法。

STL中有三种容器适配器，包括stack、queue、priority_queue

| 容器适配器     | 简要说明                                                     | 文档链接                               |
| -------------- | ------------------------------------------------------------ | -------------------------------------- |
| stack          | stack是一种后进先出（LIFO）的容器，它允许在栈顶添加或删除元素。由于栈具有LIFO的特性，stack可以很容易地实现一些需要后进先出的操作，比如回溯算法。在STL中，stack通常基于deque或list实现。 | https://cplusplus.com/reference/stack/ |
| queue          | queue是一种先进先出（FIFO）的容器，它允许在队尾添加元素，在队首删除元素。由于队列具有FIFO的特性，queue可以很容易地实现一些需要先进先出的操作，比如广度优先搜索。在STL中，queue通常基于deque或list实现。 | https://cplusplus.com/reference/queue/ |
| priority_queue | priority_queue是一种带有优先级的队列，它允许在队尾添加元素，但在删除元素时总是删除具有最高优先级的元素。在STL中，priority_queue通常基于vector实现。 | https://cplusplus.com/reference/queue/ |

容器适配器并不是STL中的容器，它们的内部实现通常基于常规的STL容器。它们只提供了特定的接口和语义，是一种比较简单、方便的封装方式。

# 三、具体容器的剖析

## 3.1序列式容器

### 3.1.1 vector(向量)

#### （1）vector迭代器

- ##### 迭代器类型

vector迭代器是原生指针`T*`，具有随机访问的能力，属于Random Access Iterators

```c++
//未萃取的版本
template <class T>
class vector
{
public:
    typedef T* iterator; //vector迭代器是普通指针
    typedef const T* const_iterator;
    iterator begin(){return _start;}
    iterator end(){return _finish;}
    const_iterator cbegin() const{return _start;}
    const_iterator cend() const{return _finish;}
};
```

- ##### 迭代器失效

迭代器在insert操作时因扩容会出现失效问题，erase也会出现访问end（）和意义丢失等迭代器失效问题

#### （2）vector的数据结构

vector数据结构为线性连续空间，以两个迭代器（iterator）`_start`和`_finish`来分别指向连续空间中目前被使用的有效数据的范围，并以`_end_of_storage`指向整块连续空间的尾端

```c++
template <class T>
class vector
{
  //.....
  protect:
    iterator _start;		// 指向数据的头
	iterator _finish;		// 指向有效数据的尾
	iterator _end_of_storage;  //指向存储容量的尾
};
```

为了提高vector的效率，vector的实际配置大小（size）比需要使用的空间大小要更大一些，以备将来之需，这便是引入容量的概念（capacity）。

<img src="D:\笔记\STL\image-20230425004638303.png" style="zoom: 80%;" />

#### （3）vector的构造和内存管理

可以用初始化列表创建一个空的vector对象

```c++
vector()
    : _start(nullptr)
        , _finish(nullptr)
        , _endOfStorage(nullptr)
    {}
```

也可以用任意迭代器初始化构造

```c++
template<class InputIterator>//若使用iterator做迭代器，会导致初始化的迭代器区间[first,last)只能是vector的迭代器
    vector(InputIterator first, InputIterator last)
{
    while (first != last)
    {
        push_back(*first);
        ++first;
    }
}
```

拷贝构造和赋值重载：利用`tmp`交换资源，`tmp`会在函数调用结束后自动析构，注意拷贝构造参数的类型，防止重复调用。

浅拷贝对涉及资源管理的类会引发重复析构和指向同一值问题，前者可以通过计数解决，后者可以通过写时拷贝。

```c++
vector(const vector<T>& v)//拷贝构造使用const的引用
    : _start(nullptr)
    , _finish(nullptr)
    , _end_of_storage(nullptr)
    {
        vector<T> tmp(v.cbegin(),v.cend());//拷贝构造的现代写法
		swap(tmp);						//资源互换
    }
vector<T>& operator=(vector<T> v)
{
    swap(v);
    return *this;
}
```

析构：vector的析构函数用于释放内存并销毁vector对象，由于vector的元素在内存中是连续存储的，所以析构函数只需要简单地释放内存即可

```c++
~vector()
{
    if (_start)
    {
        delete[] _start;
        _start = _finish = _end_of_storage = nullptr;
    }
}
```

容量处理，资源的开辟一定考虑深拷贝问题

```c++
size_t size() const { return _finish - _start; }
size_t capacity() const { return _endOfStorage - _start; }
bool empty() const { return _start == _finish; }
void reserve(size_t n)
{
    if (n > capacity())
    {
        size_t oldSize = size();
        T* tmp = new T[n];
        if (_start)
        {
            for (size_t i = 0; i < oldSize; ++i)
                tmp[i] = _start[i];//深拷贝
            delete[] _start;
        }
        _start = tmp;             //更新迭代器
        _finish = _start + oldSize;
        _endOfStorage = _start + n;
    }
}
void resize(size_t n, const T& value = T())
{
    if (n <= size())
    {
        _finish = _start + n;
        return;
    }
    if (n > capacity())
        reserve(n);
    iterator it = _finish;
    _finish = _start + n;
    while (it != _finish)
    {
        *it = value;
        ++it;
    }
}
```

扩容时，迭代器需要更新，否则会出现迭代器失效问题，返回当前位置的迭代器

```c++
void push_back(const T& val)
{
    insert(end(), val);
}
iterator insert(iterator pos, const T& x)
{
    assert(pos <= _finish);
    if (_finish == _endOfStorage)
    {
        size_t newCapacity = (0 == capacity()) ? 1 : capacity() * 2;
        reserve(newCapacity);
        pos = _start + size();    //更新迭代器pos
    }
    iterator end = _finish ;
    while (end >pos)
    {
        *end  = *(end-1);
        --end;
    }
    *pos = x;
    ++_finish;
    return pos;
}
```

#### （4）vector的元素操作

访问[]/find

```c++
T& operator[](size_t pos) 
{ 
    assert(pos < size());
    return _start[pos]; 
}
template<class InputIterator,class T>
    InputIterator find(InputIterator first,InputIterator last,cosnt T& val=T())
{
    while(first!=last)
    {
        if(*first==val)
        {
            return first;
        }
        fitst++;
    }
    return last;//返回end（）   
}
```

删除元素，返回删除数据的下一位，在循环中使用erase需注意迭代器失效问题

```c++
void pop_back()
{
    erase(end());
}
iterator erase(iterator pos)
{
    iterator begin = pos + 1;
    while (begin != _finish) {
        *(begin - 1) = *begin;
        ++begin;
    }
    --_finish;
    return pos;// 返回删除数据的下一个数据
}
```

#### （5）vector的OJ练习题

[118. 杨辉三角 - 力扣（LeetCode）](https://leetcode.cn/problems/pascals-triangle/submissions/)

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/submissions/)

[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/submissions/)

> n>>i&1取n的第i位
>
> n|1<<i  改n的第i位为1

[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/submissions/)

[数组中出现次数超过一半的数字_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/submissions/)

#### 3.1.2 list/forward_list（链表）

1）list的节点

双向链表

```c++
template<class T>
    struct ListNode
    {
        ListNode(const T& val = T()): _prev(nullptr), _next(nullptr), _val(val){}
        ListNode<T>* _prev;
        ListNode<T>* _next;
        T _val;
    };
```

2）list的迭代器

list是双向链表，迭代器具有前移和后移的能力，属于Bidirectional Iterators，在insert、splice操作中迭代器并不会失效，甚至erase操作也只会让“指向被删除元素”的迭代器失效

```c++
template<class T, class Ref, class Ptr>
    class ListIterator
    {
        typedef ListNode<T> Node;
        typedef ListIterator<T, Ref, Ptr> Self;
   		public:
        typedef Ref Ref;//实现反向迭代器
        typedef Ptr Ptr;
        public:
        ListIterator(Node* node = nullptr): _node(node){}
        Ref operator*() { return _node->_val;}
        Ptr operator->() { return &(operator*()); }
        Self& operator++(){_node = _node->_next;return *this;}
        Self operator++(int){Self temp(*this);_node = _node->_next;return temp;}
        Self& operator--(){_node = _node->_prev;return *this;}
        Self operator--(int){Self temp(*this);_node = _node->_prev;return temp;}
        bool operator!=(const Self& l)const{ return _node != l._node;}
        bool operator==(const Self& l)const{ return _node != l._node;}
        Node* _node;//与容器的关联
    };
```

反向迭代器是以迭代器作为底层的适配器

```c++
template<class Iterator>
	class ReverseListIterator
	{
	public:
		typedef typename Iterator::Ref Ref;// 注意：此处typename的作用是明确告诉编译器，Ref是Iterator类中的一个类型，而不是静态成员变量
		typedef typename Iterator::Ptr Ptr;
		typedef ReverseListIterator<Iterator> Self;//rbegin和rend底层与iterator对称实现
	public:
		ReverseListIterator(Iterator it): _it(it){}
		Ref operator*(){Iterator temp(_it);--temp;return *temp;}//返回上一个迭代器的值
		Ptr operator->(){return &(operator*());}
		Self& operator++(){--_it;return *this;}
		Self operator++(int){Self temp(*this);--_it;return temp;}
		Self& operator--(){++_it;return *this;}
		Self operator--(int){Self temp(*this);++_it;return temp;}
		bool operator!=(const Self& l)const{return _it != l._it;}
		bool operator==(const Self& l)const{return _it != l._it;}
		Iterator _it;
	};
```

类中对迭代器的声明

```c++
template<class T>
	class list
	{
		typedef ListIterator<T, T&, T*> iterator;
		typedef ListIterator<T, const T&, const T&> const_iterator;
		typedef ReverseListIterator<iterator> reverse_iterator;
		typedef ReverseListIterator<const_iterator> const_reverse_iterator;
	};
}
```

3）list的数据结构

```c++
template<class T>
class list
{
private:
		Node* _head;
}；
```

3）list的构造和内存管理

4）vector的元素操作

```c++
// 在pos位置前插入值为val的节点
iterator insert(iterator pos, const T& val)
{
    Node* pNewNode = new Node(val);
    Node* pCur = pos._node;
    pNewNode->_prev = pCur->_prev;
    pNewNode->_next = pCur;
    pNewNode->_prev->_next = pNewNode;
    pCur->_prev = pNewNode;
    return iterator(pNewNode);//返回新插入的节点位置
}
iterator erase(iterator pos)
{
    Node* pDel = pos._node;
    Node* pRet = pDel->_next;
    pDel->_prev->_next = pDel->_next;
    pDel->_next->_prev = pDel->_prev;
    delete pDel;
    return iterator(pRet);返回节点删除的位置
}
```

#### 3.1.3 deque （双端队列）

#### 3.1.4 vector和list的比较

|            | vector                                                       | list                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储方式   | 连续的内存块存储元素，尾插尾删效率高，其他位置发生移位效率低 | 双向链表存储元素，在任意位置插入删除效率高                   |
| 随机访问   | 支持随机访问                                                 | 不支持，效率为o（n）                                         |
| 内存分配   | 预先分配一定大小的内存，当插入元素时，如果空间不足，会重新分配一块更大的内存，将原有元素拷贝到新内存中，然后释放原有内存 | 每次插入元素都会分配一块新的内存，因此不需要频繁地重新分配内存，但会带来额外的内存分配开销 |
| 迭代器失效 | 在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效 | 插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响 |
| 使用场景   | 需要高效存储，支持随机访问，不关心插入删除效率               | 大量插入和删除操作，不关心随机访问                           |



### 3.2关联式容器

#### 3.2.1 set /multiset（集合）

1）set

```c++

```

2）map

#### 3.2.2 map/multimap （映射）

#### 3.2.3 undered_set/undered_map

### 3.3容器适配器

#### 3.3.1 stack(堆栈)

1）模拟实现

```c++
template<class T>
    class stack
    {
        public:
        stack() {}
        void push(const T& x) {_c.push_back(x);}
        void pop() {_c.pop_back();}//删除栈顶元素
        T& top() {return _c.back();}//返回栈顶元素
        const T& top()const {return _c.back();}
        size_t size()const {return _c.size();}
        bool empty()const {return _c.empty();}
        private:
        std::vector<T> _c;//STL中默认使用了deque
    };
}
```

2）stack的OJ练习题

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)

> 一个输入栈，一个输入栈

[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/submissions/)

[栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/)

#### 3.3.2 queue

1）模拟实现

```c++
template<class T>
    class queue
    {
        public:
        queue() {}
        void push(const T& x) {_c.push_back(x);}//尾部插入
        void pop() {_c.pop_front();}//头部删除
        T& back() {return _c.back();}
        const T& back()const {return _c.back();}
        T& front() {return _c.front();}
        const T& front()const {return _c.front();}
        size_t size()const {return _c.size();}
        bool empty()const {return _c.empty();}
        private:
        std::list<T> _c;//STL中默认使用了deque
    };

```

2）queue的OJ练习题

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/submissions/)

#### 3.2.3 priority_queue

STL中的priority_queue是一个容器适配器，它在队列的基础上提供了排序的功能。它使用堆来实现排序，默认为大堆，利用less仿函数，具有高效的插入、删除和查找操作。priority_queue通常用于需要按照优先级排序的场景，如任务调度等。

1)模拟实现

```c++
template<class T>
    struct less
    {
        bool operator()(const T& left, const T& right)
        {
            return left < right;
        }
    };
template<class T>
    struct greater
    {
        bool operator()(const T& left, const T& right)
        {
            return left > right;
        }
    };
template<class T, class Container = std::vector<T>, class Compare = less<T>>
    class priority_queue
    {
        public:
        template<class Iterator>
            priority_queue(Iterator first, Iterator last)
            : c(first, last)
            {
                int count = c.size();
                int root = ((count - 2) >> 1);
                for (; root >= 0; root--)
                    AdjustDown(root);
            }
        void push(const T& data)
        {
            c.push_back(data);
            AdjustUP(c.size() - 1);
        }

        void pop()
        {
            if (empty())
                return;
            swap(c.front(), c.back());
            c.pop_back();
            AdjustDown(0);
        }
        size_t size()const
        {
            return c.size();
        }
        bool empty()const
        {
            return c.empty();
        }
        // 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性
        const T& top()const
        {
            return c.front();
        }	
        private:
        Container c;
    };
}
```

2）priority_queue的OJ练习题

