# 一、项目简介

## 1.项目功能

## 2.业务架构

![img](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/f4ed032886604b3eac0fb5adb6e62bdd.jpg)

## 3. 技术栈详述

### 前端：
- **uni-app**：用于构建跨平台的移动应用。

### 数据库：
- **MySQL**：作为主要的关系数据库管理系统。

### 缓存系统：
- **Redis**：用于提高数据处理速度的内存中数据结构存储系统。

### 注册中心：
- **Nacos**、**Consul**、**Eureka**：这些工具用于服务的注册与发现，以支持微服务架构的高可用性和灵活性。

### 配置中心：
- **Spring Cloud Config**：提供服务器和客户端支持，用于外部化配置管理。

### 微服务网关：
- **Spring Cloud Gateway**：作为API网关，管理微服务的路由规则、权限验证等。

### 熔断设计与实战：
- **Spring Cloud Circuit Breaker**、**Resilience4J**、**Spring Cloud Alibaba Sentinel**：提供服务熔断保护，增强系统的弹性。

### 限流设计与实战：
- **Spring Cloud Alibaba Sentinel**：用于服务限流，保护系统在高流量下的稳定性。

### 服务监控：
- **Spring Cloud Sleuth**、**Spring Cloud Zipkin**：支持服务调用的跟踪与监控，提高系统的可观察性。

### 分布式解决方案：
- **Redis**：除了作为缓存，还能支持实现分布式锁等高级功能。

## 4. 设计规范概述

> 本项目严格遵循**阿里巴巴Java开发手册**来确保代码的质量和可维护性。

### （1）接口设计

- **工具使用**：采用**Apifox**来管理API文档。
- **设计风格**：接口设计遵循**RESTful**风格，确保接口的简洁性和易用性。

### （2）工程设计

- **项目结构**：明确项目整体结构和单个工程的布局。
- **依赖管理**：合理组织项目依赖，确保系统组件之间的高度协同。

### （3）数据库设计

- **索引设计**：精心设计数据库索引，优化查询性能并减少资源消耗。
- **事务设计**：合理利用数据库事务，确保数据操作的原子性、一致性、隔离性和持久性。

# 二、乘客用户中心服务系列

## 1.乘客注册/登录服务

### （1）乘客注册/登录服务时序图

![image-20240428152705056](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428152705056.png)

### （2）Redis分布式存储验证码和Token

#### **采用Redis方案的作用**

Redis是一个高性能的键值对数据库，经常用于缓存、会话管理、排行榜、发布订阅系统等。在分布式系统中，使用Redis存储验证码和JSON Web Token（JWT）有多个作用：

1. **速度快**：Redis基于==内存操作==，==读写速度极快==，适合高速读取的场景，比如频繁的验证码校验和JWT验证。
2. **减轻数据库压力**：将验证码和JWT存储在Redis中可以==减少对主数据库的访问次数==，减轻数据库负担，尤其是在高并发情况下。
3. **分布式支持**：在分布式系统中，可以通过Redis保证数据的一致性和同步，这对于在==多个服务器间共享验证码和JWT状态非常重要==。
4. **安全性**：验证码和JWT通常具有时效性，Redis的==快速失效机制==可以帮助保证它们的时效性，提高系统的安全性。
7. **易用性**：Redis提供了简单易用的API，可以方便地进行验证码和JWT的存储、查询和管理。

具体到验证码和JWT的应用场景：

- **验证码**：通常用于验证用户身份，例如在登录、注册或执行敏感操作时。存储在Redis中可以快速比对用户输入的验证码和系统生成的验证码是否一致。

- **JWT**：作为一种状态无关的认证方式，经常用于分布式系统的用户认证。将JWT存储在Redis中可以用于快速访问和校验，同时可以方便地实现注销功能，即使JWT本身没有过期，也可以通过从Redis中移除对应的JWT来立即使其失效。

#### 具体使用细节

参考springboot官方文档[在 Spring Boot 中整合、使用 Redis - spring 中文网 (springdoc.cn)](https://springdoc.cn/spring-boot-data-redis/)

### （3）JWT

JWT（==JSON Web Token==）是一种开放标准（RFC 7519），它定义了一种简洁的、自包含的方法用于通信双方之间以 JSON 对象的形式安全地传输信息。每条信息都是经过数字签名的，因此可以验证其真实性。JWT 通常用于身份验证和信息交换，特别是在网络应用中。

用户登录后，服务器生成一个 JWT 并返回给客户端。客户端后续的请求都将这个 ==JWT 放在 HTTP 头的 Authorization 字段==里发送给服务器。服务器通过验证 JWT 的签名来验证请求者的身份。

#### JWT的结构

JWT 主要包含三个部分，它们之间以点（`.`）分隔：
1. **Header（头部）**:
   
   - 类型：通常是 JWT。
   - 算法：如 HMAC SHA256 或者 RSA。
   
   例如:
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```
2. **Payload（有效载荷）**:
   
   - 包含所要传递的信息，如用户ID、用户名等。
   - 还可以包含一些元数据，如发行人、过期时间等。
   - 注意，因为 JWT 的 payload 是基于 Base64 编码的，所以它==只是被编码而不是被加密的==，因此不应该在 payload 中放置任何敏感数据。
   
   例如:
   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true,
     "iat": 1516239022
   }
   ```
3. **Signature（签名）**:
   - 根据 header 中指定的算法，将 header、payload 以及一个密钥使用算法进行签名。
   - 签名的目的是保证 JWT 在传输过程中未被篡改。

   生成示例:
   ```plaintext
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret
   )
   ```

#### Jwt工具类-JwtTokenProvider以及具体使用细节

参考：[在 Spring Boot 中使用 Spring Security + JWT + MySQL 实现基于 Token 的身份认证 - spring 中文网 (springdoc.cn)](https://springdoc.cn/spring-boot-spring-security-jwt-mysql/)

### （4）双Token

在现代应用程序中，尤其是那些需要处理身份验证和会话管理的应用中，经常使用“双Token机制”，包括`accessToken`和`refreshToken`。这种机制提供了更加安全和灵活的方式来管理用户会话和身份验证状态。

#### AccessToken
`accessToken`（访问令牌）是用于访问应用程序资源的短期令牌。它允许用户在成功验证身份后访问服务器资源，通常有效期较短（如15分钟到几小时）。访问令牌的短期有效性可以减少某些安全风险，如令牌泄露。一旦`accessToken`过期，用户就无法再用它来访问需要授权的资源。

#### RefreshToken
`refreshToken`（刷新令牌）是一种长期有效的令牌，其主要目的是在`accessToken`过期后用来获取新的`accessToken`，而==不需要用户重新登录==。刷新令牌通常有效期较长，如几天、几周甚至几个月。

### （5）nacos注册中心

> 具体使用参考：[什么是 Nacos | Nacos](https://nacos.io/docs/v2/what-is-nacos/)

在 Nacos 中，服务提供者在启动时会向 Nacos 服务注册中心注册自己的地址和必要的元数据信息。服务消费者通过 Nacos 服务注册中心来发现可用的服务提供者并获取调用信息。当服务提供者的状态发生变化时，Nacos 注册中心会实时更新这一状态信息，并通知所有相关的服务消费者。

### （6）Feign 

> 具体使用参考：[Spring Cloud OpenFeign 中文文档 (springdoc.cn)](https://springdoc.cn/spring-cloud-openfeign/)

Feign 是一个声明式的 Web 服务客户端，使得编写 HTTP 客户端变得更简单。通过使用 Feign，开发者可以通过简单地声明接口和注解来自动构建 HTTP 请求。Feign 的目标是让编写 Java HTTP 客户端变得更简单。

Feign 集成了 Ribbon 和 Hystrix，因此除了提供 HTTP 客户端的功能外，还内置支持负载均衡和断路器模式，这些特性特别适合用在微服务架构中。

### （7）拦截器

### （8）异常处理

### （9）后续改进方案

添加账号密码注册/登录模式，使用Spring Security + MySQL方案，参考合家云物业管理项目

## 2.查询乘客服务（检测Token）

### （1）查询乘客服务流程图

<img src="D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428123445273.png" alt="image-20240428123445273" style="zoom: 67%;" />



# 三、预估价格服务系列

## 1.预估价格服务

### （1）预估价格服务时序图

![image-20240428145442508](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428145442508.png)

### （2）API的调用

> 参考：[概述-Web服务 API|高德地图API (amap.com)](https://lbs.amap.com/api/webservice/summary)

在开发过程中，经常需要通过调用外部API来扩展应用的功能。以高德地图API为例，以下是获取和使用外部Web服务API的一般步骤：

#### 申请“Web服务API”密钥（key）
为了使用高德地图的API服务，首先需要到官方网站注册并申请一个==API密钥（key）==。这个密钥将用于身份验证，确保API调用是经过授权的。

#### 构建HTTP请求URL
一旦获取到API密钥，就可以开始==构建HTTP请求==了。在请求的URL中，必须包含第一步申请的密钥作为一个必填参数。这个密钥是用来验证请求者身份的关键信息。

#### 接收并解析HTTP响应数据
API调用的响应通常以JSON或XML格式返回。收到数据后，需要对这些数据进行==解析==，以便提取有用信息或进一步处理。在整个接口交互过程中，输入参数和输出数据的编码应统一使用UTF-8，除非有其他明确的声明。

# 四、司机信息管理

## 1.CURD司机信息

### （1）时序图

![image-20240428152144913](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428152144913.png)

![image-20240428153051989](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428153051989-1714290272877-1.png)

### （2）项目规范设计

在设计数据库架构时，==用户信息和工作状态通常应该被组织为两个独立的表格==。这种分离有助于保持数据库的清晰性和可维护性。类似地，在业务逻辑的编写中，也强烈建议遵循MVC（模型-视图-控制器）模式，并尽量确保模型、视图和控制器之间的职责分明。将用户信息和工作状态在MVC结构中分别管理，不仅可以提高代码的组织性，还可以增强应用程序的可扩展性和可维护性。通过这样的设计规范，开发团队可以更有效地协作，同时也使得未来的维护和升级变得更加简单。

### （3）数据库列属性自动生成代码

**mybatis-plus-generator**

**MyBatis-Plus Generator** 是一个强大的代码生成器，它集成了 MyBatis-Plus 框架，旨在为开发者提供一种快捷方便的方式来生成实体类、映射文件以及对应的Mapper接口。

==**easycode**==

**EasyCode** 是一个基于 IntelliJ IDEA 的插件，用于生成各种层次的代码，如DAO、Service、Controller等。它特别适用于快速构建Spring Boot应用程序。

参考合家云物业管理项目

## 2.CURD车辆信息

### （1）时序图

![image-20240428160730118](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240428160730118.png)

### （2）高德地图猎鹰轨迹服务

> 参考：[猎鹰基本概念-猎鹰轨迹服务|高德地图API (amap.com)](https://lbs.amap.com/api/track/lieying-rumen)

注意在项目启动前，拿到serviceId

## 3.司机信息、车辆信息的绑定和解绑

## 4.司机登录服务

# 五、司机位置管理

## 1.司机同步位置（上传轨迹信息）

### （1）时序图

![image-20240501160200936](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240501160200936.png)

### （2）数据库设计

在设计数据库时，特定的信息如终端编号和轨迹编号，通常具有==敏感性质==，因而应当被==安全地存储在服务器的数据库中==，而非通过上层应用进行明文传输。这类信息涉及到系统内部操作，为保证数据安全和系统的完整性，应通过设计安全的API接口来进行查询和访问。通过这种方式，可以有效地控制对敏感信息的访问，确保这些信息不被未授权访问和滥用，同时也便于维护数据的完整性和一致性。

## 2.搜索司机位置（终端搜索）

## 3.轨迹查询

# 六、订单系统

## 1.乘客下订单

### （1）时序图

<img src="D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240501170714865.png" alt="image-20240501170714865" style="zoom: 200%;" />

### （2）流程图

![image-20240502134836344](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240502134836344.png)

### （3）分布式锁

分布式锁是一种用于==控制分布式系统中多个进程或服务访问共享资源的同步机制==。由于分布式系统通常运行在不同的物理或虚拟机器上，它们无法直接使用传统的内存锁（如Java中的`synchronized`或`ReentrantLock`）来实现线程或进程间的同步。因此，需要一种特殊的锁机制来确保跨网络的多个节点能够安全地操作共享资源。

分布式锁主要用于处理分布式计算环境中的资源同步问题，如：

- 确保分布式系统中的多个服务或任务在操作共享资源（如数据库中的数据或文件系统中的文件）时不会互相干扰。
- 在进行一些关键的操作，如数据聚合、支付处理或系统状态更新时，保证操作的原子性和一致性。

使用像Redis这样的分布式缓存系统来实现锁。Redis的==`SETNX`（set if not exists）命令==可以用来实现一个基本的锁机制。此外，Redis从2.6.12版本开始提供了更完善的`SET`命令支持，可以通过设置过期时间来自动释放锁，减少死锁的风险。

在网约车订单派发系统中，**==司机是关键的共享资源==**，特别是在高需求时段，==多个订单可能会竞争同一个可用司机==。当一个订单被处理并尝试分配给特定司机时，分布式锁确保无其他订单可以同时争夺该司机。

使用Redisson客户端来实现Redis的分布式锁，确保不会有多个司机接到同一个订单。以下是对该程序中分布式锁使用的分析：

**分布式锁的使用流程**

1. **锁的创建与获取**：对于每个符合条件的司机，程序生成一个==基于司机ID的锁键 `lockKey`==。使用Redisson客户端获取一个锁实例 `lock`，并调用 `lock.lock()` 尝试获取锁。这里使用的锁是阻塞式的，如果锁不可用，当前线程会等待直到锁被释放。
   
2. **锁的作用范围**：锁在检查司机==是否有进行中的订单之前获取==，如果检查结果显示司机有进行中的订单，锁会被释放，并继续检查下一个司机。如果司机没有进行中的订单，则继续使用该司机的信息更新订单信息，发送通知给司机和乘客，然后释放锁。
   
3. **锁的释放**：不管操作成功与否，一旦订单处理完成或确定不使用某司机后，锁都会被释放，以确保其他操作可以继续进行。

综上所述，虽然程序有效地使用了分布式锁来确保一个订单不会被多个司机接收，但在异常处理、锁的超时设置以及锁的粒度上还有改进的空间。

### （4）派发订单拓展

设定优先级系统来改善订单派发的公平性是一个很好的策略。这样的系统不仅能提高司机的满意度，还能优化整体的服务效率和客户体验。以下是一些实施优先级系统的建议：

首先需要定义何为“公平性”及其对应的优先级规则。这些规则可能基于多种因素，例如：
- **司机的工作时间**：长时间未接单的司机可以获得更高的优先级。
- **司机的地理位置**：距离订单起点最近的司机可能获得较高优先级。
- **司机的历史表现**：根据司机的评分、客户反馈等数据给予不同的优先级。
- **司机的车型**：某些订单可能需要特定类型的车辆。

实现一个优先级队列系统，用于管理等待接单的司机。当一个订单被创建时，系统可以根据预设的优先级规则从队列中选择合适的司机。

优先级系统应该是动态的，能够根据实时数据和反馈进行调整。例如，如果某司机连续多次拒绝接单，其优先级可以适当降低。

建立一个透明的优先级规则系统，并向司机明确这些规则，可以增强司机对系统的信任和接受度。同时，应该有机制允许司机对优先级决策提出反馈或申诉。

在技术层面，可以利用现有的数据结构和算法（如堆、优先队列等）来实现优先级队列。此外，确保优先级调度逻辑与现有的分布式锁系统兼容，以维护系统的稳定性和效率。

持续监控优先级系统的效果，并根据数据分析结果进行优化。这可以包括调整优先级参数、改进司机匹配算法等。

通过实施这样的优先级系统，您的网约车平台可以更合理地分配订单，同时提高司机的工作满意度和客户的服务体验。这种方法能够平衡各方利益，推动业务的长期发展。

### （5）预估价格拓展

确保你的定价系统可以实时更新，并且这些更新能够即时反映到用户界面上。这可能需要后端系统与前端应用之间的紧密集成，确保数据的及时传输。

在乘客最终确认订单前，提供一个价格确认步骤，显示最新计算的价格。这可以通过一个弹窗或在订单确认页面上的显著位置显示最终价格来实现。

如果在乘客浏览过程中价格发生变化（例如，由于需求高峰期的动态定价），应该明确通知乘客价格已更新。可以使用界面元素如弹出通知或特定的标签来提示用户。

提供一个简单的说明或常见问题解答（FAQ）部分，解释可能导致价格变化的因素，如高峰时段费用、天气影响等。这有助于增加乘客对价格变动的理解和接受。

在用户下单时，记录下价格计算所使用的规则版本。这不仅有助于内部审计和问题追踪，也在乘客有疑问时提供了依据。

考虑提供一个价格锁定功能，允许乘客在一定时间内以当前显示的价格下单。这可以作为一种增值服务，提升客户满意度和忠诚度。

通过实施这些策略，您的网约车服务可以更有效地管理价格变动，提升乘客体验，同时保持业务的透明度和公平性。这些措施将帮助建立乘客的信任，促进平台的长期成功。

### （6）消息推送

`SseEmitter` 是Spring Framework提供的一种支持服务器发送事件（Server-Sent Events，简称SSE）的机制，允许服务器向客户端浏览器推送实时数据。SSE 是一种标准的Web技术，允许服务器通过HTTP连接向客户端发送新的数据，这种连接一旦建立将保持开放，适用于实时通信场景。

`SseEmitter` 在以下场景中特别有用：
- 实时通知和消息
- 实时数据更新（例如，股票行情、竞拍、体育比赛实时分数）
- 进度条更新（如文件上传进度）

在Spring MVC中使用 `SseEmitter` 的基本步骤如下：

1. **创建一个控制器方法，返回 `SseEmitter`**
   ```java
   @RequestMapping(value = "/stream-sse", method = RequestMethod.GET)
   public SseEmitter streamSseMvc() {
       SseEmitter emitter = new SseEmitter();
       // 异步处理
       asyncTask(emitter);
       return emitter;
   }
   ```

2. **发送事件**
   在异步方法中发送事件到客户端。可以通过调用 `SseEmitter#send()` 方法发送数据，可以是简单的字符串、JSON对象或其他数据。
   ```java
   private void asyncTask(SseEmitter emitter) {
       try {
           for (int i = 0; i < 10; i++) {
               Thread.sleep(1000); // 模拟延迟
               emitter.send("Message " + i + " from server.");
           }
           emitter.complete(); // 完成事件流
       } catch (IOException | InterruptedException e) {
           emitter.completeWithError(e); // 发送错误信息
       }
   }
   ```

3. **处理连接关闭**
   可以添加一个处理器来管理客户端断开连接的情况。
   ```java
   emitter.onCompletion(() -> System.out.println("Emitter is completed"));
   emitter.onTimeout(() -> System.out.println("Emitter timed out"));
   emitter.onError((e) -> System.out.println("Error in emitter: " + e));
   ```

客户端使用JavaScript的 `EventSource` 接口接收来自服务器的事件。
```javascript
var eventSource = new EventSource('/stream-sse');
eventSource.onmessage = function(event) {
    console.log('New event from server:', event.data);
};
```

### （7）并发测压

jmeter的使用

## 2.订单过程

### （1）订单状态流程图

![image-20240502133339034](D:/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE/%E7%BD%91%E7%BA%A6%E8%BD%A6/image/image-20240502133339034.png)

## 3.订单取消

对于网约车平台的取消订单业务，设计一个适当的逻辑来处理基于订单状态的不同情况是非常重要的，尤其是在涉及费用扣除和司机赔偿的情况。

取消政策应该基于订单的当前状态，具体政策可能包括：
- **免费取消期**：例如，乘客在司机接单后的5分钟内可以免费取消。
- **取消费**：如果司机已经在路上或已到达乘车点，取消可能会收取费用，以补偿司机的时间和燃油成本。

在系统中实现取消订单的逻辑时，可以按以下步骤进行：
- **检查订单状态**：查询当前订单的状态。
- **应用取消政策**：根据订单的状态应用相应的取消政策。
  - 如果司机**未到达乘车点**，根据距离乘车点的远近可能收取小额取消费或不收费。
  - 如果司机**已到达乘车点**，根据政策收取相应的取消费。
- **通知相关方**：更新订单状态为“已取消”，并通知司机和乘客订单已取消，包括任何相关的费用信息。

# 七、支付系统

## （1）支付宝沙箱环境

[快速接入 - 支付宝文档中心 (alipay.com)](https://opendocs.alipay.com/common/02kkv7)

## （2）外网穿透

# 八、进阶

## 1.Maven架构调整

1. **解除循环依赖**：
   - `internal-common` 模块原本继承自 `online-taxi-public` 父项目，同时父项目也将 `internal-common` 作为依赖。这种设计容易导致依赖解析的复杂性和版本管理上的混乱，因此需要调整。
   
2. **使用 `internal-common` 作为第二方库**：
   - 考虑将 `internal-common` 模块独立出来，作为一个第二方库进行管理。这意味着 `internal-common` 将不再直接继承自 `online-taxi-public`，而是作为一个独立的库，供其他服务或模块按需引用。
   - 这样做不仅清晰了模块间的关系，还有助于库的版本管理和复用。

3. **移除父项目中的 `internal-common` 依赖**：
   - 在 `online-taxi-public` 的父项目的依赖管理中移除对 `internal-common` 的直接依赖，避免潜在的冲突和版本问题。
   - 任何需要使用 `internal-common` 的项目都应明确地添加对它的依赖，这样可以更好地控制依赖的版本和配置。

## 2.Spring Validation

**Spring Validation** 是 Spring 框架提供的一个强大的==数据验证==机制，它与 Spring 的数据绑定紧密集成，允许开发者方便地对从客户端传入的数据进行验证。Spring Validation 主要用于==确保应用程序接收到的数据满足业务规则==，从而避免潜在的错误或安全问题。

### （1）核心特性

1. **支持 JSR-303/JSR-349**：Spring 支持通过==注解==（如 `@NotNull`, `@Min`, `@Max` 等）进行声明式验证，这些注解基于 Bean Validation 规范（JSR-303 和 JSR-349）。

2. **可扩展**：除了使用标准的验证注解外，Spring 还允许开发者==自定义验证逻辑==。

### （2）注解声明式验证

在Java中，注解声明式验证主要依赖于Bean Validation API（JSR 303和JSR 349），通过这个框架，开发者可以使用一系列内置的注解来声明字段、方法参数或类的约束。这种方法使得代码更加简洁、清晰，并易于维护，因为它把验证逻辑从业务逻辑中分离出来。

#### 常用的内置验证注解：

1. **@NotNull** - 确保字段的值不为null。
2. **@NotEmpty** - 确保字段的值不为空，适用于字符串、集合、Map或数组。
3. **@NotBlank** - 确保字符串非null且至少包含一个非空白字符。
4. **@Email** - 确保字段的值是一个格式正确的电子邮件地址。
5. **@Size(min=, max=)** - 确保字符串、集合、数组或Map的大小在指定的范围内。
6. **@Min(value)** - 确保数字字段的值不小于指定的最小值。
7. **@Max(value)** - 确保数字字段的值不大于指定的最大值。
8. **@Positive** - 确保数字字段的值为正数。
9. **@PositiveOrZero** - 确保数字字段的值为正数或零。
10. **@Negative** - 确保数字字段的值为负数。
11. **@NegativeOrZero** - 确保数字字段的值为负数或零。
12. **@Digits(integer=, fraction=)** - 确保数字的值具有不超过`integer`位整数和不超过`fraction`位小数。
13. **@DecimalMin(value)** - 确保数字字段的值至少为指定的最小值，可以是小数。
14. **@DecimalMax(value)** - 确保数字字段的值最多为指定的最大值，可以是小数。
15. **@Pattern(regexp)** - 确保字符串字段的值匹配指定的正则表达式。

#### 高级验证注解：

1. **@Valid** - 用于级联验证，标注在对象或对象集合上，指示验证引擎也应验证此对象的内部属性。
2. **@AssertTrue** / **@AssertFalse** - 确保布尔字段的值为true或false。
3. **@Past** / **@PastOrPresent** - 确保日期或时间值在当前时间之前或包括当前时间。
4. **@Future** / **@FutureOrPresent** - 确保日期或时间值在当前时间之后或包括当前时间。

### （3）自定义验证

`ConstraintValidator` 是 Java Bean Validation API (JSR 303) 的一部分，它是一个接口，用于定义自定义约束验证逻辑。开发者可以实现这个接口来创建自定义的验证注解，这些注解可以用于验证 Java Bean 的字段或属性是否符合特定的业务规则。通过使用 `ConstraintValidator`，你可以扩展标准的验证框架，使其包含非标准的验证逻辑。

#### 基本结构和用法

`ConstraintValidator` 接口定义了两个主要的方法：`initialize` 和 `isValid`。

1. **initialize**:这个方法在约束验证器实例化时调用，用于传递任何状态或预配置到验证器。通过这个方法，你可以从注解本身获取==配置并初始化验证器==。
   
2. **isValid**:这个方法包含实际的==验证逻辑==，用于检查给定的值是否满足约束条件。它接收两个参数：一个是要验证的字段值，另一个是 `ConstraintValidatorContext`，后者提供了一种方式来报告验证失败。

#### 创建一个自定义验证器

下面是创建一个简单的自定义验证器的步骤，以检验字符串是否包含特定的子字符串作为例子：

##### 定义一个注解

在Java注解中，`default` 关键字用于定义注解属性的默认值。当使用该注解时，如果没有显式为特定属性指定值，那么就会自动使用定义的默认值。这使得注解的使用更加灵活和方便，因为用户可以只设置他们关心的属性，而其余属性则使用安全的默认配置。

```java
@Constraint(validatedBy = ContainsSubstringValidator.class)
@Target({ ElementType.METHOD, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface ContainsSubstring {
    String message() default "must contain the specified substring";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    String substring();
}
```

#####  实现 `ConstraintValidator` 接口

```java
public class ContainsSubstringValidator implements ConstraintValidator<ContainsSubstring, String> {
    private String substring;

    @Override
    public void initialize(ContainsSubstring constraintAnnotation) {
        this.substring = constraintAnnotation.substring();
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // null values are valid
        }
        return value.contains(substring);
    }
}
```

#### 使用自定义验证器

一旦你的自定义验证器定义好了，你就可以像使用任何其他的 Bean Validation 注解一样使用它：

```java
public class SomeEntity {
    @ContainsSubstring(substring = "important")
    private String dataField;
}
```

在这个例子中，`dataField` 必须包含子字符串 "important"，才被视为有效。

### （4）项目结构的调整

在微服务架构中，项目结构的调整是至关重要的，特别是涉及到数据验证的场景。传递的对象需要进行精细化管理以适应不同接口的验证需求。因此，相较于之前在`internal-common`公共类中统一处理，现在必须将这些对象分散到各个微服务项目中。进一步地，某些特定的微服务项目可能还需对这些对象进行更进一步的细分，以确保验证逻辑的精确性和效率。这种方法不仅增强了服务的自治性，也提高了系统的可维护性和可扩展性。

## 3.司机抢单（预约）

### （1）分布式锁问题

在单体应用中，可以使用 JVM 内置锁（如 `synchronized` 和 `ReentrantLock`）来控制线程对共享资源的访问。这些锁可以确保在同一时刻只有一个线程能够执行临界区的代码，从而保证了数据的一致性。

在分布式系统或微服务架构中，单体应用的锁机制不再适用，因为多个服务实例可能运行在不同的服务器或进程上。此时，可以使用基于 **Redis** 或 **ZooKeeper** 的分布式锁。

#### Redis 锁
- **基本实现**：使用 `SETNX` 命令（SET if Not eXists），这个命令只在键不存在时设置键值。锁的释放通过删除键来实现。
- **过期时间**：为了防止锁永久占用导致死锁，可以设置锁键的过期时间。Redis 的 `SET` 命令与 `EXPIRE` 选项结合使用可以实现这一点。
- **高可用性**：使用 Redis 哨兵模式、主从复制、集群来提高锁服务的可用性和容错性。

#### Redisson
- **框架支持**：Redisson 提供了一套在 Java 中使用 Redis 分布式锁的高级接口。它处理了锁的获取、自动续租、释放等复杂性，是实现分布式锁的推荐方法。

#### 红锁（RedLock）
- **算法描述**：在 Redis 集群中，红锁算法通过多个独立的 Redis 节点来获取和释放锁，以增加锁操作的可靠性。这种方法在部分节点不可达时仍能保持锁的有效性。

### （2）分布式事务问题

在微服务架构中，处理跨多个服务的数据库事务尤为复杂。传统的事务管理方法（如 XA 协议）可能过于重，并且在性能和扩展性方面有限制。

#### Seata
- **解决方案**：Seata 是一个开源的分布式事务解决方案，它通过 AT、TCC、SAGA 和 XA 模式支持不同的事务需求。Seata 管理分布式事务的生命周期，包括分支注册、状态报告和协调各个服务的提交或回滚。





























