# 一、ConcurrentHashMap

`ConcurrentHashMap` 是Java并发包中的核心组件之一，==适用于需要高并发且线程安全的键值存储的场景==。它通过使用先进的同步技术（如CAS和synchronized），以及在内部数据结构上的优化（链表和红黑树），提供了高效的并发性能。对于涉及多线程修改共享数据的场景，`ConcurrentHashMap` 提供了比 `HashMap` 更好的选择。

## （1）使用场景

- **多线程环境**：当多个线程可能同时读写同一个 `key-value` 结构时，`ConcurrentHashMap` 是一个理想的选择，因为它提供了线程安全性而不牺牲太多的性能。它通过分段锁（在较新的Java版本中是通过CAS操作和synchronized语句块）来减少锁竞争，从而提高效率。
  
- **单线程环境**：在单线程环境或方法局部变量中，使用 `HashMap` 可能更适合，因为它避免了线程同步带来的额外开销。

## （2）存储结构

`ConcurrentHashMap` 的内部实现是基于 ==**数组**==（Segment数组，在JDK 1.7及之前版本）和 **==链表==**，以及 ==**红黑树**==在JDK 1.8及之后的版本）。这种结构帮助它在保持高并发性的同时，也保持了良好的读写性能：

1. **数组**：基础结构是一个数组，每个数组元素本质上是一个桶（bucket）。随着元素的增加，这些桶可能转换成链表或红黑树来存储多个元素。

2. **链表**：在冲突发生时，多个键值对会以链表的形式存储在同一个桶中。在JDK 1.8之前，`ConcurrentHashMap` 使用Segment（类似于锁的一种优化，可以看作是锁的数组）来分割数据段，每个Segment管理桶的一部分，并且每个Segment独立锁定，从而减少线程间的竞争。

3. **红黑树**：在JDK 1.8及以后，为了进一步优化性能，==在链表长度超过一定阈值（默认为8）时，并且数组长度大于64==,链表将转换为红黑树，这有助于降低查找时间复杂度。

## （3）工作原理

- **==锁分离技术==**：通过对不同部分的数据结构加锁（JDK 1.8之前是Segment，之后是桶或节点），`ConcurrentHashMap` 允许多个更新操作并发进行，只要它们访问的是不同的桶。

- **==非阻塞的读操作==**：读操作通常不需要加锁，因为它们只访问不变的哈希表条目。这使得读操作非常快，而写操作通过锁和CAS来保证安全性和原子性。

# 二、ConcurrentHashMap的写入（put）数据流程

> **性能优化**：`ConcurrentHashMap`的设计旨在通过减少锁的使用范围（只锁定数组的某一段，而不是全局锁）和使用非阻塞算法（如CAS），来提高并发性能。
>
> **线程安全**：所有的写入操作都是线程安全的，确保在多线程环境下，数据的一致性和完整性。

## 1. **散列运算与索引确定**
- 首先，`ConcurrentHashMap`将对key进行==散列运算==，计算出key的`hashCode`，然后进一步处理这个hash值以减少碰撞，并确定数组中的==索引==位置。

## 2. **数组初始化检查**
- `ConcurrentHashMap`使用==懒加载策略初始化==其内部数组。如果数组尚未初始化（即首次插入数据），则执行初始化流程。

## 3. **确定插入位置并处理碰撞**
- 基于hash值，定位到数组的具体索引位置。
  - **如果该位置为空**：使用CAS操作尝试将新节点（Node对象）插入该位置。如果CAS操作成功，则插入操作完成；如果CAS失败（说明其他线程已经成功插入了新节点），则继续循环尝试。
  - **如果该位置已被占用**：进一步检查这个位置的头节点：
    - **==扩容检测==**：如果头节点的hash值指示当前正在进行扩容（MOVED状态），则当前线程将参与协助扩容过程，完成后重新尝试插入。
    - **==锁定头节点==**：如果没有正在进行的扩容，对头节点进行加锁（synchronized），确保以下操作的原子性。

## 4. **处理链表与红黑树**
- 在锁定的情况下，根据节点的状态进行不同的处理：
  - **链表操作**：如果当前结构是链表，新节点将被添加到链表的末端。如果链表长度达到阈值（通常是8），并且数组长度至少为64，将触发链表到红黑树的转换。
  - **红黑树操作**：如果当前结构是红黑树，将节点插入到红黑树中。

## 5. **更新计数器**
- 使用`LongAdder`进行线程安全的计数操作，更新`ConcurrentHashMap`中的元素总数。

## 6. **结束操作**
- 释放所有获取的锁，完成整个插入操作。

# 三、CHM扩容流程&协助扩容

## 1.扩容触发条件
扩容通常是由于当前元素的数量超过了阈值（负载因子与当前数组容量的乘积）或因插入操作而导致某个桶过长（如链表长度超过某个阈值）。

## 2.ConcurrentHashMap 扩容流程详解

1. **检测并初始化扩容**：
   - 扩容操作是多线程触发的。第一个到达的线程负责进行初始化工作，这包括设置 `sizeCtl` 的值为小于 -1 的特定值，从而标记扩容开始，并初始化一个新的数组，其长度为原数组的两倍。此后到达的其他线程在发现 `sizeCtl` 小于 -1 时，通过对 `sizeCtl` 执行加 1 操作来表明它们参与扩容，这个过程通过 CAS 操作保证原子性。

2. **迁移数据**：
   - 在扩容过程中，旧数组中的数据需要被重新散列到新数组。这要求重新计算每个元素在新数组中的位置，这个位置可能与在旧数组中的位置不同。

3. **协助扩容**：
   - 当其他线程检测到 `sizeCtl` 表明扩容正在进行时，它们会加入到扩容任务中，帮助进行数据的迁移。线程通过领取指定范围的数据迁移任务来共同完成这一过程。

4. **任务分配和同步**：
   - 每个参与扩容的线程会被分配一定范围的桶来处理。这些任务是通过计算固定的步长和进行任务分配来实现的。在迁移具体桶的数据时，线程会对其加锁，确保数据迁移的安全性和原子性。如果遇到已标记为MOVED（hash = -1）的索引位置，线程将不进行操作，因为这表示该位置的数据已被处理。

5. **处理不同数据结构**：
   - 对于存储为链表的桶，进行直接的链表迁移。
   - 对于存储为红黑树的桶，迁移操作利用红黑树内部的双向链表进行，这有助于简化红黑树的重建和数据迁移过程。

6. **迁移完成的清理工作**：
   - 数据迁移完成后，通常是最后一个完成迁移任务的线程负责进行最终的清理工作。这包括检查所有桶确保无遗漏，更新 `sizeCtl` 的值以标志扩容操作的结束。

这种扩容机制不仅确保了 `ConcurrentHashMap` 的高并发性能，还能够在运行时动态调整容量，以适应不断变化的负载需求。通过细致的任务协调和精确的同步控制，`ConcurrentHashMap` 能有效管理并发数据操作，维持其作为高性能并发容器的地位。

# 四、CHM查询数据流程

`ConcurrentHashMap` 的设计确保查询操作尽可能快速且非阻塞性，这是通过以下几种情况的处理实现的：

1. **数据直接位于数组节点**：
   - 如果目标数据直接存储在数组的节点上，查询将非常迅速。这是最理想的情况，因为直接访问内存地址通常非常快。

2. **数据存储在链表中**：
   - 如果节点后跟着一个链表，查询操作会沿链表逐节点查找直到找到匹配的键。尽管这需要多步访问，但由于链表结构简单，操作仍然相对快速。

3. **节点处于MOVED状态**：
   - MOVED状态表明当前节点的数据已经迁移到了新的扩容数组中。在这种情况下，查询操作将直接==跳转到新数组继续进行==，确保查询能够反映最新的数据状态。

4. **节点处于RESERVED状态**：
   - RESERVED状态意味着节点位置正被占用，但实际的值可能还在计算中。查询在这种情况下==会返回 `null`==，表明数据暂时不可达。

5. **数据存储在红黑树中**：
   - 如果节点是一个红黑树，查询操作将根据树的性质进行。如果有线程正在对红黑树进行平衡（写操作），查询将通过备份的==双向链表==进行，以避免等待写操作完成。
   - 如果没有写线程正在操作，查询将直接在红黑树中进行，利用树结构的高效查找特性。

 `lockState` 变量用于协调红黑树中的读写操作，保证数据的一致性和查询的非阻塞性：

- **lockState == 1**：表示有写线程正在对红黑树进行平衡操作。
- **lockState == 2**：表示写线程正在等待进行平衡操作。
- **lockState >= 4**：表示有读线程正在访问红黑树中的数据。每个读线程在进入时都会将 `lockState` 增加 4，读操作完成后相应地减少 4。

这种精细的锁状态管理使得 `ConcurrentHashMap` 能够在维护高并发性的同时，提供快速的数据访问能力，特别是在多线程环境下。这些特性使 `ConcurrentHashMap` 成为Java中处理高并发数据结构的首选实现。
