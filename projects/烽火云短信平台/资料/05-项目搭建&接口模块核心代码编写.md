# **搭建项目**

## 一、搭建父工程

父工程中主要的内容就是管理一般版本：

* Spring Boot
* Spring Cloud
* Spring Cloud Alibaba

父工程是聚合工程

```
<packaging>pom</packaging>
```

管理三个版本

* SpringBoot

  ```
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.3.12.RELEASE</version>
      <relativePath />
  </parent>
  ```
* SpringCloud&SpringCloudAlibaba

  ```
  <properties>
      <spring.cloud-version>Hoxton.SR12</spring.cloud-version>
      <spring.cloud.alibaba-version>2.2.6.RELEASE</spring.cloud.alibaba-version>
  </properties>
  <dependencyManagement>
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-dependencies</artifactId>
              <version>${spring.cloud-version}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
          <dependency>
              <groupId>com.alibaba.cloud</groupId>
              <artifactId>spring-cloud-alibaba-dependencies</artifactId>
              <version>${spring.cloud.alibaba-version}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
  </dependencyManagement>
  ```

## 二、搭建接口模块

**beacon-api**

### 2.1 导入的依赖内容

```xml
<dependencies>
    <!--        web项目-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--        注册到nacos-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--        nacos拉取配置-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--        openFeign-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
    <!--        RabbitMQ-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
</dependencies>
```

### 2.2 编写启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ApiStarterApp {

    public static void main(String[] args) {
        SpringApplication.run(ApiStarterApp.class,args);
    }
}
```

### 2.3 编写配置文件（本地）

```yml
# 服务名称
spring:
  application:
    name: beacon-api
# 多环境
  profiles:
    active: dev
# nacos注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 114.116.226.76:8848
      # nacos配置中心地址:
      config:
        server-addr: 114.116.226.76:8848
        file-extension: yml
        # beacon-api-dev.yml
```

### 2.4 编写配置文件（Nacos）

```yml
# 端口号
server:
  port: 10001

spring: 
# rabbitMQ连接信息
  rabbitmq:
    host: 114.116.226.76
    port: 5672
    username: root
    password: ZhengJinWei123!
    virtual-host: /  
```

## 三、搭建缓存模块

**（看到接口模块的2.3.2再来）**

### 3.1 导入依赖

```
<dependencies>
    <!--        web项目-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--        nacos注册中心-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--        nacos的配置中心-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--        data系列的redis依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
</dependencies>
```

### 3.2 编写启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class CacheStarterApp {

    public static void main(String[] args) {
        SpringApplication.run(CacheStarterApp.class,args);
    }

}
```

### 3.3 配置文件（本地+Nacos）

本地配置：

```java
# 服务名称
spring:
  application:
    name: beacon-cache
  # 多环境
  profiles:
    active: dev
  # nacos注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 114.116.226.76:8848
      # nacos配置中心地址:
      config:
        server-addr: 114.116.226.76:8848
        file-extension: yml
        # beacon-cache-dev.yml
```

nacos配置：

```yml
spring:
  redis:
    # Redis链接信息
    host: 114.116.226.76
    port: 6379
    password: ZhengJinWei123!

# 端口号  
server:
  port: 10002
```

### 3.4 编写配置类

因为默认使用data-redis提供的RedisTemplate对象时，针对key和value的序列化方式都是byte[]，这种方式在图形化界面上的查看不太优化，将key做String的序列化，将Value做JSON的序列化。

同时也是为了让RedisTemplate支持JDK8的日期格式

```java
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * 设置RedisTemplate的序列化方式
 * @author zjw
 * @description
 */
@Configuration
public class RedisConfig {

    @Bean
    public <T> RedisTemplate<String,T> redisTemplate(RedisConnectionFactory factory,RedisSerializer<Object> redisSerializer){
        //1. 构建RedisTemplate对象
        RedisTemplate<String,T> redisTemplate = new RedisTemplate<>();

        //2. 设置RedisConnectionFactory到RedisTemplate
        redisTemplate.setConnectionFactory(factory);

        //3. 设置Redis的key的序列化方式
        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setHashKeySerializer(RedisSerializer.string());

        //4. 设置Redis的value的序列化方式  Date
        redisTemplate.setValueSerializer(redisSerializer);
        redisTemplate.setHashValueSerializer(redisSerializer);

        //5. 保证生效
        redisTemplate.afterPropertiesSet();

        //6. 返回RedisTemplate
        return redisTemplate;
    }

    @Bean
    public RedisSerializer<Object> redisSerializer(){
        //1. 构建Jackson的ObjectMapper
        ObjectMapper objectMapper = new ObjectMapper();

        //2. 设置JDK8日期格式的支持
        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        Module timeModule = new JavaTimeModule()
                .addDeserializer(LocalDate.class,new LocalDateDeserializer(dateFormatter))
                .addDeserializer(LocalDateTime.class,new LocalDateTimeDeserializer(dateTimeFormatter))
                .addSerializer(LocalDate.class,new LocalDateSerializer(dateFormatter))
                .addSerializer(LocalDateTime.class,new LocalDateTimeSerializer(dateTimeFormatter));
        objectMapper.registerModule(timeModule);

        //3. 构建Jackson2JsonRedisSerializer
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        //4. 设置好对JDK8日期的支持
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        //5. 返回设置好的Jackson2JsonRedisSerializer
        return jackson2JsonRedisSerializer;
    }


}
```

### 3.5 测试配置效果

构建一个TestController测试功能

准备两个接口

```java
/**
 * @author zjw
 * @description
 */
@RestController
public class TestController {

    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    // 写测试   hash结构
    @PostMapping("/test/set/{key}")
    public String set(@PathVariable String key, @RequestBody Map map){
        redisTemplate.opsForHash().putAll(key,map);
        return "ok";
    }
    // 读测试
    @GetMapping("/test/get/{key}")
    public Map get(@PathVariable String key){
        Map<Object, Object> result = redisTemplate.opsForHash().entries(key);
        return result;
    }
}
```

测试内容：

* 写入操作![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/a3e6bc4dab5d4d2783c2247475574316.png)![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/c57de1ecf5be4a88b806b792f13e85d3.png)
* 读取操作![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/42754d3df7c94c70b462f1b7e428331e.png)

### 3.6 缓存模块的问题

#### 3.6.1 问题一：

直接使用RedisTemplate对象，及基于他的API与Redis服务交互时，方法的实用性比较差。

方法名和Redis中的命令差别很大。

#### 3.6.2 问题二：

基于Java客户端与Redis交互时，很多使用会采用一个注解，@Cacheable。

如果当前缓存模块需要基于@Cacheable去与Redis交互时，需要再次配置CacheManager，以及KeyGenerator等配置信息

其次如果还需要使用Redis做分布式锁，一般用分布式锁的客户端大多是采用Redisson，Redisson内部的watchDog以及一些锁重入等操作时，封装的比较完善。需要再次配置一些基于Redisson的信息。

可以基于马士兵教育内部提供的  **飞马框架**  ，去快速搭建一个基础内容，内部对大部分使用的功能都做了封装。

### 3.7 飞马框架

飞马框架是咱们马士兵内部的严选商城使用的一款自研框架。在框里面针对很多组件都做了另一层封装和starter内容编写。如果需要使用某一个组件的话，可以直接使用飞马框架内部的启动器。

登录：https://git.mashibing.com/

使用手机号验证码的方式去登录即可。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/168174c4b1ec4a43ac9cef1ee01d4164.png)

直接点击蓝色区域的严选分布式电商项目![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/c4db1a24c3644de08efef1eb600e3119.png)

直接使用git，将整个项目clone下来

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/760de1c18f5c4b7cafb46bdccd016392.png)

会需要输入用户名和密码，需要在首页的头像位置获取使用的git用户名和密码![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/28f78dcf7b0547f796cd763cb4002d1f.png)

可以将严选商城项目正常的clone下来。

下载完毕后，推荐使用IDEA打开一下，这样Maven会根据pom.xml下载一些依赖。

因为后期需要执行install将所有的组件安装的本地仓库，然后再做二次修改。

比如刚刚查看的Cache模块，内部很贴心的做了三件事情：

* 配置好了RedisTemplate的序列化操作
* 配置好了Redisson的一些基本配置
* 声明了RedisClient的操作客户端

### 3.8 使用飞马框架

因为飞马框架不是开源的，需要优先将飞马框架的内容install安装到本地仓库。

找到yanxuan项目的地址，然后在yanxuan项目地址打开cmd窗口，直接输入

```
mvn clean install -DskipTests
```

飞马框架安装成功后，需要在父工程中指定好飞马框![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/cfd0ab38be2f4439bde938778b2b7e55.png)架的版本

在父工程中，直接声明

```xml
<properties>
    <spring.cloud-version>Hoxton.SR12</spring.cloud-version>
    <spring.cloud.alibaba-version>2.2.6.RELEASE</spring.cloud.alibaba-version>
    <horse-version>1.0.0</horse-version>
</properties>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring.cloud-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>${spring.cloud.alibaba-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>com.msb.cloud</groupId>
            <artifactId>horse-framework-starters</artifactId>
            <version>${horse-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

之前编写过的RedisTemplate的Config配置文件，可以直接删掉了。

同时，可以基于飞马框架提供的RedisClient直接与Redis交互，代码更简洁。

### 3.9 飞马框架更新问题

因为飞马框架一致在更新，导致之前在玩项目时，使用飞马框架的方法对应不上，这里咱们需要根据飞马框架提供的功能做出略微的调整。

所以大家在使用听短信平台课程时，如果发现我在Cache模块编写的方法，你那没有，记住这个视频。

因为我当时使用的飞马框架版本和现在不一样，而且现在飞马框架也一直在更新。

我会将我当前使用的飞马框架的源码，扔到课程资料里，大家根据这个走会更好一些。

# 接口模块

## 一、实现校验链

接口模块核心的事情就是对当前的请求参数和一些信息做校验。

为了保证校验的这些方式，可以做到动态可插拔。而且希望后期的扩展性可以更好。

直接查看了MyBatis二级缓存的源码，发现二级缓存整体的套路就是策略模式 + 责任链模式。

咱们也可以向上声明一个接口，内部提供好校验方法。

然后在执行校验时，以责任链的形式一个一个去校验就ok了。

基于Nacos提供的一个配置的动态刷新去实现，指定好整体校验链，需要改变时，只需要去修改Nacos中的配置文件即可。

额外的导入两个依赖

```xml
<!--        记录日志等工具-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
<!--        测试的依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
</dependency>
```

### 1.1 准备校验的父接口&实现类

父接口

```java
/**
 *
 * @author zjw
 * @description 做策略模式的父接口
 */
public interface CheckFilter {

    /**
     * 校验！！！！
     * @param obj
     */
    void check(Object obj);

}
```

准备校验的实现类

```java
/**
 * @author zjw
 * @description  校验客户的apikey是否合法
 */
@Service(value = "apikey")
@Slf4j
public class ApiKeyCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验apikey】   校验ing…………");
    }
}

/**
 * @author zjw
 * @description  校验请求的ip地址是否是白名单
 */
@Service(value = "ip")
@Slf4j
public class IPCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验ip】   校验ing…………");
    }
}

/**
 * @author zjw
 * @description  校验短信的签名
 */
@Service(value = "sign")
@Slf4j
public class SignCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验签名】   校验ing…………");
    }
}

/**
 * @author zjw
 * @description  校验短信的模板
 */
@Service(value = "template")
@Slf4j
public class TemplateCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验模板】   校验ing…………");
    }
}

/**
 * @author zjw
 * @description  校验手机号的格式合法性
 */
@Service(value = "mobile")
@Slf4j
public class MobileCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验手机号】   校验ing…………");
    }
}
/**
 * @author zjw
 * @description  校验客户剩余的金额是否充足
 */
@Service(value = "fee")
@Slf4j
public class FeeCheckFilter implements CheckFilter {


    @Override
    public void check(Object obj) {
        log.info("【接口模块-校验客户余额】   校验ing…………");
    }
}

```

### 1.2 准备上下文对象

需要执行整个校验链时，直接获取到Context上下文对象即可

```java
/**
 * @author zjw
 * @description  策略模式的上下文对象
 */
@Component
@RefreshScope
public class CheckFilterContext {

    // Spring的IOC会将对象全部都放到Map集合中
    // 基于4.x中Spring提供的反省注解，基于Map只拿到需要的类型对象即可
    @Autowired
    private Map<String,CheckFilter> checkFiltersMap;

    // 基于Nacos获取到执行的顺序和需要执行的校验对象
    @Value("${filters:apikey,ip,sign,template}")
    private String filters;

    /**
     * 当前check方法用于管理校验链的顺序
     */
    public void check(Object obj){
        //1. 将获取到filters基于,做切分
        String[] filterArray = filters.split(",");
        //2. 遍历数组即可
        for (String filter : filterArray) {
            CheckFilter checkFilter = checkFiltersMap.get(filter);
            checkFilter.check(obj);
        }
    }
}
```

### 1.3 Nacos准备顺序&测试

Nacos配置文件中准备内容

```yml
# 校验策略的执行内容和顺序 apikey,ip,sign,template,mobile,fee
filters: apikey,ip,sign,template,mobile,fee
```

基本功能测试：

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class CheckFilterContextTest {

    @Autowired
    private CheckFilterContext checkFilterContext;

    @org.junit.Test
    public void check() {
        Object obj = new Object();
        checkFilterContext.check(obj);
    }
}
```

测试动态改变的效果：

```java
/**
 * @author zjw
 * @description  测试校验链的效果
 */
@Controller
public class TestController {

    @Autowired
    private CheckFilterContext checkFilterContext;

    @GetMapping("/api/test")
    public void test(){
        System.out.println("====================================");
        checkFilterContext.check(new Object());
    }
}
```

## 二、单条短信发送接口

### 2.1 映射请求&接收参数&设置响应结果

```java
@RestController
@RequestMapping("/sms")
public class SmsController {


    @PostMapping(value = "/single_send",produces = "application/json;charset=utf-8")
    public ResultVO singleSend(@RequestBody SingleSendForm singleSendForm){
        return R.ok();
    }
}
```

提供参数映射的POJO类，以及返回结果的ResultVO，提供的R工具类

**SingleSendForm**

```java
/**
 * @author zjw
 * @description
 */
@Data
public class SingleSendForm {

    /** 客户的apikey */
    private String apikey;

    /** 手机号 */
    private String mobile;

    /** 短信内容 */
    private String text;

    /** 客户业务内的uid */
    private String uid;

    /** 0-验证码短信 1-通知类短信 2-营销类短信 */
    private int state;

}
```

**ResultVO**

```java
/**
 * @author zjw
 * @description
 */
@Data
public class ResultVO {

    private Integer code;

    private String msg;

    private Integer count;

    private Long fee;

    private String uid;

    private String sid;
}
```

**R**

```java
public class R {

    public static ResultVO ok(){
        ResultVO r = new ResultVO();
        r.setCode(0);
        r.setMsg("接收成功");
        return r;
    }

}
```

### 2.2 参数校验

因为采用的SpringBoot的2.3.x的版本，在这个版本中默认已经不去内置JSR303校验规则。如果需要使用，需要单独的导入一个依赖：

```xml
<!--        参数校验-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

在声明的Form对象中，追加JSR303的注解

```
@NotNull：判断不允许为null
@NotBlank：判断不允许为null，并且字符串不允许为空串
@Range：给整型指定一个范围。
```

为了更好的管理code码以及对应的信息，声明一个枚举去管理

```java
/**
 * 一些响应信息中code和msg的对应
 * @author zjw
 * @description
 */
@Getter
public enum SmsCodeEnum {
    PARAMETER_ERROR(-10,"参数不合法！");

    private Integer code;
    private String msg;

    SmsCodeEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }
}
```

在Controller的接口上注解注解即可

```java
@PostMapping(value = "/single_send",produces = "application/json;charset=utf-8")
public ResultVO singleSend(@RequestBody @Validated SingleSendForm singleSendForm, BindingResult bindingResult){
    //1. 校验参数
    if (bindingResult.hasErrors()){
        String msg = bindingResult.getFieldError().getDefaultMessage();
        log.info("【接口模块-单条短信Controller】 参数不合法 msg = {}",msg);
        return R.error(SmsCodeEnum.PARAMETER_ERROR.getCode(),msg);
    }
    return R.ok();
}
```

### 2.3 鉴权前准备

#### 2.3.1 准备StandardSubmit

因为在接口模块只接收到了客户发送过来的基本信息，还需要去封装很多内容，比如短信是哪个客户发送的，费用是多少，选择的哪个通道等等信息，都需要封装出来。而且这个信息要从头到尾贯穿到运营商。后面在记录短信发送信息到Elasticsearch时，也需要使用当前的Submit作为构建Elasticsearch索引的主要模板。

为了保证整体内容采用同一个POJO类，构建了一个beacon-common模块，用于专门封装这种公共的信息。

```java
/**
 * 在接口模块-策略模块-短信网关模块需要做校验和封装的POJO类对象
 *
 * @author zjw
 * @description
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class StandardSubmit {

    /**
     * 针对当前短信的唯一标识
     */
    private Long sequenceId;

    /**
     * 客户端ID
     */
    private Long clientId;

    /**
     * 客户端的ip白名单
     */
    private String ip;

    /**
     * 客户业务内的uid
     */
    private String uid;

    /**
     * 目标手机号
     */
    private String mobile;

    /**
     * 短信内容的签名
     */
    private String sign;

    /**
     * 短信内容
     */
    private String text;

    /**
     * 短信的发送时间
     */
    private LocalDateTime sendTime;

    /**
     * 当前短信的费用
     */
    private Long fee;

    /**
     * 目标手机号的运营商
     */
    private Integer operatorId;


    /**
     * 目标手机号的归属地区号  0451  0455
     */
    private Integer areaCode;

    /**
     * 目标手机号的归属地  哈尔滨，  绥化~
     */
    private String area;

    /**
     * 通道下发的源号码  106934985673485645
     */
    private String srcNumber;

    /**
     * 通道的id信息
     */
    private Long channelId;

    /**
     * 短信的发送状态， 0-等待ing，1-成功，2-失败
     */
    private int reportState;

    // 后续再做封装~~~~

}
```

#### 2.3.2 搭建缓存模块

发现要校验的各种内容，都需要通过数据库表查询到指定的信息再做校验。

但是查询数据库的效率必然不高。为了降低在短信平台侧校验的时长，需要在校验时，尽量使用缓存。

缓存的使用不推荐直接在模块内容基于 **RedisTemplate** 直接去调用Redis，这样会导致Redis一变，所有模块都会改变。会单独的声明一个模块，缓存模块去和Redis交互。也方便后去对缓存中间件做迭代更新。

详情见： **搭建项目-三、搭建缓存模块**

#### 2.3.3 获取客户端IP

##### 2.3.3.1 获取客户端IP的问题

获取请求的IP很简单，可以直接使用request.getRemoteAddr()直接获取

因为请求在转发到接口模块前，会经过大量的反向代理操作，从咱们流程图中可以看到，至少要经过Nginx以及网关模块后，请求才会转发到接口模块。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/7c221fcda49f435bbbab27b166d52c42.png)

准备一台虚拟机，在虚拟机上安装Linux，搭建Nginx

* 基于Docker搭建Nginx

  ```
  version: '3.1'
  services:
    nginx:
      image: nginx
      container_name: nginx
      ports:
        - 80:80
      volumes:
        - ./conf.d/:/etc/nginx/conf.d/
  ```
* 配置Nginx的conf文件

  ```
  server {
    listen 80;
    server_name localhost;
  
    location / {
      proxy_pass http://192.168.2.16:10001/;
    }
  }
  ```

配置Nginx的配置文件，让Windows请求发送到Linux上的Nginx，Nginx将请求转发到Windows上的Tomcat上

* postman发送请求到Linux的Nginx上![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/f476fbd737a3414688c7da290bb05f07.png)
* tomcat服务内部基于request.getRemoteAddr获取IP![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/3ea3d0057bfa4ca2ab762dbe6b1a872e.png)

##### 2.3.3.2 获取客户端真实IP地址

第一个方向，需要反向代理服务器可以携带真实的客户端IP地址，放在请求头中。

第二个方向，需要在服务器端基于代码获取时，考虑多种情况。

修改Nginx的配置，让Nginx可以携带客户端真实IP的地址

```json
server {
  listen 80;
  server_name localhost;

  location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass http://192.168.11.1:10001/;
  }
}
```

修改Java代码，基于请求头获取真实IP地址

```java
/**
 * 获取客户端真实的IP地址
 * @param req
 * @return
 */
private String getRealIP(HttpServletRequest req) {

    //0. 声明真实IP地址
    String  ip;

    //1. 基于x-forwarded-for请求头获取IP地址
    String ips = req.getHeader("x-forwarded-for");
    //  直接基于第一个,的位置，截取需要的IP地址
    if (StringUtils.isEmpty(ips) || "unknow".equalsIgnoreCase(ips)) {
        if(ips.contains(",")){
        	return ips.substring(0, ips.indexOf(","));
		}else{
 			return ips;
		}
    }

    // 2. 基于请求头获取IP地址，基于request请求头获取信息时，除了null和空串外，还有可能拿到unknow，
    ip = req.getHeader("x-real-ip");
    if (StringUtils.isEmpty(ip) || "unknow".equalsIgnoreCase(ip)){
        // x-real-ip没拿到，考虑一下其他的代理服务器
        //3.  Apache的服务器，请求头中携带真实IP的名称是 proxy-client-ip
        ip = req.getHeader("proxy-client-ip");
    }

    //4. 如果real没有拿到，判断apache是否拿到了。
    if (StringUtils.isEmpty(ip) || "unknow".equalsIgnoreCase(ip)){
        // 5. 如果Apache服务器没拿到，考虑一手WebLogic, wl-proxy-client-ip
        ip = req.getHeader("wl-proxy-client-ip");
    }

    //6. 判断WebLogic有木有拿到IP
    if (StringUtils.isEmpty(ip) || "unknow".equalsIgnoreCase(ip)){
        //7. 基于其他的代理服务器的方式获取请求头的IP地址
        ip = req.getHeader("http_client_ip");
    }
    //8. 如果上诉方式都获取不到，
    if (StringUtils.isEmpty(ip) || "unknow".equalsIgnoreCase(ip)){
        // 9. 基于传统方式获取IP
        ip = req.getRemoteAddr();
    }
    //10. 返回
    return ip;
}
```

##### 2.3.3.3 将请求头信息维护到Nacos

因为请求头信息和一些unknow都是写死在代码中的，不方便后期的维护

将可能涉及到请求头基于优先级顺序写在Nacos的配置文件中

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/9aea4f3489054442899842e518370253.png)

在代码中获取Nacos配置文件中的请求头信息，基于循环的方式获取真实IP地址

```java
/**
 * 客户端IP地址的请求头信息，多个用','隔开。
 */
@Value("${headers}")
private String headers;

/**
 * 基于请求头获取信息时，可能获取到的未知信息
 */
private final String UNKNOW = "unknow";

/**
 * 如果是当前请求头获取IP地址，需要截取到第一个','未知
 */
private final String X_FORWARDED_FOR = "x-forwarded-for";

/**
 * 获取客户端真实的IP地址
 * @param req
 * @return
 */
private String getRealIP(HttpServletRequest req) {
    //1. 声明返回的ip地址
    String ip;

    //2. 遍历请求头，并且通过req获取ip地址
    for (String header : headers.split(",")) {
        // 健壮性校验
        if (!StringUtils.isEmpty(header)) {
            // 基于req获取ip地址
            ip = req.getHeader(header);
            // 如果获取到的ip不为null，不为空串，并且不为unknow，就可以返回
            if (!StringUtils.isEmpty(ip) && !UNKNOW.equalsIgnoreCase(ip)) {
                // 判断请求头是否是x-forwarded-for
                if (X_FORWARDED_FOR.equalsIgnoreCase(header) && ip.indexOf(",") > 0) {
                    ip = ip.substring(0,ip.indexOf(","));
                }
                // 返回IP地址
                return ip;
            }
        }
    }

    //3. 如果请求头都没有获取到IP地址，直接基于传统的方式获取一个IP
    return req.getRemoteAddr();
}
```

#### 2.3.4 封装StandardSubmit&配置接口模块OpenFeign&准备缓存数据

##### 2.3.4.1 封装StandardSubmit

补全StandardSubmit中的一些属性：

* 获取到了客户端真实的IP地址
* 将请求携带的apiKey封装
* 短信的类型

将请求参数携带的5个属性以及基于req拿到的客户端IP地址封装到StandardSubmit中

```java
@PostMapping(value = "/single_send",produces = "application/json;charset=utf-8")
public ResultVO singleSend(@RequestBody @Validated SingleSendForm singleSendForm, BindingResult bindingResult, HttpServletRequest req){
    //1. 校验参数
    if (bindingResult.hasErrors()){
        String msg = bindingResult.getFieldError().getDefaultMessage();
        log.info("【接口模块-单条短信Controller】 参数不合法 msg = {}",msg);
        return R.error(SmsCodeEnum.PARAMETER_ERROR.getCode(),msg);
    }
    //=========================获取真实的IP地址=========================================
    String ip = this.getRealIP(req);

    //=========================构建StandardSubmit，各种封装校验=========================================
    StandardSubmit submit = new StandardSubmit();
    submit.setRealIP(ip);
    submit.setApikey(singleSendForm.getApikey());
    submit.setMobile(singleSendForm.getMobile());
    submit.setText(singleSendForm.getText());
    submit.setState(singleSendForm.getState());
    submit.setUid(singleSendForm.getUid());

    //=========================发送到MQ，交给策略模块处理=========================================
    return R.ok();
}
```

##### 2.3.4.2 配置OpenFeign

导入依赖：

```xml
<!--        为了访问缓存模块，需要配置OpenFeign-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

启动类添加注解：

```java
@EnableFeignClients
```

声明接口：

```java
@FeignClient(value = "beacon-cache")
public interface BeaconCacheClient {

}
```

##### 2.3.4.3 Redis存储写数据

给Redis准备一些缓存数据的存储方式

* 需要将客户信息、客户签名、客户模板、客户余额导入到Redis缓存
* 客户信息：采用hash结构

  * key：client_business:apikey
  * value：用户信息的json
* 客户签名： **采用set结构**

  * key：client_sign:clientId
  * value：对应客户签名的json
* 客户模板： **采用set结构**

  * key：client_template:signId
  * value：对应签名模板的json
* 客户余额：采用string接口

  * key：client_balance:clientId
  * value：客户余额

如果直接手动的将数据库的数据写入到Redis会出现一个问题：手动写入时，即便给value追加了双引号，但是在存储到redis时，不会保留双引号，再加上缓存模块，在针对value做序列化和反序列化时，会出现没有双引号，就反序列化失败的情况。

为了快速落地核心业务流程，基于代码的方式将测试数据同步到Redis中。

###### client_business同步

构建一个beacon-test作为同步数据的一个测试项目

需要导入依赖：

* 注册Nacos。
* 通过OpenFeign调用Cache
* 查询数据库

配置好各种信息：

* 启动类
  ```
  @SpringBootApplication
  @EnableDiscoveryClient
  @EnableFeignClients
  @MapperScan(basePackages = "com.mashibing.test.mapper")
  public class TestStarterApp {
  
      public static void main(String[] args) {
          SpringApplication.run(TestStarterApp.class,args);
      }
  }
  ```
* 配置文件
  ```
  # 服务名
  spring:
    application:
      name: beacon-test
    # nacos地址
    cloud:
      nacos:
        discovery:
          server-addr: 114.116.226.76:8848
    # datasource
    datasource:
      driver-class-name: org.gjt.mm.mysql.Driver
      url: jdbc:mysql://114.116.226.76:3306/beacon_cloud?characterEncoding=utf-8
      username: root
      password: ZhengJinWei123!
  # 端口号
  server:
    port: 20000
  
  # mybatis
  mybatis:
    configuration:
      map-underscore-to-camel-case: true
  ```
* 生成实体类信息：基于IDEA自带的POJOs脚本生成实体类，先凑合用
* 准备对应的Mapper接口：
  ```
  public interface ClientBusinessMapper {
  
      @Select("select * from client_business where id = #{id}")
      ClientBusiness findById(@Param("id") Long id);
  
  }
  ```
* 测试与数据连接
  ```
  @SpringBootTest
  @RunWith(SpringRunner.class)
  public class ClientBusinessMapperTest {
  
      @Autowired
      private ClientBusinessMapper mapper;


      @Test
      public void findById() {
          ClientBusiness cb = mapper.findById(1L);
          System.out.println(cb);
      }
  }
  ```

只同步一个客户信息需要的数据即可：

* 在beacon-test中准备OpenFeign调用Cache模板
  ```
  @FeignClient(value = "beacon-cache")
  public interface CacheClient {

      @PostMapping(value = "/cache/hmset/{key}")
      void hmset(@PathVariable(value = "key")String key, @RequestBody Map<String,Object> map);
    
      @PostMapping(value = "/cache/set/{key}")
      void set(@PathVariable(value = "key")String key, @RequestParam(value = "value")String value);

  }
  ```
* 在beacon-cache中提供接口
  ```
  @RestController
  @Slf4j
  public class CacheController {

      @Autowired
      private RedisClient redisClient;
    
      @PostMapping(value = "/cache/hmset/{key}")
      public void hmset(@PathVariable(value = "key")String key, @RequestBody Map<String,Object> map){
          log.info("【缓存模块】 hmset方法，存储key = {}，存储value = {}",key,map);
          redisClient.putMap(key,map);
      }
    
      @PostMapping(value = "/cache/set/{key}")
      public void set(@PathVariable(value = "key")String key, @RequestParam(value = "value")String value){
          log.info("【缓存模块】 set方法，存储key = {}，存储value = {}",key,value);
          redisClient.set(key,value);
      }
  }
  ```
* 在beacon-test编写测试将数据保存到Redis
  ```
  /*
   * 客户信息：采用hash结构
   * key：client_business:apikey
   * value：用户信息的json
      *
      */

    @Test
    public void findById() throws JsonProcessingException {
      ClientBusiness cb = mapper.findById(1L);
      ObjectMapper objectMapper = new ObjectMapper();
      Map map = objectMapper.readValue(objectMapper.writeValueAsString(cb), Map.class);
      cacheClient.hmset("client_business:" + cb.getApikey(),map);
    }
  ```
* 查看效果![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/2dfb4c52847e4da388dcd552f22f3a3b.png)

###### client_sign同步

因为一个客户会绑定多个签名，基于这种情况，将之前考虑的hash结构存储，更改为set结构存储

准备ClientSignMapper

```java
public interface ClientSignMapper {

    @Select("select * from client_sign where client_id = #{clientId}")
    List<ClientSign> findByClientId(@Param("clientId")Long clientId);

}
  ```

测试ClientSignMapper

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class ClientSignMapperTest {

    @Autowired
    private ClientSignMapper mapper;

    @Test
    public void findByClientId() {
        List<ClientSign> list = mapper.findByClientId(1L);
        for (ClientSign clientSign : list) {
            System.out.println(clientSign);
        }
    }
}
```

准备CacheClient中的sadd方法

```java
@FeignClient(value = "beacon-cache")
public interface CacheClient {
    // ....

    @PostMapping(value = "/cache/sadd/{key}")
    void sadd(@PathVariable(value = "key")String key, @RequestBody Map<String,Object>... maps);

}
```

准备Cache模块的sadd接口

```java
@RestController
@Slf4j
public class CacheController {

    @Autowired
    private RedisClient redisClient;

    // ....

    @PostMapping(value = "/cache/sadd/{key}")
    public void sadd(@PathVariable(value = "key")String key, @RequestBody Map<String,Object>... value){
        log.info("【缓存模块】 sadd方法，存储key = {}，存储value = {}", key, value);
        redisClient.sAdd(key,value);
    }

}
```

同步数据到Redis

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class ClientSignMapperTest {

    @Autowired
    private ClientSignMapper mapper;

    @Autowired
    private CacheClient cacheClient;

    @Test
    public void findByClientId() {
        List<ClientSign> list = mapper.findByClientId(1L);
        for (ClientSign clientSign : list) {
            System.out.println(clientSign);
        }

        ObjectMapper objectMapper = new ObjectMapper();
        List<Map> value = list.stream().map(cs -> {
            try {
                return objectMapper.readValue(objectMapper.writeValueAsString(cs), Map.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toList());

        cacheClient.sadd("client_sign:1",value.toArray(new Map[]{}));
    }
}
```

###### client_template 同步

依然是基于Set结构去存储对应签名下的模板信息

基于上面的数据同步，可以看到客户用两个签名，分别是id=15和id=24

现在为了完成核心业务，需要将id为15和24的签名对应的模板同步到Redis缓存

准备ClientTemplateMapper

```java
public interface ClientTemplateMapper {

    @Select("select * from client_template where sign_id = #{signId}")
    List<ClientTemplate> findBySignId(@Param("signId") Long signId);

}
```

测试查询数据库

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class ClientTemplateMapperTest {

    @Autowired
    private ClientTemplateMapper mapper;

    @Autowired
    private CacheClient cacheClient;

    @Test
    public void findBySignId() {
        List<ClientTemplate> ct1 = mapper.findBySignId(15L);
        List<ClientTemplate> ct2 = mapper.findBySignId(24L);
        for (ClientTemplate clientTemplate : ct1) {
            System.out.println(clientTemplate);
        }
        //  ct2在现有的库中没有数据
        System.out.println(ct2);
    }
}
```

将数据存储到Redis中

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class ClientTemplateMapperTest {

    @Autowired
    private ClientTemplateMapper mapper;

    @Autowired
    private CacheClient cacheClient;

    @Test
    public void findBySignId() {
        List<ClientTemplate> ct1 = mapper.findBySignId(15L);
        List<ClientTemplate> ct2 = mapper.findBySignId(24L);
        for (ClientTemplate clientTemplate : ct1) {
            System.out.println(clientTemplate);
        }
        //  ct2在现有的库中没有数据
        System.out.println(ct2);

        ObjectMapper objectMapper = new ObjectMapper();
        List<Map> value = ct1.stream().map(ct -> {
            try {
                return objectMapper.readValue(objectMapper.writeValueAsString(ct), Map.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toList());


        cacheClient.sadd("client_template:15",value.toArray(new Map[]{}));
    }
}
```

###### client_balance同步

准备ClientBalanceMapper

```java
public interface ClientBalanceMapper {

    @Select("select balance from client_balance where client_id = #{clientId}")
    Long findByClientId(@Param("clientId")Long clientId);

}
```

测试查询并同步到Redis

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class ClientBalanceMapperTest {

    @Autowired
    private ClientBalanceMapper mapper;

    @Autowired
    private CacheClient cacheClient;

    @Test
    public void findByClientId() {
        Long balance = mapper.findByClientId(1L);
        System.out.println(balance);

        cacheClient.set("client_balance:1",balance);
    }
}
```

### 2.4 校验apikey

基于请求传递过来的apikey去Redis缓存中查询客户的信息

如果查询不到，直接扔异常，并且携带指定的错误码

如果查询到客户信息，封装数据

#### 2.4.1 准备Cache查询

Api接口模块的Feign接口

```java
@FeignClient(value = "beacon-cache")
public interface BeaconCacheClient {

    @GetMapping("/cache/hgetall/{key}")
    Map hGetAll(@PathVariable(value = "key")String key);

}
```

Cache缓存模块的Controller接口

```java
@GetMapping("/cache/hgetall/{key}")
public Map hGetAll(@PathVariable(value = "key")String key){
    log.info("【缓存模块】 hGetAll方法，获取key ={} 的数据", key);
    Map<String, Object> value = redisClient.getMap(key);
    log.info("【缓存模块】 hGetAll方法，获取key ={} 的数据 value = {}", key,value);
    return value;
}
```

#### 2.4.2 准备枚举、自定义异常等工具

枚举

```java
@Getter
public enum ExceptionEnums {

    ERROR_APIKEY(-1,"非法的apikey"),
    IP_NOT_WHITE(-2,"请求的ip不在白名单内"),
    ERROR_SIGN(-3,"无可用签名"),
    ERROR_TEMPLATE(-4,"无可用模板"),
    ERROR_MOBILE(-5,"手机号格式不正确"),
    BALANCE_NOT_ENOUGH(-6,"手客户余额不足"),
    ;
    private Integer code;

    private String msg;

    ExceptionEnums(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }
}
```

自定义异常

```java
@Getter
public class ApiException extends RuntimeException {

    private Integer code;

    public ApiException(String message, Integer code) {
        super(message);
        this.code = code;
    }


    public ApiException(ExceptionEnums enums) {
        super(enums.getMsg());
        this.code = enums.getCode();
    }

}
```

R工具

```java
public static ResultVO error(ApiException ex) {
    ResultVO r = new ResultVO();
    r.setCode(ex.getCode());
    r.setMsg(ex.getMessage());
    return r;
}
```

#### 2.4.3 实现ApiKeyCheckFilter

```java
@Service(value = "apikey")
@Slf4j
public class ApiKeyCheckFilter implements CheckFilter {

    @Autowired
    private BeaconCacheClient cacheClient;


    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验apikey】   校验ing…………");
        //1. 基于cacheClient查询客户信息
        Map clientBusiness = cacheClient.hGetAll(CacheConstant.CLIENT_BUSINESS + submit.getApikey());

        //2. 如果为null，直接扔异常
        if(clientBusiness == null || clientBusiness.size() == 0){
            log.info("【接口模块-校验apikey】 非法的apikey = {}",submit.getApikey());
            throw new ApiException(ExceptionEnums.ERROR_APIKEY);
        }

        //3. 正常封装数据
        submit.setClientId(Long.parseLong(clientBusiness.get("id") + ""));
        log.info("【接口模块-校验apikey】 查询到客户信息 clientBusiness = {}",clientBusiness);
    }
}
```

### 2.5 校验请求的ip地址是否是白名单

之前基于apiKey做校验并且封装客户ID时，直接从缓存模块查询到了客户的所有信息。这个是没有必要的，因为只需要可以基于apiKey查询到客户的ID即可。

#### 2.5.1 准备Cache查询

为了做到只查询客户的IP地址，要给Cache模块提供一个hget的方法，基于key和field只查询IP地址即可。

```java
@GetMapping("/cache/hget/{key}/{field}")
public Object hget(@PathVariable(value = "key")String key,@PathVariable(value = "field")String field){
    log.info("【缓存模块】 hget方法，获取key ={}，field = {}的数据", key,field);
    Object value = redisClient.getMapItem(key, field);
    log.info("【缓存模块】 hGetAll方法，获取key ={}，field = {} 的数据 value = {}", key,field,value);
    return value;
}
```

编写完之后，测试一下功能

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/d6e336c2bd234c0ea6602414c1de6549.png)

给Api接口模块提供对应访问的OpenFeign接口的抽象方法

```java
@FeignClient(value = "beacon-cache")
public interface BeaconCacheClient {

    @GetMapping("/cache/hgetall/{key}")
    Map hGetAll(@PathVariable(value = "key")String key);

    @GetMapping("/cache/hget/{key}/{field}")
    Object hget(@PathVariable(value = "key")String key,@PathVariable(value = "field")String field);

}
```

#### 2.5.2 完成校验请求的ip地址是否是白名单

第一步：通过CacheClient查询客户端的IP白名单

发现直接通过CacheClient查询到的IP白名单在转换为Object类型时，直接报错。原因是缓存模块在响应数据时，响应头是【text/plain;chartset=utf-8】。导致Object类型无法直接接收。处理方案有两种：

* 可以从OpenFeign入手，让OpenFeign支持text/plain响应头转换为Object
* 直接给OpenFeign的方法提供一个方法重载，从而将返回值，直接设置为String，String类型可以支持【text/plain;chartset=utf-8】这个响应头

第二步：

* 判断IP白名单为空，直接放行
* 如果不为空，IP白名单是否包含请求IP，如果包含，直接放行

第三步：如果未满足第二部，正常记录日志，抛出异常

```java
@Service(value = "ip")
@Slf4j
public class IPCheckFilter implements CheckFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    private final String IP_ADDRESS = "ipAddress";


    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验ip】   校验ing…………");
        //1. 根据CacheClient根据客户的apikey以及ipAddress去查询客户的IP白名单
        String ip = cacheClient.hgetString(CacheConstant.CLIENT_BUSINESS + submit.getApikey(), IP_ADDRESS);
        submit.setIp(ip);

        //2. 如果IP白名单为null，直接放行
        if(StringUtils.isEmpty(ip) || ip.contains(submit.getRealIP())){
            log.info("【接口模块-校验ip】  客户端请求IP合法！");
            return;
        }

        //3. IP白名单不为空，并且客户端请求不在IP报名单内
        log.info("【接口模块-校验ip】  请求的ip不在白名单内");
        throw new ApiException(ExceptionEnums.IP_NOT_WHITE);
    }
}
```

### 2.6 校验短信的签名

#### 2.6.1 准备Cache查询

因为客户绑定的签名信息，是基于Set结构存储在Redis中，需要让缓存模块提供一个smember查询当前客户的全部绑定的签名信息。

缓存模块提供接口

```java
@GetMapping("/cache/smember/{key}")
public Set smember(@PathVariable(value = "key")String key){
    log.info("【缓存模块】 smember方法，获取key ={}的数据", key);
    Set<Object> values = redisClient.sGet(key);
    log.info("【缓存模块】 smember方法，获取key ={} 的数据 value = {}", key,values);
    return values;
}
```

接口模块提供OpenFeign的抽象方法

```java
@GetMapping("/cache/smember/{key}")
Set<Map> smember(@PathVariable(value = "key")String key);
```

#### 2.6.2 完成校验短信的签名

第一步：先从客户端发送请求中携带的短信内容中，判断是否有使用【】携带了签名

第二步：如果携带了签名，需要将签名截取出来

第三步：基于Redis查询当前客户绑定的所有签名信息

第四步：在客户有绑定了签名的情况下，去做校验

第五步：到了最后，说明签名不匹配，直接告辞

```java
@Service(value = "sign")
@Slf4j
public class SignCheckFilter implements CheckFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    /**
     * 截取签名的开始索引
     */
    private final int SIGN_START_INDEX = 1;

    /**
     * 客户存储签名信息的字段
     */
    private final String CLIENT_SIGN_INFO = "signInfo";



    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验签名】   校验ing…………");
        //1. 判断短信内容是否携带了【】
        String text = submit.getText();
        if(!text.startsWith(ApiConstant.SIGN_PREFIX) || !text.contains(ApiConstant.SIGN_SUFFIX)){
            log.info("【接口模块-校验签名】   无可用签名 text = {}",text);
            throw new ApiException(ExceptionEnums.ERROR_SIGN);
        }
        //2. 将短信内容中的签名截取出来
        String sign = text.substring(SIGN_START_INDEX, text.indexOf(ApiConstant.SIGN_SUFFIX));
        if(StringUtils.isEmpty(sign)){
            log.info("【接口模块-校验签名】   无可用签名 text = {}",text);
            throw new ApiException(ExceptionEnums.ERROR_SIGN);
        }

        //3. 从缓存中查询出客户绑定的签名
        Set<Map> set = cacheClient.smember(CacheConstant.CLIENT_SIGN + submit.getClientId());
        if(set == null || set.size() == 0){
            log.info("【接口模块-校验签名】   无可用签名 text = {}",text);
            throw new ApiException(ExceptionEnums.ERROR_SIGN);
        }
        //4. 判断~
        for (Map map : set) {
            if(sign.equals(map.get(CLIENT_SIGN_INFO))){
                log.info("【接口模块-校验签名】   找到匹配的签名 sign = {}",sign);
                return;
            }
        }

        //5. 到这，说明没有匹配的签名
        log.info("【接口模块-校验签名】   无可用签名 text = {}",text);
        throw new ApiException(ExceptionEnums.ERROR_SIGN);
    }
}
```

### 2.7 校验短信的模板

#### 2.7.1 模板审核前置准备

客户拥有的模板是基于签名绑定

为了可以在模板校验中可以获取到签名的id信息，并且可以替换掉短信内容中的签名，需要在签名校验通过时，将签名id以及签名内容封装到Submit对象中

在签名校验通过后，需要将签名信息，以及签名的id封装到submit中

```java
//4. 判断~
for (Map map : set) {
    if(sign.equals(map.get(CLIENT_SIGN_INFO))){
        // 走到这，说明匹配上了具体的签名信息
        submit.setSign(sign);
        submit.setSignId(Long.parseLong(map.get(SIGN_ID) + ""));
        log.info("【接口模块-校验签名】   找到匹配的签名 sign = {}",sign);
        return;
    }
}
```

在校验模板时，会拿到两个具体的内容

```java
// 短信的具体内容
您的验证码是123434534534534534556。如非本人操作，请忽略本短信
// 模板信息
您的验证码是#code#。如非本人操作，请忽略本短信
// 多变量模板
您的验证码是#code#。如非本人操作，请忽略本短信，验证码有效期为#time#分钟
// 连续多个变量模板（无法审核通过的例子）
您的#info##code#。如非本人操作，请忽略本短信，验证码有效期为#time#分钟
```

在模板中只有一个占位符用##括起来时，模板的校验基本没什么问题。

但是如果模板中出现了多个占位符，这时校验就会出现问题。

模板是需要用户在后台管理模板中进行审核的内容

> 一、验证码类短信内容，要求如下：
> 1、如短信中含变量的，以实际发送字数为准，超过70字，按67字/条计算；
> 2、变量：请以英文格式的双“#”号加英文、数字或下划线的形式，例如#code#，模板不允许单独携带#，并且两个及以上变量需指定模板发送；
> 3、模板不可携带连续多个变量，建议在每个变量前添加能让人明白意图的短信文案，以提高审核通过率；
> 4、验证码类短信不支持携带联系方式/链接/吸引成分内容；
> 5、请输入使用验证码的网址或名称，审核专员需审核页面合规性；若是公司内部系统的网址，请输入网址后额外做文字说明；
> 6、为了防止短信通道被轰炸，使用验证码的网页需要添加图形验证码或行为验证才会被审核通过；
> 7、如果使用验证码的网页还没上线。请输入域名，并备注“开发中”，云片将在您上线后进行复审；
> 8、个人资质申请的验证码类模板，仅支持携带单变量，且不得涉及公司相关内容；
> 9、不支持敏感行业：金融/网赚/运营商/财税/代办业务/法院/宗教/烟酒/ETC等行业均不支持申请验证码类短信。
>
> 二、通知类短信内容，要求如下：
> 1、如短信中含变量的，以实际发送字数为准，超过70字，按67字/条计算；
> 2、变量：请以英文格式的双“#”号加英文、数字或下划线的形式，例如#code# ，模板不允许单独携带#，并且两个及以上变量需指定模板发送；
> 3、模板不可携带连续多个变量，建议在每个变量前添加能让人明白意图的短信文案，以提高审核通过率；
> 4、若文案包含跳转两次及以上的链接，暂不支持申请；
> 5、请确保您的模板主题是明确的，主题不明确会被拒绝；
> 6、不支持敏感行业：
> · 金融类：股票、投资、理财、支付等类模板暂不支持
> · 运营商类：涉及移动、联通、电信三大运营商相关业务类通知暂不支持
> 7、个人资质申请的通知类模板，不支持携带变量，且仅支持祝福类短信。
>
> 三、营销类短信内容，要求如下：
> 1、如短信中含变量的，以实际发送字数为准，超过70字，按67字/条计算；
> 2、变量：请以英文格式的双“#”号加英文、数字或下划线的形式，例如#code#，模板不允许单独携带#，并且两个及以上变量需指定模板发送；
> 3、模板不可携带连续多个变量，建议在每个变量前添加能让人明白意图的短信文案，以提高审核通过率；
> 4、若文案包含跳转两次及以上的链接，暂不支持申请；
> 5、不支持敏感行业：
> · 会展类：会议/展会/讲座/宣讲会/培训类营销内容均不支持
> · 教育类：画画、书法等兴趣班营销知晓拦截风险可发，应试教育、考证相关营销育暂不支持
> · 运营商类：涉及移动、联通、电信三大运营商相关业务类营销暂不支持
> · 家装类：家装、装修、建材类营销内容暂不支持
> · 招聘类：招聘邀请、兼职邀请、网赚类营销暂不支持
> · 金融类：金融投资、理财、支付等类模板暂不支持
> · 电商类：A货、微商、货到付款、众筹、公益、代理、返利、一元购类营销暂不支持
> · 代办类：代开发票、代理注册公司、代办其他证件类暂不支持
> · 法院类：涉及案件相关、政府法律、律师事务所类暂不支持。

根据上述的模板审核要求，可以确认一个事情：

* 当前的单条短信发送时，只能去匹配有一个变量的模板，如果模板中有多个变量，无法匹配
* 如果要使用多变量的模板，需要使用指定模板发送的接口去发送短信，以下面的模板举例，发送短信时，需要指定好当前模板的id，再传入针对不同占位符的值，去生成短信内容
  ```
  您的验证码是#code#。如非本人操作，请忽略本短信，验证码有效期为#time#分钟
  ```

#### 2.7.2 完成模板校验

为了完成模板的校验需要执行几步操作：

* 从submit中获取到短信内容，签名信息，签名id
* 将短信内容中的签名直接去掉，获取短信具体内容
* 从缓存中获取到签名id绑定的所有模板
* 遍历签名绑定的所有模板信息
  * 将模板内容和短信具体内容做匹配-true-匹配成功
  * 判断模板中是否只包含一个变量，如果是，直接让具体短信内容匹配前缀和后缀
* 模板校验失败

```java
@Service(value = "template")
@Slf4j
public class TemplateCheckFilter implements CheckFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    /**
     * 模板内容中的具体模板信息
     */
    private final String TEMPLATE_TEXT = "templateText";

    private final String TEMPLATE_PLACEHOLDER = "#";

    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验模板】   校验ing…………");
        // 1、从submit中获取到短信内容，签名信息，签名id
        String text = submit.getText();
        String sign = submit.getSign();
        Long signId = submit.getSignId();
        // 2、将短信内容中的签名直接去掉，获取短信具体内容

        text = text.replace(ApiConstant.SIGN_PREFIX + sign + ApiConstant.SIGN_SUFFIX, "");
        // 3、从缓存中获取到签名id绑定的所有模板
        Set<Map> templates = cacheClient.smember(CacheConstant.CLIENT_TEMPLATE + signId);
        // 4、在tempaltes不为null时，遍历签名绑定的所有模板信息
        if(templates != null && templates.size() > 0) {
            for (Map template : templates) {
                // 4.1 将模板内容和短信具体内容做匹配-true-匹配成功
                String templateText = (String) template.get(TEMPLATE_TEXT);
                if(text.equals(templateText)){
                    // 短信具体内容和模板是匹配的。
                    log.info("【接口模块-校验模板】   校验模板通过 templateText = {}",templateText);
                    return;
                }
                // 4.2 判断模板中是否只包含一个变量，如果是，直接让具体短信内容匹配前缀和后缀
                // 例子：您的验证码是123434。如非本人操作，请忽略本短信
                // 例子：您的验证码是#code#。如非本人操作，请忽略本短信
                if(templateText != null && templateText.contains(TEMPLATE_PLACEHOLDER)
                        && templateText.length() - templateText.replaceAll(TEMPLATE_PLACEHOLDER,"").length() == 2){
                    // 可以确认模板不为空，并且包含#符号，而且#符号有2个，代表是一个占位符（变量）。
                    // 获取模板撇去占位符之后的前缀和后缀
                    String templateTextPrefix = templateText.substring(0, templateText.indexOf(TEMPLATE_PLACEHOLDER));
                    String templateTextSuffix = templateText.substring(templateText.lastIndexOf(TEMPLATE_PLACEHOLDER) + 1);
                    // 判断短信的具体内容是否匹配前缀和后缀
                    if(text.startsWith(templateTextPrefix) && text.endsWith(templateTextSuffix)){
                        // 当前的短信内容匹配短信模板
                        log.info("【接口模块-校验模板】   校验模板通过 templateText = {}",templateText);
                        return;
                    }
                }
            }
        }
        // 5、 模板校验失败
        log.info("【接口模块-校验模板】   无可用模板 text = {}",text);
        throw new ApiException(ExceptionEnums.ERROR_TEMPLATE);
    }
}
```

### 2.8 校验手机号的格式合法性

手机号暂时满足国内的移动，联通，电信三大运营商的手机号规范即可。

需要一套合适的正则表达式（正则去网上COPY，不要自己写）。

准备一套正则的工具类校验手机号格式：

```java
/**
 * 校验手机号格式的合法性正则
 * @author zjw
 * @description
 */
public class PhoneFormatCheckUtil {

    /**
     * 国内手机号的正则表达式
     */
    private final static Pattern CHINA_PATTERN = Pattern.compile("^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$");

    /**
     * 根据正则校验手机号是否合法
     * @param number
     * @return
     */
    public static boolean isChinaPhone(String number){
        Matcher matcher = CHINA_PATTERN.matcher(number);
        return matcher.matches();
    }

}
```

编写校验手机号的Filter：

```java
@Service(value = "mobile")
@Slf4j
public class MobileCheckFilter implements CheckFilter {


    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验手机号】   校验ing…………");
        String mobile = submit.getMobile();
        if(!StringUtils.isEmpty(mobile) && PhoneFormatCheckUtil.isChinaPhone(mobile)){
            // 如果校验进来，代表手机号么得问题
            log.info("【接口模块-校验手机号】   手机号格式合法 mobile = {}",mobile);
            return;
        }
        log.info("【接口模块-校验手机号】   手机号格式不正确 mobile = {}",mobile);
        throw new ApiException(ExceptionEnums.ERROR_MOBILE);
    }
}
```

### 2.9 校验客户剩余的金额是否充足

根据短信内容的字数计算具体费用是多少

> 短信文字个数超过70字，按67字/条计算费用
>
> 如果短信文字个数小于等于70字，按照一条计算即可、
>
> 短信内容一条最大是指140个字节，如果是纯英文的方式计算，这种方式，一个字符最小只需要占用7个bit位，按照是ASCII码表去写的，一般只需要0~127之间的ASCII码表信息即可，纯英文的方式，最多可以编写160个字符。
>
> 但是只要短信内容出现了一个中文或者是中文的字符，此时当前的短信内容就全部都要基于UCS-2编码，这个编码每个字占用2字节。
>
> 因为想从平台发送短信必须要有签名，签名必须用中文的符号【】包起来，所以平台所有短信内容的长度都按照一个文字占用2字节去计算，也就是70个字。

```java
@Service(value = "fee")
@Slf4j
public class FeeCheckFilter implements CheckFilter {

    /**
     * 只要短信内容的文字长度小于等于70个字，按照一条计算
     */
    private final int MAX_LENGTH = 70;

    /**
     * 如果短信内容的文字长度超过70，67字/条计算
     */
    private final int LOOP_LENGTH = 67;


    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验客户余额】   校验ing…………");
    }

}
```

之前同步到Redis的数字展示的样子是个字符串

发现之前同步到Redis缓存中的用户余额被存储为了字符串类型

直接将clientBalance中的全部信息同步到Redis缓存中，这样当前存储的金额是正常的数值类型

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1667054812060/3ff0d85975614a81aaee236a7b1d0c91.png)

查询到缓存中的剩余金额，并和短信费用多比较

```java
@Service(value = "fee")
@Slf4j
public class FeeCheckFilter implements CheckFilter {

    @Autowired
    private BeaconCacheClient cacheClient;

    /**
     * 只要短信内容的文字长度小于等于70个字，按照一条计算
     */
    private final int MAX_LENGTH = 70;

    /**
     * 如果短信内容的文字长度超过70，67字/条计算
     */
    private final int LOOP_LENGTH = 67;

    private final String BALANCE = "balance";


    @Override
    public void check(StandardSubmit submit) {
        log.info("【接口模块-校验客户余额】   校验ing…………");
        //1、从submit中获取到短信内容
        int length = submit.getText().length();

        //2、判断短信内容的长度，如果小于等于70，算作一条，如果大于70字，按照67字/条，算出来当前短信的费用
        if(length <= MAX_LENGTH){
            // 当前短信内容是一条
            submit.setFee(ApiConstant.SINGLE_FEE);
        }else{
            int strip = length % LOOP_LENGTH == 0 ? length / LOOP_LENGTH : length / LOOP_LENGTH + 1;
            submit.setFee(ApiConstant.SINGLE_FEE * strip);
        }

        //3、从Redis中查询出客户剩余的金额
        Long balance = ((Integer) cacheClient.hget(CacheConstant.CLIENT_BALANCE + submit.getClientId(), BALANCE)).longValue();

        //4、判断金额是否满足当前短信费用\
        if(balance >= submit.getFee()){
            log.info("【接口模块-校验客户余额】   用户金额充足！！");
            return;
        }

        //5、不满足就抛出异常
        log.info("【接口模块-校验客户余额】   客户余额不足");
        throw new ApiException(ExceptionEnums.BALANCE_NOT_ENOUGH);
    }

}
```

### 2.10 雪花算法生成唯一标识

#### 2.10.1 编写雪花算法工具类

雪花算法是分布式微服务下生成全局唯一的ID，并且可以做到去中心化的常用算法

SnowFlake中文意思就是雪花，所以叫他雪花算法。最早是推特公司在其内部的分布式环境下生成ID的方式。

整体结构雪花算法是固定，但是也可以做一些细粒度的调整。

雪花算法有一个特点，首先他是64bit位的正整数，整体结构是有序的，这样数据存储在本地的MySQL也是一套连续的序列。

64的个bit位分别是：

* 最高为：0，代表是一个正整数
* 41位：存储毫秒级别的时间戳。System.currentMillons();
* 10位：存储机房/机器/操作系统/容器/服务的ID;
* 12位：存储一个序列，自增的值。

在common组件中，编写编写雪花算法的工具类，在需要的项目中引用即可。

```java
/**
 * 雪花算法生成全局唯一ID
 * 64个bit为的long类型的值
 * 第一位：占1个bit位，就是0.
 * 第二位：占41个bit位，代表时间戳
 * 第三位：占5个bit位，代表机器id
 * 第四位：占5个bit位，服务id
 * 第五位：占12个bit位，序列，自增的数值
 * @author zjw
 * @description
 */
@Component
public class SnowFlakeUtil {

    /**
     * 41个bit位存储时间戳，从0开始计算，最多可以存储69.7年。
     * 那么如果默认使用，从1970年到现在，最多可以用到2039年左右。
     * 按照从2022-11-11号开始计算，存储41个bit为，这样最多可以使用到2092年不到~~
     */
    private long timeStart = 1668096000000L;

    /**
     * 机器id
     */
    @Value("${snowflake.machineId:0}")
    private long machineId;

    /**
     * 服务id
     */
    @Value("${snowflake.serviceId:0}")
    private long serviceId;

    /**
     * 序列
     */
    private long sequence;


    /**
     * 机器id占用的bit位数
     */
    private long machineIdBits = 5L;

    /**
     * 服务id占用的bit位数
     */
    private long serviceIdBits = 5L;

    /**
     * 序列占用的bit位数
     */
    private long sequenceBits = 12L;

    /**
     * 计算出机器id的最大值
     */
    private long maxMachineId = -1 ^ (-1 << machineIdBits);

    /**
     * 计算出服务id的最大值
     */
    private long maxServiceId = -1 ^ (-1 << serviceIdBits);

    @PostConstruct
    public void init(){
        if(machineId > maxMachineId || serviceId > maxServiceId){
            System.out.println("机器ID或服务ID超过最大范围值！！");
            throw new ApiException(ExceptionEnums.SNOWFLAKE_OUT_OF_RANGE);
        }
    }

    /**
     * 服务id需要位移的位数
     */
    private long serviceIdShift = sequenceBits;

    /**
     * 机器id需要位移的位数
     */
    private long machineIdShift = sequenceBits + serviceIdBits;

    /**
     * 时间戳需要位移的位数
     */
    private long timestampShift = sequenceBits + serviceIdBits + machineIdBits;

    /**
     *  序列的最大值
     */
    private long maxSequenceId = -1 ^ (-1 << sequenceBits);

    /**
     * 记录最近一次获取id的时间
     */
    private long lastTimestamp = -1;

    /**
     *  获取系统时间毫秒值
     * @return
     */
    private long timeGen(){
        return System.currentTimeMillis();
    }


    public synchronized long nextId(){
        //1、 拿到当前系统时间的毫秒值
        long timestamp = timeGen();
        // 避免时间回拨造成出现重复的id
        if(timestamp < lastTimestamp){
            // 说明出现了时间回拨
            System.out.println("当前服务出现时间回拨！！！");
            throw new ApiException(ExceptionEnums.SNOWFLAKE_TIME_BACK);
        }

        //2、 判断当前生成id的时间和上一次生成的时间
        if(timestamp == lastTimestamp){
            // 同一毫秒值生成id
            sequence = (sequence + 1) & maxSequenceId;
            // 0000 10100000 :sequence
            // 1111 11111111 :maxSequenceId
            if(sequence == 0){
                // 进到这个if，说明已经超出了sequence序列的最大取值范围
                // 需要等到下一个毫秒再做回来生成具体的值
                timestamp = timeGen();
                while(timestamp <= lastTimestamp){
                    // 时间还没动。
                    timestamp = timeGen();
                }
            }
        }else{
            // 另一个时间点生成id
            sequence = 0;
        }
        //3、重新给lastTimestamp复制
        lastTimestamp = timestamp;

        //4、计算id，将几位值拼接起来。  41bit位的时间，5位的机器，5位的服务 ，12位的序列
        return  ((timestamp - timeStart) << timestampShift) |
                (machineId << machineIdShift) |
                (serviceId << serviceIdShift) |
                sequence &
                Long.MAX_VALUE;
    }
}
```

#### 2.10.2 在接口模块直接调用即可

需要在启动类中追加需要扫描的包

```java
/**
 * @author zjw
 * @description
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
@ComponentScan(basePackages = {
        "com.mashibing.api",
        "com.mashibing.common"
})
public class ApiStarterApp {

    public static void main(String[] args) {
        SpringApplication.run(ApiStarterApp.class,args);
    }
}
```

在接口模块的单挑短信发送中，生成唯一id，set到StandardSubmit对象中

```java
/**
 * 单条验证短信接口
 * @param singleSendForm
 * @param bindingResult
 * @param req
 * @return
 */
@PostMapping(value = "/single_send",produces = "application/json;charset=utf-8")
public ResultVO singleSend(@RequestBody @Validated SingleSendForm singleSendForm, BindingResult bindingResult, HttpServletRequest req){
    //1. 校验参数
    if (bindingResult.hasErrors()){
        String msg = bindingResult.getFieldError().getDefaultMessage();
        log.info("【接口模块-单条短信Controller】 参数不合法 msg = {}",msg);
        return R.error(ExceptionEnums.PARAMETER_ERROR.getCode(),msg);
    }
    //=========================获取真实的IP地址=========================================
    String ip = this.getRealIP(req);

    //=========================构建StandardSubmit，各种封装校验=========================================
    StandardSubmit submit = new StandardSubmit();
    submit.setRealIP(ip);
    submit.setApikey(singleSendForm.getApikey());
    submit.setMobile(singleSendForm.getMobile());
    submit.setText(singleSendForm.getText());
    submit.setState(singleSendForm.getState());
    submit.setUid(singleSendForm.getUid());

    //=========================调用策略模式的校验链=========================================
    checkFilterContext.check(submit);

    //========================基于雪花算法生成唯一id，并添加到StandardSubmit对象中=========================================
    submit.setSequenceId(snowFlakeUtil.nextId());

    //=========================发送到MQ，交给策略模块处理=========================================
    return R.ok();
}
```

### 2.11 发送消息到RabbitMQ

为什么要在接口模块和策略模块之间做一个MQ的缓冲。

核心点是为了两个事情：

* 接口模块是客户直接通过HTTP请求的入口，希望可以快速的给客户响应。
* 接口模块中存放前置的基本校验，将一些可选择的校验放在了策略模块中再次校验。

完成发送消息到RabbitMQ

* 导入依赖
  ```
  <!--        RabbitMQ-->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```
* 编写配置信息
  ```
  spring: 
  # rabbitMQ连接信息
    rabbitmq:
      host: 114.116.226.76
      port: 5672
      username: root
      password: ZhengJinWei123!
      virtual-host: /  
      # 开启confirm机制&return机制
      publisher-confirm-type: correlated
      publisher-returns: true
  ```
* 声明发送的队列信息
  ```
  /**common中声明
   * RabbitMQ中的一些队列信息
   * @author zjw
   * @description
   */
  public interface RabbitMQConstants {
  
      /**
       * 接口模块发送消息到策略模块的队列名称
       */
      String SMS_PRE_SEND = "sms_pre_send_topic";
  }
  // =======================================
  /**
   * 构建队列&交换机信息
   * @author zjw
   * @description
   */
  @Configuration
  public class RabbitMQConfig {
  
      /**
       * 接口模块发送消息到策略模块的队列
       * @return
       */
      @Bean
      public Queue preSendQueue(){
          return QueueBuilder.durable(RabbitMQConstants.SMS_PRE_SEND).build();
      }
  
  }
  ```
* 配置RabbitTemplate
  ```
  /**
   * 设置RabbitTemplate的confirm&return机制
   * @author zjw
   * @description
   */
  @Configuration
  @Slf4j
  public class RabbitTemplateConfig {
  
      @Bean
      public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory){
          //1、构建RabbitTemplate对象
          RabbitTemplate rabbitTemplate = new RabbitTemplate();
  
          //2、设置connectionFactory
          rabbitTemplate.setConnectionFactory(connectionFactory);
  
          //3、配置confirm机制
          rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback(){
  
              @Override
              public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                  // ack为false，代表消息没有发送到exchange。
                  if(!ack){
                      log.error("【接口模块-发送消息】 消息没有发送到交换机，correlationData = {}，cause = {}",correlationData,cause);
                  }
              }
          });
  
          //4、配置return机制
          rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback(){
  
              // 触发这个回调，说明交换机没有把消息路由到指定的队列中
              @Override
              public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
                  log.error("【接口模块-发送消息】 消息没有路由到指定的Queue。 message = {},exchange = {},routingKey = {}",
                          new String(message.getBody()),exchange,routingKey);
              }
          });
  
          //5、返回
          return rabbitTemplate;
      }
  
  }
  ```
* 基于RabbitTemplate发送消息到队列
  ```
  /**
   * 单条验证短信接口
   * @param singleSendForm
   * @param bindingResult
   * @param req
   * @return
   */
  @PostMapping(value = "/single_send",produces = "application/json;charset=utf-8")
  public ResultVO singleSend(@RequestBody @Validated SingleSendForm singleSendForm, BindingResult bindingResult, HttpServletRequest req){
      //1. 校验参数
      if (bindingResult.hasErrors()){
          String msg = bindingResult.getFieldError().getDefaultMessage();
          log.info("【接口模块-单条短信Controller】 参数不合法 msg = {}",msg);
          return R.error(ExceptionEnums.PARAMETER_ERROR.getCode(),msg);
      }
      //=========================获取真实的IP地址=========================================
      String ip = this.getRealIP(req);
  
      //=========================构建StandardSubmit，各种封装校验=========================================
      StandardSubmit submit = new StandardSubmit();
      submit.setRealIP(ip);
      submit.setApikey(singleSendForm.getApikey());
      submit.setMobile(singleSendForm.getMobile());
      submit.setText(singleSendForm.getText());
      submit.setState(singleSendForm.getState());
      submit.setUid(singleSendForm.getUid());
  
      //=========================调用策略模式的校验链=========================================
      checkFilterContext.check(submit);
  
      //========================基于雪花算法生成唯一id，并添加到StandardSubmit对象中=========================================
      submit.setSequenceId(snowFlakeUtil.nextId());
  
      //=========================发送到MQ，交给策略模块处理=========================================
      rabbitTemplate.convertAndSend(RabbitMQConstants.SMS_PRE_SEND,submit,new CorrelationData(submit.getSequenceId().toString()));
  
      // =====================没有问题，返回接收成功===============================
      return R.ok();
  }
  ```
