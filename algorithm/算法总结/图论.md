# 七、图论

## 1.简介

**图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。**图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

图可以用来模拟现实世界中的许多不同类型的网络，比如社交网络中的人际关系、城市间的道路网络、网页之间的链接结构等。

## 2.相关概念

### （1）图的基本概念

- **节点（Vertex）**：图中的一个对象，可以用来表示一个实体。
- **边（Edge）**：连接两个节点的线，表示节点之间的关系。边可以是有向的（表示关系的方向）或无向的。
- **邻接（Adjacency）**：如果两个节点通过一条边直接相连，则它们被称为邻接节点。
- **路径（Path）**：由边依次连接的一系列节点。
- **环（Cycle）**：起点和终点相同的路径。
- **加权图（Weighted Graph）**：图的边被赋予了权重，权重可以表示成本、距离等。
- **连通图（Connected Graph）**：在无向图中，如果任意两个节点都是连通的，则该图被称为连通图。
- **强连通图（Strongly Connected Graph）**：在有向图中，如果对于任意两个节点`u`和`v`，都存在从`u`到`v`以及从`v`到`u`的路径，则该图被称为强连通图。

### （2）图的分类

- **无向图（Undirected Graph）**：图中所有的边都是无向的，即边的方向不影响图的含义。
- **有向图（Directed Graph）**：图中的边具有方向，从一个节点指向另一个节点。
- **无权图（Unweighted Graph）**：图中的边没有权重。
- **有权图（Weighted Graph）**：图中的边具有权重。

## 3.图的存储

### （1）**邻接矩阵（Adjacency Matrix）**

使用二维数组来表示图。如果节点`i`和节点`j`之间存在边，则`matrix[i][j]`和`matrix[j][i]`（无向图）被设置为1（或权重值，对于加权图）；否则被设置为0。

### （2）**邻接列表（Adjacency List）**

对于每个节点，都有一个列表来存储它的邻接节点。这是一种更加紧凑的表示方法，特别适合于稀疏图。

```java
public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;
    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
    public class Edge {
        public int weight;
        public Node from;
        public Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
    public class Node {
        public int value;
        public int in;
        public int out;
        public ArrayList<Node> nexts;
        public ArrayList<Edge> edges;

        public Node(int value) {
            this.value = value;
            in = 0;
            out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }
}
```

## 4.DFS

在DFS中，栈的使用是模拟递归调用堆栈的一种方法，反映了后进先出的原则，确保了算法能够深入到每个可能的分支。通过将当前节点的邻接节点加入栈中，算法可以持续深入直至达到叶子节点，然后通过栈的回溯自然地探索其他分支。使用集合记录已访问的节点，是防止算法在含有环的图中陷入无限循环的关键。这个集合保证了每个节点在整个遍历过程中只被访问一次，从而提高了遍历的效率。

```java
public class DFS {
    public static void dfs(Node start){
        if(start==null){
            return;
        }
        Stack<Node>stack=new Stack<>();
        HashSet<Node> set=new HashSet<>();
        stack.add(start);
        set.add(start);
        System.out.println(start);
        while(!stack.isEmpty()){
            Node cur=stack.pop();
            System.out.println(cur.value);
            for(Node node:cur.nexts){
                if(!set.contains(node)){
                    stack.add(cur);
                    stack.add(node);
                    System.out.println(node);
                    set.add(node);
                    break;
                }
            }
        }
    }
}
```



## 5.BFS

宽度优先搜索（BFS）是一种用于遍历或搜索树和图的算法。对于图结构，BFS 通过使用队列这种先进先出（FIFO）的数据结构，确保了节点按照它们被发现的顺序进行访问。由于图中可能存在环，即一个节点可以通过多条路径被访问到，因此，为了防止无限循环和重复访问相同的节点，使用一个集合来记录已经被访问过的节点是至关重要的。

```java
public class BFS {
    public static void bfs(Node start) {
        if(start==null){
            return;
        }
        Queue<Node> queue = new LinkedList<>();
        HashSet<Node> set=new HashSet<>();
        queue.add(start);
        set.add(start);
        while(!queue.isEmpty()){
            Node cur=queue.poll();
            System.out.println(cur.value);
            for(Node node:cur.nexts){
                if(!set.contains(node)){
                    queue.add(node);
                    set.add(node);
                }
            }
        }
    }
}
```



## 6.树上问题

## 7.矩阵树定理

## 8.有向无环图

## 9.拓扑排序

？

## 10.最小生成树

Kruskal算法

Prim算法

## 11.斯坦纳树

## 12.最小树形图

## 13.最小直径生成树

## 14.最短路

Dijkstra算法

## 15.拆点

## 16.差分约束

## 17.k短路







