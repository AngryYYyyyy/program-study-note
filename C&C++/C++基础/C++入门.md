# 一、C++关键字

> C++11的一部分关键字，后续学习会继续介绍

| Keyword    | Keyword      | Keyword          | Keyword       |
| ---------- | ------------ | ---------------- | ------------- |
| alignas    | decltype     | long             | short         |
| alignof    | default      | mutable          | signed        |
| asm        | delete       | namespace        | sizeof        |
| auto       | double       | new              | static        |
| bool       | dynamic_cast | noexcept         | static_assert |
| break      | else         | not              | static_cast   |
| case       | enum         | not_eq           | struct        |
| catch      | explicit     | nullptr          | switch        |
| char       | export       | operator         | template      |
| class      | extern       | or               | this          |
| const      | false        | or_eq            | thread_local  |
| constexpr  | float        | private          | throw         |
| const_cast | for          | protected        | true          |
| continue   | friend       | public           | try           |
| decltype   | goto         | register         | typedef       |
| default    | if           | reinterpret_cast | typeid        |
| delete     | inline       | return           | typename      |
| do         | int          | short            | union         |
| double     | long         | signed           | unsigned      |

# 二、命名空间

> 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是==**对标识符的名称进行本地化，以避免命名冲突或名字污染**==，namespace关键字的出现就是针对这种问题的。

## 2.1 命名空间的定义

> 定义命名空间，需要使用到==namespace关键字==，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。

```c++
namespace name
{
    int a;
    void func(){}
    struct type_t
    {};
    namespace name1
    {}
}
```

> 命名空间中可以定义变量/函数/类型
>
> 命名空间可以嵌套
>
> 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中

## 2.2 命名空间的使用

### （1）加命名空间名称及作用域限定符指定某个成员

```c++
//作用域限定符::
name::a
```



### （2）使用using将命名空间中某个成员引入

```c++
using name::a;
```



### （2）使用using namespace 将命名空间引入

```c++
using namespace name;
```



## 2.3 <stdio.h>与\<cstdio>区别

### （1）**原始C与C++**

> - `<stdio.h>`：是原始C库的头文件。
> - `<cstdio>`：是C++标准库中对应的头文件。

### （2）==**命名空间**==

> - `<stdio.h>`：所有的函数和符号都是在全局命名空间中。
> - `<cstdio>`：所有的函数和符号都在`std`命名空间中。因此，当你使用 `<cstdio>` 时，你通常需要用 `std::` 限定符，例如 `std::printf`，除非你使用了 `using` 指令或声明。

### （3）**兼容性**

> - `<stdio.h>`：在C和C++中都可用。
> - `<cstdio>`：主要是在C++中使用。

### （4）**其他C标准库的头文件**

> 对于C++，几乎所有C标准库的头文件都有一个对应的以“c”开始的版本（去掉“.h”后缀），例如 `<math.h>` 在C++中是 `<cmath>`， `<string.h>` 在C++中是 `<cstring>`。这种命名约定也遵循了上述的规则和区别。

# 三、输入和输出

> `cin` 和 `cout` 是C++中的对象，它们都定义在`<iostream>`头文件中，是标准输入输出库的一部分。这两个对象与控制台输入和输出紧密相关，可以自动识别变量的类型，让C++程序能够从控制台读取数据并向控制台输出数据。
>
> 实际上cout和cin分别是ostream和istream类型的对象，>>和<<也涉及运算符重载等知识，这里只是简单学习他们的使用，后面更深入的学习 IO流用法及原理

## 3.1 cout

> - `cout` 是一个代表标准输出流的对象，常用于将文本和数据输出到控制台。
> - 使用 `<<` 运算符与 `cout` 对象一起，将数据输出到屏幕。

```c++
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```



## 3.2 cin

> - `cin` 是一个代表标准输入流的对象，常用于从键盘读取文本和数据。
> - 使用 `>>` 运算符与 `cin` 对象一起，将数据从控制台读入到变量中。

```c++
#include <iostream>
int main() {
    int age;
    std::cout << "Please enter your age: ";
    std::cin >> age;
    std::cout << "You are " << age << " years old." << std::endl;
    return 0;
}
```



# 四、缺省参数

> 在C++中，函数参数可以有默认值，这些默认值的参数通常称为缺省参数。当函数调用时没有为这些参数提供值时，它们会自动使用这些默认值。

## （1）全缺省参数

> 函数的所有参数都有默认值

```c++
void Func(int a = 10, int b = 20, int c = 30)
{
    cout<<"a = "<<a<<endl;
    cout<<"b = "<<b<<endl;
    cout<<"c = "<<c<<endl;
}
```



## （2）半缺省参数

> 函数的参数部分有默认值，而其他部分没有

```c++
void Func(int a, int b = 10, int c = 20)
{
    cout<<"a = "<<a<<endl;
    cout<<"b = "<<b<<endl;
    cout<<"c = "<<c<<endl;
}
```

> ==半缺省参数在参数列表中必须跟在非缺省参数==
>
> ==缺省值必须是常量或者全局变量==



# 五、函数重载

> 函数重载（Function Overloading）是C++编程语言中的一个特性，它允许程序员定义==多个同名的函数，但这些函数的参数列表必须不同（不同的参数类型、参数数量或参数顺序）==。

## 5.1 基本规则

> **函数名称必须相同**。
>
> **函数的参数列表必须不同**（不同的参数数量、类型或顺序）。
>
> **仅返回类型的不同不能作为函数重载的依据**。

## 5.2 函数重载原理

> 函数重载的原理基于编译器在编译过程中进行的==名称修饰（name mangling）==或名称装饰（name decoration）。当你重载一个函数时，虽然所有重载的函数都共享相同的名称，但是编译器会为每个函数生成一个不同的、独特的内部名称，这个内部名称是==基于函数的名称、参数类型和（对于成员函数来说）类名称==来生成的。

### 5.2.1 链接解析

> 名称修饰允许链接器正确地链接重载函数的调用。当你在程序中调用一个重载的函数时，编译器根据你提供的参数类型生成对应 的修饰后的函数名，并在链接阶段将其与正确的函数实现进行链接。

### 5.2.2 函数名称修饰

> 为了支持函数重载，C++的编译器对函数名进行修饰，将参数类型信息添加到函数名后，从而生成一个唯一的函数标识符。这意味着即使在源代码中两个函数有相同的名字，它们在编译后的代码中也会有不同的名字。
>
> C语言没有函数名称修饰，因此不具备函数重载的功能

## 5.3 extern "C"

> C++支持函数重载，这意味着可以有多个同名函数，只要它们的参数类型或数量不同。为了区分这些函数，C++编译器在编译时对函数名进行修饰，这样每个函数都会有一个独特的名称。而C语言没有函数重载的概念，所以它不需要这种名字修饰。
>
> 当C++代码想要调用一个C语言库中的函数或当C语言代码想要调用C++库中的函数时，就可能出现问题。这是因为由于名字修饰的存在，链接器可能找不到正确的函数。
>
> `extern "C"` 是C++中的一个链接规范，它用于告诉C++编译器按照C的方式来处理指定的代码。在C++中使用它的主要原因是为了==确保与C语言代码的互操作性==。

### 5.3.1 使用extern "C"

> 如果你在一个C++头文件中使用`extern "C"`, 并且这个头文件也会被C代码所包含，那么需要使用条件编译来确保`extern "C"`只在C++编译器中生效

#### （1）**声明一个C函数**

```cpp
#ifdef __cplusplus
extern "C"
{
#endif
 void MyCFunction();
#ifdef __cplusplus
}
#endif
```

#### （2）**包含一个C语言的头文件**

> 如果你有一个C语言的头文件（例如`my_header.h`）并且想要在C++代码中包含它，你可以这样做
>

```cpp
#ifdef __cplusplus
extern "C"
{
#endif
 #include "my_header.h"
#ifdef __cplusplus
}
#endif
```

## 5.4 相关面试题

### （1）下面两个函数能形成函数重载吗？有问题吗或者什么情况下会出问题？

```c++
void Func(int a = 10)
{
    cout<<"void Func(int a = 10)"<<endl;
}
void Func(int a)
{
    cout<<"void Func(int a)"<<endl;
}
```

> 这两个函数不能形成有效的函数重载，因为它们的参数列表是相同的（都是单个整数类型的参数）。尽管第一个函数有一个默认值，但这并不影响函数的修饰。这意味着编译器将无法确定应该调用哪个版本的`Func`函数，因此会导致编译时错误。

### （2）**为什么C语言不支持函数重载**

> C语言的函数名就是它的唯一标识符，没有考虑到参数列表，这样保持了其简洁性和高效性。

### （3）**C++中函数重载的底层处理**

> 当C++编译器遇到重载的函数时，它会进行名字修饰，以确保每个函数都有一个独特的名称。这个过程通常包括将函数的参数类型附加到函数名上来生成一个独特的函数标识符。因此，重载的函数在编译后的代码中都会有不同的名称，使链接器可以区分它们。

### （4）**在C++中按照C的风格编译一个函数**

> 可以使用`extern "C"`来告诉C++编译器按照C语言的方式处理特定的代码.
>
> 使用`extern "C"`后，该函数不会经历名字修饰，可以被C代码直接调用（假设该函数的实现只使用了C兼容的特性）。

# 六、引用

> 给已存在变量取了一个==别名==，==共用同一块内存空间==

## 6.1 引用特性

> 引用在定义时必须初始化 
>
> 一个变量可以有多个引用 
>
> 引用一旦引用一个实体，再不能引用其他实体

## 6.2 引用的使用

### （1）参数

> 使用引用作为参数时，函数可以直接修改传递给它的变量的值。
>
> 可以==避免数据的复制==，这在处理大型对象时尤为重要。

### （2）返回值

> 函数可以返回引用，从而提供对函数内部或外部数据的直接访问。
>
> 永远==不要返回局部变量的引用==，因为局部变量会在函数返回后被销毁，这将导致未定义的行为。
>
> 通常，==返回引用最有用的场景是访问对象的成员或静态变量==。

## 6.3 常量引用

> 常量引用在C++中是一个很有用的特性，主要用于==确保引用的对象不会被修改==。

### 6.3.1 参数

> 常量引用作为函数参数可以确保在函数内部不会修改传递的实参，同时避免了复制的开销。

### 6.3.2 引用临时变量

> 常量引用==允许引用一个临时对象==（例如函数返回值或类型转换的结果），这会==延长临时对象的生命周期==至引用的生命周期。

#### （1）**函数返回值**

> 当函数返回一个对象，但不是通过指针或引用返回时，它实际上返回的是该对象的一个副本，这是一个临时对象。

```c++
std::string GetName() {
    return "Alice";
}
const std::string& name = GetName();
```

#### （2）运算符结果

> 行一些操作（如算术运算）时，结果通常是一个临时值。

```c++
const double& result = 5.0 / 3.0;
```

#### （3）**类型转换**

> 当进行类型转换时，结果是一个临时值。

```c++
double d = 5.7;
const int& i = static_cast<int>(d);
```

## 6.4 引用与指针

> 引用概念上定义一个变量的别名，指针存储一个变量地址。 
>
> ==引用本身不是一个对象==，因此不占用任何存储空间。指针是一个对象，它占用存储空间。
>
> 引用在定义时必须初始化，指针没有要求 
>
> 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体 
>
> 没有NULL引用，但有NULL指针 
>
> 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节) 
>
> 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 
>
> 有多级指针，但是没有多级引用 
>
> 访问实体方式不同，指针需要显式解引用，引用编译器自己处理 

# 七、内联函数

> 内联函数是C++提供的一个优化特性，它们用于减少函数调用的开销，尤其在那些被频繁调用的小函数中。当函数被声明为内联时，编译器会尝试在每个调用函数的地方都“内联”这个函数，即==将函数体的代码直接插入到调用位置，从而消除常规函数调用所带来的额外开销==。

## 7.1 内联特性

> 空间换时间
>
> inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建议：将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、频繁调用的函数 采用inline修饰，否则编译器会忽略inline特性。
>
> 不建议声明和定义分离，分离会导致链接错误。

## 7.2 内联函数的使用

```c++
inline void f(){}
```

## 7.3 内联与宏定义

> 宏是预处理器的指令，它在编译之前将宏替换为其定义。
>
> 宏没有返回类型，参数类型，类型检查，作用域规则，因为它只是一个文本替换

## 7.4 相关面试题

### （1）宏的优缺点

> 优点：
>
> 一些微小的操作可以通过宏实现以提供最小的性能开销
>
> 通过宏，可以避免重复的代码片段，尤其是在多次使用的小段代码中。
>
> 缺点：
>
> 当程序出现问题时，宏会使得调试变得困难，因为宏展开后的代码可能与原始代码看起来完全不同。
>
> 由于宏只是简单的文本替换，没有类型检查，这可能导致类型不匹配或其他未预期的问题
>
> 过多使用宏可能导致代码难以理解和维护。

### （2）C++哪些可以替代宏

> **内联函数**：对于简单的函数，内联函数可以作为宏的替代品。它们提供了类型安全，易于调试，且有可能比宏更高效。
>
> **枚举**：对于定义一组相关的常量值，枚举是一个更好的选择
>
> **常量**：对于常量值，使用`const`或`constexpr`替代`#define`是更好的选择。

# 八、auto

> 在C++11及之后的版本中，`auto`被用作类型推导的工具。编译器可以基于初始化的值自动推断出变量的类型。

## 8.1 auto特性

> 使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。
>
> 因此auto并非是一种“类型”的声明，而是一个==类型声明时的“占位符”==，编译器在编译期会将auto替换为 变量实际的类型。

## 8.2 auto的使用

### 8.2.1 声明指针

```c++
int x = 10;
auto *ptr = &x; //或者也可以用auto ptr=&x;两者在使用上是相同的
*ptr=2;
```



### 8.2.2 声明引用

```c++
int y = 20;
auto &ref = y;  

const int z = 30;
const auto &const_ref = z;  
```



### 8.2.3 声明返回值

> 从C++14开始，你可以使用`auto`作为函数的返回类型，这意味着函数的返回类型是由其返回语句推导出来的

```c++
auto add(int a, int b) {
    return a + b;  // The return type is deduced to be int
}
```

### 8.2.4 不能使用的场景

#### （1）函数参数

> 编译过程中，无法通过函数参数形成唯一的函数名称
>
> 注意：C++20引入了概念和约束，它们允许函数模板参数以类似`auto`的方式声明。

#### （2）数组

> 尽管可以使用`auto`从数组类型推导出指针类型，但==不能使用`auto`来定义新的数组==。

```c++
int arr1[5] = {1, 2, 3, 4, 5};
auto arr2[5] = arr1;  // Error

```

# 九、范围for

> C++11引入了范围`for`循环，它提供了一种简洁且更可读的方式来遍历容器或其他可以进行范围遍历的对象。

## 9.1 范围for的使用

```cpp
for (declaration : expression) {
    statement;
}
```

> 其中，`declaration`表示每次迭代中的元素的声明，`expression`是一个可以返回遍历范围的对象。
>

## 9.2 注意事项

> ==**使用引用来避免拷贝**==：如果不想在每次迭代时拷贝容器中的元素，可以使用引用。例如，`for (const auto& item : items)`。
>
> ==**范围`for`循环要求提供的表达式必须有`begin()`和`end()`成员函数**==，或者全局范围内必须有适当的`begin()`和`end()`自由函数。这意味着用户定义的类型也可以使用范围`for`循环，只要这些函数是可用的。
>
> ==**避免在范围`for`循环内修改容器的大小**==：这样做可能会导致未定义的行为。

# 十、nullptr

### 10.1 nullptr

> **类型安全**：`nullptr` 是C++11引入的新关键字，用于表示空指针。它有自己的类型：`std::nullptr_t`，可以被隐式转换为所有指针类型。
>
> **避免歧义**：在函数重载的上下文中，`nullptr` 能提供一个明确的指针类型，从而避免歧义。
>
> ```cpp
> void foo(int);
> void foo(char *);
> foo(nullptr);  // Calls foo(char*), not foo(int)
> ```
>
> **不是整数类型**：你不能将 `nullptr` 转换为整数类型，除了 `bool`。

### 10.2 NULL

> **来自C语言**：`NULL` 是C语言中的宏，用于表示空指针。
>
> **可能的问题**：在C++中，==`NULL` 往往定义为 `((void*)0)` 或者直接为 `0`==。由于这种定义，`NULL` 实际上是一个整数，而不是一个真正的空指针常量。这可能会导致类型推断和函数重载的问题。
>
> ```cpp
> void foo(int);
> void foo(char *);
> foo(NULL);  // Might call foo(int) depending on the definition of NULL
> ```
>
> **不完全安全**：==由于 `NULL` 可能只是一个整数零==，它可能不适合于所有的指针类型，这有时可能导致不期望的行为或编译错误。

# 十一、static成员

> `static` 在C++的类上下文中有特殊的意义。当成员在类中被声明为 `static` 时，它不再与类的特定对象关联，而是与类本身关联。换句话说，不论你创建了多少该类的实例，`static` 成员只有一个实例。
>
> static 成员的存在时间从它们被创建直到程序结束。

## 11.1 特性

### （1）`static` 成员变量

> - 对于每个类，`static` 数据成员只有一个副本，而不是每个对象都有一个副本，所有对象共享同一个 `static` 成员变量。
> - 需要在类定义之外分配并初始化静态数据成员。
>

### （2） `static` 成员函数
> - ==`static` 成员函数只能访问静态数据成员或其他静态成员函数==，它们无法访问类的非静态成员。
> - 你可以在不创建类对象的情况下调用静态成员函数。
> - 静态成员函数中没有 `this` 指针，因为它们与特定的对象无关。
>



## 11.2 相关面试题

### （1）**静态成员函数可以调用非静态成员函数吗？**

> 不可以。静态成员函数是与类关联的，而不是与类的某个具体对象关联的，所以它没有 `this` 指针。因为非静态成员函数需要一个对象的上下文（通常通过 `this` 指针提供）来访问其数据成员和函数，静态成员函数在没有特定对象的情况下无法调用非静态成员函数。

### （2）**非静态成员函数可以调用类的静态成员函数吗？**

> 可以。非静态成员函数可以调用静态成员函数，因为静态成员函数与类关联，而不是与具体对象关联。调用静态成员函数不需要特定的对象上下文。



# 十二、友元

> 友元的设计初衷是为了使某些函数或类能够访问其他类的私有或受保护成员。这在某些特定情境下是很有用的，如进行某种特定操作（例如，重载操作符）时。但过度使用友元可能会破坏类的封装特性，因此应当谨慎使用。

## 12.1 友元函数

> - 当一个函数被声明为类的友元时，它可以访问该类的私有和受保护的成员。
> - 友元函数不是类的成员，也不受任何类的访问修饰符限制。
> - 友元函数的声明通常出现在类定义的公共部分，但可以在私有或受保护部分。

## 12.2 友元类

> - 当一个类被声明为另一个类的友元时，友元类的所有成员函数都可以访问另一个类的私有和受保护的成员。
> - 友元关系不是传递的。
> - 友元关系不是双向的。
> - 友元关系不是继承的。

