# 学习目标

> 认识网络字节序等网络编程中的基本概念
>
> 学习socket api的基本用法
>
> 能够实现一个简单的udp客户端/服务器
>
> 能够实现一个简单的tcp客户端/服务器(单连接版本, 多进程版本, 多线程版本)
>
> 理解tcp服务器建立连接, 发送数据, 断开连接的流程

# 一、网络字节序

> 网络数据流有大端小端之分
>
> 网络数据流的地址应这样规定：==先发出的数据是低地址,后发出的数据是高地址==

网络字节序（Network Byte Order）是在网络上发送数据时使用的字节序或字节顺序的一种约定。它确保了在不同的硬件和操作系统平台之间传输数据时，数据的解释方式是一致的，从而实现了不同计算机系统之间的通信兼容性。

### 1.1 简述TCP/IP协议

> ==TCP/IP协议规定网络数据流应采用大端字节序,即低地址高字节==.  不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据; 如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;

### 1. 2  网络字节序和主机字节序的转换

> 当我们进行网络编程时，需要将==主机字节序的数据转换为网络字节序==，反之亦然。为了解决这个问题，我们通常使用一些专门的函数进行字节序的转换。这些函数包括：
>
> 1. **`htonl`**：将一个无符号（32）长整形数从主机字节序转换为网络字节序。
> 2. **`ntohl`**：将一个无符号（32）长整形数从网络字节序转换为主机字节序。
> 3. **`htons`**：将一个无符号（16）短整形数从主机字节序转换为网络字节序。
> 4. **`ntohs`**：将一个无符号（16）短整形数从网络字节序转换为主机字节序。
>
> 这些函数的名字中的 "h" 表示 "host"，"n" 表示 "network"，"s" 表示 "short"，"l" 表示 "long"。例如，`htonl` 的全名是 "host to network long"，意思是将一个长整形数从主机字节序转换为网络字节序。
>

# 二、套接字

套接字（Socket）是计算机网络通信的基本抽象概念，==提供了在网络上进行数据交换的机制==。它是一个编程接口（API），==位于应用层和传输层之间==，使得应用程序可以通过标准的网络协议进行数据交换，无需关心网络细节。

## 1.套接字类型

**流套接字（Stream Sockets）**：基于TCP（传输控制协议），提供面向连接、可靠的字节流服务。数据按照发送的顺序到达，没有边界，确保数据不会丢失或重复。

**数据报套接字（Datagram Sockets）**：基于UDP（用户数据报协议），提供无连接、不可靠的消息服务。数据以独立的消息形式发送，有边界，可能会丢失或重复。

## 2.协议簇

协议簇（Protocol Family）是操作系统网络编程接口中==用于指定网络通信的协议范围==的一个概念。在创建套接字（socket）时，协议簇决定了套接字可以使用的地址类型、底层网络协议，以及因此而可能的通信特性和范围。协议簇的选择直接影响了网络程序的兼容性、可用性和性能。

常见的协议簇

- **`AF_INET`**：IPv4互联网协议簇。`AF`代表Address Family。使用32位地址。
- **`AF_INET6`**：IPv6互联网协议簇。使用128位地址，解决了IPv4地址耗尽的问题，同时引入了多项改进。
- **`AF_UNIX`（或`AF_LOCAL`）**：本地通信协议簇，用于同一台计算机上的进程间通信（IPC），通过文件系统中的路径名标识。
- **`AF_PACKET`**：直接接入底层网络设备的协议簇，用于实现底层协议如以太网通信。
- **`AF_NETLINK`**：用于内核与用户空间进程间的通信。

## 3.常用api

### (1) socket

`socket`函数用于==创建一个套接字==，它是网络通信的端点。

```c
int socket(int domain, int type, int protocol);
```

- **domain**：指定使用哪个底层协议族，常用的有`AF_INET`（IPv4网络协议）、`AF_INET6`（IPv6网络协议）。
- **type**：指定套接字类型，常用的有`SOCK_STREAM`（流式套接字，对应TCP）、`SOCK_DGRAM`（数据报套接字，对应UDP）。
- **protocol**：指定具体协议，通常设置为0，表示使用默认协议（TCP对应`SOCK_STREAM`，UDP对应`SOCK_DGRAM`）。

### (2) bind

`bind`函数==将套接字绑定到一个地址和端口上==。

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- **sockfd**：由`socket`函数返回的套接字文件描述符。
- **addr**：指向`sockaddr`结构体的指针，该结构体包含了地址和端口信息。
- **addrlen**：`addr`结构体的大小。

#### 1）struct sockaddr

`struct sockaddr` 是一个通用的套接字地址结构，==用于保存网络地址信息==。这个结构在 `<sys/socket.h>` 头文件中定义。它被设计为一个通用的、可以处理任何类型的地址的结构，包括但不限于 IP 地址。

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230729103926538.png" alt="image-20230729103926538" style="zoom: 50%;" />

下面是这个结构在大多数系统中的定义：

```c
struct sockaddr {
    unsigned short sa_family;  // address family, AF_xxx
    char sa_data[14];          // 14 bytes of protocol address
};
```

`sa_family` 字段表示地址的类型，例如 `AF_INET` 表示 IPv4 地址，`AF_INET6` 表示 IPv6 地址。这个字段告诉系统如何解析 `sa_data` 字段中的内容。

`sa_data` 字段包含了实际的地址信息，但是因为它是一个字符数组，所以不能直接用于访问 IP 地址或者端口号。

因为 `struct sockaddr` 的通用性，一般我们在实际编程中不会直接使用它，而是==使用特定协议的地址结构==，例如 `struct sockaddr_in`（用于 IPv4），然后在需要 `struct sockaddr` 作为参数的函数调用中进行类型转换。

### (3) recvfrom

`recvfrom`函数用于==接收UDP数据报==。

```c
codessize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
```

- **sockfd**：套接字文件描述符。
- **buf**：接收数据的缓冲区。
- **len**：缓冲区的长度。
- **flags**：指定调用方式，通常设置为0。
- **src_addr**：（可选）指向`sockaddr`结构体的指针，==用于存储发送方的地址信息==。
- **addrlen**：（可选）`src_addr`结构体的大小。

### (4) sendto

`sendto`函数用于==发送UDP数据报==。

```c
codessize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);
```

- **sockfd**、**buf**、**len**、**flags**：同`recvfrom`。
- **dest_addr**：指向包含==目的地地址信息==的`sockaddr`结构体的指针。
- **addrlen**：`dest_addr`结构体的大小。

### (5)  listen

`listen`函数使得一个套接字==进入监听状态，等待客户端的连接请求==（仅限于TCP）。

```c
int listen(int sockfd, int backlog);
```

- **sockfd**：套接字文件描述符。
- **backlog**：决定了套接字可以排队的最大连接数。

### (6) connect

`connect`函数==用于建立与TCP服务器的连接==。

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- **sockfd**、**addr**、**addrlen**：同`bind`。

### (7) accept

`accept`函数==接受客户端的连接请求==（仅限于TCP），并==返回一个新的套接字文件描述符用于与客户端通信==。

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

- **sockfd**：处于监听状态的套接字文件描述符。
- **addr**：（可选）用于存储客户端地址信息的`sockaddr`结构体指针。
- **addrlen**：（可选）`addr`结构体的大小。

## 4.套接字操作流程

套接字的基本操作流程可以分为服务器端和客户端：

#### 服务器端

1. **创建套接字**：使用`socket()`函数创建一个套接字。
2. **绑定地址**：使用`bind()`函数将套接字绑定到一个地址和端口上。
3. **监听连接**：对于流套接字，使用`listen()`函数监听连接请求。
4. **接受连接**：使用`accept()`函数接受一个连接请求，这将返回一个新的套接字，用于与客户端的通信。
5. **数据交换**：使用`send()`和`recv()`函数（或`write()`和`read()`函数）进行数据发送和接收。
6. **关闭套接字**：使用`close()`函数关闭套接字。

#### 客户端

1. **创建套接字**：使用`socket()`函数创建一个套接字。
2. **建立连接**：对于流套接字，使用`connect()`函数与服务器建立连接。
3. **数据交换**：使用`send()`和`recv()`函数（或`write()`和`read()`函数）进行数据发送和接收。
4. **关闭套接字**：使用`close()`函数关闭套接字。

# 三、UDP协议

UDP（User Datagram Protocol，用户数据报协议）是一种无连接的网络传输协议，位于OSI模型的传输层，与TCP（传输控制协议）并列。UDP使得计算机应用程序可以在网络上发送封装在IP（互联网协议）数据报中的消息，而不需要在通信端点之间建立连接。由于其简单性和低开销，UDP常用于那些对==实时性要求高、可以容忍一定数据丢失的应用，如视频流、音频流和在线游戏==。

## 1.特点

- **无连接**：UDP不需要在通信前建立连接，发送数据之前不需要进行三次握手，减少了开销和延迟。
- **不可靠传输**：UDP不保证数据的可靠到达，也就是说，数据包（数据报）可能会丢失、重复或乱序到达，需要应用程序自己处理这些问题。
- **无拥塞控制**：UDP不进行拥塞控制，即使网络条件不好，也会以相同的速率发送数据，这可能导致网络拥塞。
- **支持广播和多播**：UDP支持向多个接收者同时发送数据，即广播和多播。
- **效率高**：由于缺少连接建立、可靠性保证和拥塞控制等机制，UDP的头部开销小，传输效率高。

## 2.使用场景

- **实时应用**：对于实时应用（如VoIP通话、在线视频会议和实时多人游戏），UDP的低延迟特性比可靠性更重要。
- **简单查询**：一些简单的请求-响应协议（如DNS查询）使用UDP，因为它可以快速交换小消息。
- **广播和多播**：需要将消息发送给多个接收者的应用会使用UDP，因为TCP不支持广播和多播。

## 3.缺点

- **数据可能丢失**：UDP不保证传输的可靠性，应用程序需要自己实现错误检测和恢复机制。
- **顺序可能错乱**：接收到的数据包顺序可能与发送顺序不同，应用程序需要自己处理数据重组。

## 4.消息路由

消息路由（Message Routing）是在分布式系统、网络通信、消息队列系统等领域中用于决定如何将消息从一个源传递到一个或多个目标的过程。消息路由的实现可以基于静态或动态的路由策略，旨在提高消息传输的效率，确保消息准确无误地到达预定的接收者。

## 5.模拟实现简单UDP

这个程序可以接收来自多个客户端的消息，并将每个消息转发给所有已知的客户端。每次有新的客户端发送消息时，它都会被添加到服务器的已知客户端列表中

#### （1）日志信息

```c++
#pragma once
#include <cstdio>
#include <ctime>
#include <cstdarg>
#include <cassert>
#include <cassert>
#include <cstring>
#include <cerrno>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#define DEBUG 0
#define NOTICE 1
#define WARINING 2
#define FATAL 3

const char *log_level[] = {"DEBUG", "NOTICE", "WARINING", "FATAL"};

#define LOGFILE "server.log"

class Log
{
public:
    Log():logFd(-1)
    {}
    void enable()
    {
        umask(0);
        logFd = open(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, 0666);
        assert(logFd != -1);
        dup2(logFd, 1);
        dup2(logFd, 2);
    }
    ~Log()
    {
        if(logFd != -1) 
        {
            fsync(logFd);
            close(logFd);
        }
    }
private:
    int logFd;
};

// logMessage(DEBUG, "%d", 10);
void logMessage(int level, const char *format, ...)
{
    assert(level >= DEBUG);
    assert(level <= FATAL);

    char *name = getenv("USER");

    char logInfo[1024];
    va_list ap; // ap -> char*
    va_start(ap, format);
    vsnprintf(logInfo, sizeof(logInfo) - 1, format, ap);
    va_end(ap); // ap = NULL
    FILE *out = (level == FATAL) ? stderr : stdout;
    fprintf(out, "%s | %u | %s | %s\n",
            log_level[level],
            (unsigned int)time(nullptr),
            name == nullptr ? "unknow" : name,
            logInfo);

    fflush(out); // 将C缓冲区中的数据刷新到OS
    fsync(fileno(out));   // 将OS中的数据尽快刷盘
}
```

#### （2） 服务端

使用UDP协议的简易聊天服务器，允许多个客户端向服务器发送消息，服务器则将收到的消息广播给所有已知的客户端。以下是程序的主要组成部分和流程：

**主要组件解释**

- `udpServer` 类：封装了UDP服务器的主要逻辑，包括初始化（创建套接字、绑定IP和端口）、接收消息、检查客户端是否已知（在线）、以及消息的路由。
- `init` 方法：创建UDP套接字，并将其绑定到指定的IP地址和端口号。如果没有指定IP地址，将使用`INADDR_ANY`，表示接受任何IP地址的连接，无论主机有多少个网络接口（无论是物理网络接口还是虚拟网络接口），包括公网IP、私网IP等，只要有数据发送到了指定的端口，无论是通过哪个网络接口，这个套接字都可以接收到数据。
- `start` 方法：服务器的主循环，接收来自客户端的消息，并将消息广播给所有已知的客户端。
- `checkOnlineUser` 方法：检查发送消息的客户端是否已经记录在服务器的已知客户端列表中，如果不是，则添加到列表。
- `messageRoute` 方法：将接收到的消息构建成统一格式后，广播给所有已知的客户端。

**程序流程**

1. 程序启动时，检查命令行参数以确保提供了必要的端口号（可选地提供IP地址）。
2. 创建`udpServer`对象，并使用提供的端口号（和IP地址）进行初始化。
3. 调用`init`方法创建UDP套接字，并绑定到指定的端口（和IP地址）。
4. 进入主循环（`start`方法），不断接收来自客户端的消息。
    - 接收到消息后，首先记录或确认发送者的身份。
    - 然后将消息格式化，并广播给所有已知的客户端。
5. 对于每个发送消息的客户端，如果它是第一次发送消息，则其地址信息被记录下来，视为“已知客户端”。

```c++
//用于显示如何使用该程序。用户应当至少提供端口号，可以选择性地提供 IP 地址。
static void Usage(const std::string proc)
{
    std::cout << "Usage:\n\t" << proc << " port [ip]" << std::endl;
}


class udpServer
{
public:
    //构造函数用于初始化服务器的 IP 地址、端口号和套接字描述符。
    udpServer(int port,std::string ip="")
    :_port((uint16_t)port)
    ,_ip(ip)
    ,_sockfd(-1){}
    ~udpServer(){}
    //创建一个 UDP 套接字，并绑定给定的 IP 和端口。
    void init()
    {
        //1 创建套接字
        //udp是采用IPv4,无连接方式通信
        //IPv4：使用 32 位地址空间来标识互联网上的设备。由四个十进制数（每个数范围从 0 到 255）组成，例如 192.168.0.1
        _sockfd=socket(AF_INET,SOCK_DGRAM,0);
        //如果失败返回-1
        if(_sockfd==-1)
        {
            logMessage(FATAL,"%s:%d",strerror(errno),_sockfd);
            exit(-1);
        }
        logMessage(DEBUG,"socket create sucessed:%d",_sockfd);
        //2 网络信息填充及绑定
        //2.1 添加网络信息（ip、port）
        //sockaddr_in网络通信 sockaddr_un本地通信
        struct sockaddr_in local;
        bzero(&local,sizeof(local));
        //地址族（Address Family），指示地址的类型，常见的值包括 AF_INET（IPv4）、AF_INET6（IPv6）
        local.sin_family=AF_INET;
        //从主机字节序转换为网络字节序
        local.sin_port=htons(_port);
        //INADDR_ANY，表示绑定到任意可用的 IP 地址。这通常用于服务器程序，表示接受来自任意 IP 地址的连接。
        //自动进行从主机字节序转换为网络字节序
        local.sin_addr.s_addr=_ip.empty()?INADDR_ANY:inet_addr(_ip.c_str());
        //2.2 绑定网络信息
        //sockaddr_in--->sockaddr根据地址簇进行区分
        if(bind(_sockfd,(const sockaddr *)&local,sizeof(local))==-1)
        {
            logMessage(FATAL,"bind:%s:%d",strerror(errno),_sockfd);
            exit(-2);
        }
        logMessage(DEBUG, "socket bind success: %d", _sockfd);
    }
    
    
    //这是服务器的主要循环，用于接收消息，记录发送消息的客户端，并将消息路由给所有已知的客户端。
    void start()
    {
        //输入缓冲区
        char bufferIn[1024];
        //输出缓冲区
        char bufferOut[1024];
        while(true)
        {
            //peer用于记录远程传输端的ip、port
            struct sockaddr_in peer;
            socklen_t len = sizeof(peer);
            bzero(&peer,sizeof(peer));
            //接受信息
            ssize_t s=recvfrom(_sockfd,bufferIn,sizeof(bufferIn)-1,0,(sockaddr*)&peer,&len);
            if(s>0)
            {
                bufferIn[s]='\0';
            }
            uint16_t peerPort=ntohs(peer.sin_port);
            std::string peerIp=inet_ntoa(peer.sin_addr);
            //读取成功
            logMessage(NOTICE, "[%s:%d]# %s", peerIp.c_str(), peerPort, bufferIn);
            //检查在线成员，有就添加
            checkOnlineUser(peerIp, peerPort, peer);
            //消息路由，给所有在线成员发送消息
            messageRoute(peerIp, peerPort,bufferIn);
        }
    }
private:
    //检查发送消息的客户端是否已知。如果不是，则将其添加到已知客户端列表中。
    void checkOnlineUser(std::string peerIp, uint16_t peerPort,struct sockaddr_in peer)
    {
        std::string key=peerIp;
        key+=":";
        key+=std::to_string(peerPort);
        //查询在线成员
        auto iter =_users.find(key);
        if(iter == _users.end())
        {
            _users.insert({key, peer});
        }
    }
    
    
    //将收到的消息路由给所有已知的客户端。
    void messageRoute(std::string ip, uint16_t port, std::string info)
    {

        std::string message = "[";
        message += ip;
        message += ":";
        message += std::to_string(port);
        message += "]# ";
        message += info;
        for(auto &user : _users)
        {
            sendto(_sockfd, message.c_str(), message.size(), 0, (struct sockaddr*)&(user.second), sizeof(user.second));
        }
    }
private:
    //端口号
    uint16_t _port;
    //ip地址
    std::string _ip;
    //套接字
    int _sockfd;
    std::unordered_map<std::string,sockaddr_in> _users;
};


int main(int argc,char *argv[])
{
    if (argc != 2 && argc != 3) 
    {
        Usage(argv[0]);
        exit(3);
    }
    uint16_t port = atoi(argv[1]);
    std::string ip;
    if (argc == 3)
    {
        ip = argv[2];
    }
    Log enable();
    udpServer svr(port, ip);
    svr.init();
    svr.start();
    return 0;
}
```

#### （3）客户端

**主要组件解释**

1. **udpClient 类**：这个类封装了UDP客户端的所有功能，包括创建套接字、设置服务器地址、发送和接收数据。
    - **构造函数**：接受服务器的IP地址和端口号作为参数，创建UDP套接字，并初始化服务器地址结构体`sockaddr_in`。
    - **析构函数**：关闭已打开的套接字。
    - **start 方法**：启动客户端的主要循环，包括发送数据到服务器和在一个独立线程中接收服务器的响应。
    - **recverAndPrint 静态方法**：在新线程中执行，循环接收服务器发送的数据，并打印到标准输出。

2. **Usage 函数**：打印如何使用这个程序的说明，告诉用户需要提供服务器IP地址和端口号作为命令行参数。

**程序流程**

1. **程序启动**：`main`函数是程序的入口点。首先检查命令行参数的数量，如果不符合要求，调用`Usage`函数并退出。

2. **创建 udpClient 实例**：使用命令行参数（服务器IP和端口号）创建`udpClient`类的实例。

3. **初始化套接字和服务器地址**：在`udpClient`的构造函数中，创建UDP套接字，并使用提供的IP地址和端口号设置服务器地址信息。

4. **启动客户端**：调用`udpClient`实例的`start`方法开始客户端的运行。这个方法首先创建一个线程用于接收和打印服务器发来的消息，然后进入一个无限循环，等待用户输入消息并发送给服务器。

5. **接收和打印消息**：`recverAndPrint`方法在它自己的线程中循环运行，使用`recvfrom`函数接收来自服务器的消息，然后打印这些消息。当接收到消息时，显示格式为"server echo# "，后面跟着服务器发送的原始消息内容。

6. **发送消息到服务器**：在`start`方法的主循环中，程序读取用户从标准输入输入的字符串（消息），并使用`sendto`函数将消息发送到服务器。

7. **程序结束和资源清理**：当程序需要结束时（通常是用户手动停止），`udpClient`的析构函数会被调用，关闭打开的套接字资源，确保资源得到适当清理。

```c++
#include <iostream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>

class udpClient {
public:
    udpClient(const std::string& serverIp, uint16_t serverPort)
        : _serverIp(serverIp), _serverPort(serverPort), _sockfd(-1) {
        // 在构造函数中创建套接字
        _sockfd = socket(AF_INET, SOCK_DGRAM, 0);
        if (_sockfd == -1) {
            std::cerr << "socket create failed: " << strerror(errno) << std::endl;
            exit(-1);
        }
        // 设置服务器地址
        memset(&_server, 0, sizeof(_server));
        _server.sin_family = AF_INET;
        _server.sin_port = htons(serverPort);
        _server.sin_addr.s_addr = inet_addr(serverIp.c_str());
    }

    ~udpClient() {
        if (_sockfd != -1) {
            close(_sockfd);
        }
    }

    void start() {
        //多线程用于接收消息
        pthread_t t;
        pthread_create(&t, nullptr, recverAndPrint, (void *)&_sockfd);

        std::string buffer;
        while (true) {
            std::cerr << "Please Enter# ";
            std::getline(std::cin, buffer);
            // 发送消息给server
            sendto(_sockfd, buffer.c_str(), buffer.size(), 0, (const sockaddr*)&_server, sizeof(_server));
        }
    }

private:
    static void *recverAndPrint(void *args) {
        int sockfd = *(int *)args;
        char buffer[1024];
        while (true) {
            ssize_t s = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, nullptr，nullptr);
            if (s > 0) {
                buffer[s] = '\0';
                std::cout << "server echo# " << buffer << std::endl;
            }
        }
        return nullptr;
    }
private:
    int _sockfd;
    struct sockaddr_in _server;
    std::string _serverIp;
    uint16_t _serverPort;
};

// 用于显示如何使用该程序。用户应当至少提供端口号，可以选择性地提供 IP 地址。
static void Usage(const std::string& proc) {
    std::cout << "Usage:\n\t" << proc << " serverIp serverPort" << std::endl;
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        Usage(argv[0]);
        return 3;
    }
    std::string serverIp = argv[1];
    uint16_t serverPort = atoi(argv[2]);

    udpClient client(serverIp, serverPort);
    client.start();
    return 0;
}

```



## 6.常用的测试指令

#### 3.2.1 netstat

> `netstat` 命令用于显示网络连接、路由表、接口统计等信息。
>
> `netstat -lnup` 命令的具体作用是显示与UDP相关的正在监听的套接字及其关联的进程。让我们解释这些选项：
>
> - `-l`: 仅显示正在监听的套接字。
> - `-n`: 显示数值地址，而不是解析主机名。
> - `-u`: 显示UDP连接。
> - `-p`: 显示每个套接字所属的进程ID和程序名称。
>
> 注意本地环回ip：127.0.0.1  表示本主机通信

#### 3.2.2 ps

> **ps axj**:
>
> - `a`: 显示所有进程（包括所有用户的进程）。
> - `x`: 显示没有控制终端的进程。例如后台进程。
> - `j`: 显示扩展格式的信息，包括进程组 ID (PGID)、会话 ID (SID)、控制终端 (TTY)，以及进程与会话的关联状态。
>
> 使用 `axj` 选项可以得到一个详细的进程列表，其中包含了与进程相关的会话和进程组信息。
>
> **ps -aL**:
>
> - `-a`: 显示所有进程（包括其他用户的进程）。
> - `-L`: 显示所有的线程，而不仅仅是进程。在现代操作系统中，一个进程可以包含多个执行线程。
>
> 使用 `-aL` 选项可以查看所有进程的所有线程。

# 四、TCP协议

TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它是互联网协议套件的核心协议之一，设计用于在网络通信中提供可靠的、有序的和错误检测机制的数据传输服务。

TCP协议确保数据包的顺序传输和数据的完整性，它通过在数据传输过程中实现错误检测、数据重传、流量控制和拥塞控制等机制来完成这些任务。TCP建立连接时，使用三次握手协议来初始化连接参数，断开连接时，则采用四次挥手协议。

## 1.特点

1. **可靠性**：TCP提供高可靠性数据传输。通过序列号、确认应答、重传机制等，确保数据完整、有序地到达目的地。
2. **面向连接**：在数据传输之前，TCP 需要建立连接，通信双方需要进行三次握手来确认连接已建立。
3. **基于字节流**：TCP将应用层数据看作一连串无结构的字节流，数据的发送和接收就像读写文件一样。
4. **流量控制**：TCP使用滑动窗口协议进行流量控制，防止快速发送方淹没慢速接收方。
5. **拥塞控制**：TCP实现了几种拥塞控制技术（如慢启动、拥塞避免、快速重传和快速恢复）以减少网络拥塞。

## 2.使用场景

TCP广泛用于需要高可靠性数据传输的应用，如：

- **Web浏览**：HTTP和HTTPS协议基于TCP，确保网页内容准确传输。
- **文件传输**：如FTP（文件传输协议）利用TCP保证文件的准确无误传输。
- **电子邮件**：SMTP（用于邮件发送）、POP和IMAP（用于邮件接收）协议都是基于TCP的。
- **远程访问**：如SSH（安全壳协议）和Telnet都使用TCP来保证命令和数据的可靠传输。

## 3.缺点

- **速度慢于UDP**：由于建立连接、确认应答等过程，TCP的数据传输速度不如UDP。
- **头部开销大**：TCP头部最小20字节，加上各种选项可能更大，相比之下UDP头部只有8字节。
- **实时性差**：TCP的重传机制和流量控制会导致延迟，不适合对实时性要求极高的应用，如实时视频会议或在线游戏。

总的来说，TCP通过其复杂的控制机制提供了一种可靠的数据传输方式，适用于大多数需要确保数据完整性和准确性的应用场景，但在需要高速度和实时性的场合，可能不是最佳选择。

## 4.模拟实现简单TCP

这个程序可以接收来自多个客户端的任务，并将任务添加到线程池中处理。

#### （1）任务

```c++
#include <iostream>
#include <string>
#include <functional>
class Task
{
private:
    //std::function 是一个类模板，它为任何可调用对象（包括函数、lambda、函数对象和成员函数指针）提供了一个通用的类型。
    using callback_t=std::function<void(int,uint16_t,std::string)>;//typedef std::function<void(int,uint16_t,std::string)> callback_t;
public:
    Task():_sock(-1), _port(-1){}
    Task(int sock, uint16_t port, std::string ip, callback_t func)
    :_sock(sock),  _port(port), _ip(ip),_func(func)
    {}
    ~Task(){}
    void operator () ()
    {
        logMessage(DEBUG, "线程ID[%p]处理%s:%d的请求 开始啦...",pthread_self(), _ip.c_str(), _port);
        _func(_sock, _port, _ip);
        logMessage(DEBUG, "线程ID[%p]处理%s:%d的请求 结束啦...",pthread_self(), _ip.c_str(), _port);
    }
private:
    int _sock;
    uint16_t _port;
    std::string _ip;
    callback_t _func;
};
```



#### （2）服务端

基于TCP的服务器类 `ServerTcp`，主要用于处理网络连接和数据传输

**主要组件**

1. **ServerTcp类**: 封装了TCP服务器的行为，包括初始化、接受连接和处理数据转换服务。
2. **初始化 (`init` 方法)**: 创建监听socket，绑定IP地址和端口，然后开始监听网络连接。
3. **循环监听 (`loop` 方法)**: 持续等待客户端连接，接收连接后，将创建的socket传递给线程池处理。
4. **数据转换服务 (`transService` 方法)**: 一种服务例程，接收客户端发送的数据，将所有小写字母转换为大写字母，然后将结果返回给客户端。
5. **ThreadPool**: 用于管理多个服务请求的线程池，增加并发处理能力。
6. **日志记录 (`logMessage` 函数)**: 用于记录服务器操作的日志信息，有助于调试和监控。
7. **主函数 (`main`)**: 解析命令行参数，创建 `ServerTcp` 实例，初始化并启动服务器循环。

**程序流程**

1. **启动程序**: 运行时需要指定端口和（可选的）IP地址作为命令行参数。
2. **初始化服务器**: 创建TCP监听socket，设置IP和端口，并开始监听连接。
3. **进入主循环**: 不断接受新的连接请求。
4. **为每个连接创建任务**: 接受连接后，为每个客户端创建一个 `Task` 对象，并将其添加到线程池中。这个任务会执行 `transService` 方法，处理数据转换服务。
5. **处理客户端请求**: 对于每个连接，读取客户端发送的数据，执行大小写转换，然后将转换后的数据发送回客户端。如果接收到特定的退出指令（如"quit"），或者遇到读取错误，则关闭连接。

```c++
#include "util.hpp"
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <pthread.h>

class ServerTcp
{
public:
    ServerTcp(uint16_t port, const std::string &ip = "") : port_(port), ip_(ip), listenSock_(-1),_tp(nullptr)
    {}
    ~ServerTcp()
    {}

public:
    void init()
    {
        // 1 创建socket
        /*
        	PF_INET和AF_INET相同
        	SOCK_STREAM是由于TCP面向字节流
        	注意此时返回的是监听套接字，并不提供服务
        */
        listenSock_ = socket(PF_INET, SOCK_STREAM, 0);
        if (listenSock_ < 0)
        {
            logMessage(FATAL, "socket: %s", strerror(errno));
            exit(SOCKET_ERR);
        }
        logMessage(DEBUG, "socket: %s, %d", strerror(errno), listenSock_);

        // 2. 网络信息填充及绑定
        // 2.1 填充服务器信息
        struct sockaddr_in local; 
        memset(&local, 0, sizeof local);
        local.sin_family = PF_INET;
        local.sin_port = htons(port_);
        ip_.empty() ? (local.sin_addr.s_addr = INADDR_ANY) : (inet_aton(ip_.c_str(), &local.sin_addr));
        // 2.2 绑定服务器信息，从用户栈写入内核
        if (bind(listenSock_, (const struct sockaddr *)&local, sizeof local) < 0)
        {
            logMessage(FATAL, "bind: %s", strerror(errno));
            exit(BIND_ERR);
        }
        logMessage(DEBUG, "bind: %s, %d", strerror(errno), listenSock_);

        // 3  监听socket
        if (listen(listenSock_, 5) < 0)
        {
            logMessage(FATAL, "listen: %s", strerror(errno));
            exit(LISTEN_ERR);
        }
        logMessage(DEBUG, "listen: %s, %d", strerror(errno), listenSock_);
        
        // 创建线程池
        _tp=ThreadPool<Task>::getInstance();
    }

    void loop()
    {
        // 运行线程池
        _tp->start();
        while (true)
        {
            struct sockaddr_in peer;
            socklen_t len = sizeof(peer);
            // 4 获取连接 
            /*
            	此时获得的文件描述符代表提供服务的套接字
            	如果获取链接时退出，那么服务器将无法重启
            	并且注意服务结束后要关闭这个文件描述符，否则会造成内存泄漏
            */
            int serviceSock = accept(listenSock_, (struct sockaddr *)&peer, &len);
            if (serviceSock < 0)
            {
                // 获取链接失败
                logMessage(WARINING, "accept: %s[%d]", strerror(errno), serviceSock);
                continue;
            }
            // 4.1 获取客户端基本信息
            uint16_t peerPort = ntohs(peer.sin_port);
            std::string peerIp = inet_ntoa(peer.sin_addr);

            logMessage(DEBUG, "accept: %s | %s[%d], socket fd: %d",
                       strerror(errno), peerIp.c_str(), peerPort, serviceSock);
   			//创建任务
            /*
            std::bind 是一个函数适配器，它接受一个函数（或成员函数）和一系列参数，然后生成一个新的可调用对象。在这个例子中，std::bind 将 ServerTcp::transService 方法与 this 指针（代表 ServerTcp 类的当前实例）和占位符 std::placeholders::_1、std::placeholders::_2 和 std::placeholders::_3 绑定。这些占位符代表在调用绑定的函数时将传递的参数，它们在这里代表着 sock、clientPort 和 clientIp。
                */
            Task t(serviceSock,peerPort, peerIp,
                   std::bind(&ServerTcp::transService,this,std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));
            //添加到任务队列
            //注意线实际上线程池不适合死循环任务，而是短任务，否则会长时间占用线程
            _tp->push(t);
        }
    }
    
    
    // 大小写转化服务，类的成员函数，有隐藏的this指针
    void transService(int sock,  uint16_t clientPort,const std::string &clientIp)
    {
        assert(sock >= 0);
        assert(!clientIp.empty());
        assert(clientPort >= 1024);
        char inbuffer[BUFFER_SIZE];
        while (true)
        {
            ssize_t s = read(sock, inbuffer, sizeof(inbuffer) - 1); //我们认为我们读到的都是字符串
            if (s > 0)
            {
                inbuffer[s] = '\0';
                if(strcasecmp(inbuffer, "quit") == 0)
                {
                    logMessage(DEBUG, "client quit -- %s[%d]", clientIp.c_str(), clientPort);
                    break;
                }
                logMessage(DEBUG, "trans before: %s[%d]>>> %s", clientIp.c_str(), clientPort, inbuffer);
                // 大小写转化
                for(int i = 0; i < s; i++)
                {
                    if(isalpha(inbuffer[i]) && islower(inbuffer[i])) 
                        inbuffer[i] = toupper(inbuffer[i]);
                }
                logMessage(DEBUG, "trans after: %s[%d]>>> %s", clientIp.c_str(), clientPort, inbuffer);

                write(sock, inbuffer, strlen(inbuffer));
            }
            else if (s == 0)
            {
                //写端退出
                logMessage(DEBUG, "client quit -- %s[%d]", clientIp.c_str(), clientPort);
                break;
            }
            else
            {
                logMessage(DEBUG, "%s[%d] - read: %s", clientIp.c_str(), clientPort, strerror(errno));
                break;
            }
        }
        close(sock); // 关闭服务套接字，防止文件描述符泄漏
        logMessage(DEBUG, "server close %d done", sock);
    }
private:
    int listenSock_;
    uint16_t port_;
    std::string ip_;
    ThreadPool<Task>* _tp;
};

static void Usage(std::string proc)
{
    std::cerr << "Usage:\n\t" << proc << " port ip" << std::endl;
    std::cerr << "example:\n\t" << proc << " 8080 127.0.0.1\n" << std::endl;

}


int main(int argc, char *argv[])
{
    if(argc != 2 && argc != 3 )
    {
        Usage(argv[0]);
        exit(USAGE_ERR);
    }
    uint16_t port = atoi(argv[1]);
    std::string ip;
    if(argc == 3) ip = argv[2];
	Log enable();
    daemonize();
    ServerTcp svr(port, ip);
    svr.init();
    svr.loop();
    return 0;
}
```

#### （3）客户端

```c++
#include "util.hpp"

volatile bool quit = false;

static void Usage(std::string proc)
{
    std::cerr << "Usage:\n\t" << proc << " serverIp serverPort" << std::endl;
    std::cerr << "Example:\n\t" << proc << " 127.0.0.1 8081\n"
              << std::endl;
}

class clientTcp
{
public:
    clientTcp(uint16_t port, const std::string &ip) : _serverPort(port), _serverIp(ip), _sock(-1){}
    ~clientTcp(){}
public:
    void init()
    {
        // 1 创建套接字
        _sock = socket(AF_INET, SOCK_STREAM, 0);
        if (_sock < 0)
        {
            std::cerr << "socket: " << strerror(errno) << std::endl;
            exit(SOCKET_ERR);
        }

        // 2 发起链接请求
        // 2.1 填充远端服务器信息
        struct sockaddr_in server;
        memset(&server, 0, sizeof(server));
        server.sin_family = AF_INET;
        server.sin_port = htons(_serverPort);
        inet_aton(_serverIp.c_str(), &server.sin_addr);
        // 2.2 发起请求，并自动绑定
        if (connect(_sock, (const struct sockaddr *)&server, sizeof(server)) != 0)
        {
            std::cerr << "connect: " << strerror(errno) << std::endl;
            exit(CONN_ERR);
        }
        std::cout << "info : connect success: " << _sock << std::endl;
    }
    void loop()
    {
        std::string message;
        while (!quit)
        {
            message.clear();
            std::cout << "请输入你的消息>>> ";
            std::getline(std::cin, message);
            if (strcasecmp(message.c_str(), "quit") == 0)
                quit = true;

            ssize_t s = write(_sock, message.c_str(), message.size());
            if (s > 0)
            {
                message.resize(1024);
                ssize_t s = read(_sock, (char *)(message.c_str()), 1024);
                if (s > 0)
                    message[s] = 0;
                std::cout << "Server Echo>>> " << message << std::endl;
            }
            else if (s <= 0)
            {
                break;
            }
        }
        close(_sock);
    }
private:
    int _sock;
    uint16_t _serverPort;
    std::string _serverIp;
};

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        Usage(argv[0]);
        exit(USAGE_ERR);
    }
    std::string serverIp = argv[1];
    uint16_t serverPort = atoi(argv[2]);
    clientTcp client(serverPort,serverIp);
    client.init();
    client.loop();
    return 0;
}
```

## 5.守护进程（精灵进程）

守护进程（精灵进程）是后台进程，独立于控制终端并周期性地执行某些任务或等待处理某些事件，不受登录登出的影响。通常用于服务器程序，如邮件服务器、系统日志服务器或任何其他需要在后台运行的程序。

##### （1）会话

> 会话是一个或多个进程组的集合且每个会话都有一个唯一的会话 ID。
>
> 会话开始于用户登录并持续到注销为止。通常每个终端窗口都是一个独立的会话。
>
> 会话的领头进程是创建该会话的进程。当你在终端中登录时，shell 通常是那个会话的领头进程
>
> 一个会话只能有一个领头进程。
>
> 当会话领头进程终止时，该会话中的所有进程都会收到 SIGHUP 信号。
>
> 在给定的会话中，任何时候都只能有一个进程组在前台运行。这意味着它可以从终端接收输入而其他的进程组在后台运行。
>
> 通常，会话的创建与控制终端的分离/获取有关。例如，守护进程通常会调用 `setsid()` 系统调用来开始一个新的会话并摆脱任何控制终端。

##### （2）创建守护进程（daemonize）

> 1. **创建子进程并结束父进程**: 这样可以确保进程不是进程组长，从而使得进程能成功调用setsid()。
> 2. **在子进程中创建一个新会话**: 使用setsid()创建新会话，使进程成为新会话的领头进程。这样可以确保进程不会再有控制终端。
> 3. **改变当前工作目录**: 通常会将当前工作目录更改为根目录，以确保进程不会阻止文件系统被卸载。
> 4. **重设文件权限掩码**: 这通常是为了确保进程可以读写其创建的任何文件。
> 5. **关闭文件描述符**: 进程从其父进程那里继承了文件描述符。不需要这些文件描述符，因此它们应该被关闭。
> 6. **处理信号**: 进程应该正确处理它可能收到的信号，忽略SIGPIPE。

```c++
void daemonize()
{
    int fd = 0;
    // 1 忽略SIGHUP
    signal(SIGHUP, SIG_IGN);
    // 2 让自己不要成为进程组组长
    if (fork() > 0)
        exit(0);
    // 3 设置自己是一个独立的会话
    setsid();
    // 4 更改进程的工作目录到根目录
  	chdir("/");
    // 5 重设文件权限掩码
    umask(0);
    // 6 重定向0,1,2，"/dev/null"为文件黑洞，读不返回，写丢弃
    if ((fd = open("/dev/null", O_RDWR)) != -1) // fd == 3
    {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        // 7 关闭掉不需要的fd
        if(fd > STDERR_FILENO) close(fd);
    }
}
```

##### （3）三种守护进程方案

###### 1）传统模式

###### 2）**使用 `daemon()` 函数**：

>  在某些系统中，有一个 `daemon()` 函数可以用来创建守护进程。基本上封装了上述的传统方法的大部分步骤。

###### 3）**使用 `systemd` 或其他现代初始化系统**： 

> 现代 Linux 系统通常使用 `systemd` 作为其初始化系统。在 `systemd` 中，你可以创建一个服务单元文件来描述你的守护进程，并告诉 `systemd` 如何启动和管理它。当 `systemd` 启动服务时，它会处理创建守护进程所需的大部分步骤。使用这种方法，你可以避免手动编写守护进程的代码，并利用 `systemd` 提供的许多其他功能，如日志记录、资源限制和依赖管理。



## 6.TCP协议通信流程

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230818212304613.png" alt="image-20230818212304613" style="zoom: 80%;" />





### （1）序列号和确认号

序列号（Sequence Number）

- 序列号是TCP连接中发送的每个包的唯一标识，用于保证数据包的顺序性和唯一性。
- 在TCP连接开始时，发送方会随机选择一个初始序列号（ISN: Initial Sequence Number）开始数据传输。

确认号（Acknowledgment Number）

- 确认号是TCP连接中接收方用来告诉发送方，“我期望接收到的下一个数据包的序列号是什么”。它是对收到的数据包的响应。
- 确认号总是期望的下一个序列号，因此，它等于接收到的最后一个数据包的序列号加1。

三次握手过程

1. **SYN**: 第一次握手中，客户端发送一个SYN包（设置SYN标志）到服务器。这个包包含客户端的初始序列号X。
2. **SYN-ACK**: 第二次握手中，服务器收到SYN包后，回复一个SYN-ACK包。这个包同时设置了SYN和ACK标志，其中：
   - ACK标志后面的确认号设置为`X+1`，表示服务器确认收到了序列号为X的SYN包，并期望下一个包的序列号为`X+1`。
   - SYN标志表示这也是一个连接请求，包含服务器的初始序列号Y。
3. **ACK**: 第三次握手中，客户端发送一个ACK包，其确认号设置为`Y+1`，表示客户端确认收到了序列号为Y的SYN包，并期望下一个包的序列号为`Y+1`。

### （2）**三次握手 (建立连接)**

三次握手过程确保双方准备好进行数据传输。这个过程可以简化为以下步骤：

1. **SYN**: 客户端发送一个SYN(Synchronize Sequence Numbers)包到服务器，并进入SYN_SEND状态，等待服务器确认。
   
   - 客户端选择一个随机序列号X开始序列。

2. **SYN-ACK**: 服务器接收到客户端的SYN包，必须确认客户的SYN（ACK=X+1），同时自己也发送一个SYN包（SYN+ACK），即SYN和ACK标志位都被设置。服务器将这个包发送给客户端，以确认收到了客户端的SYN包，并进入SYN_RECV状态。
   
   - 服务器选择自己的随机序列号Y。

3. **ACK**: 客户端接收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=Y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成TCP连接的建立。
   
   - 此时，连接建立，数据传输开始。
   
   
   
   **三次握手的意义**
   
   1. **确认双方的接收与发送能力**：确保双方都具备接收和发送数据的能力。通过三次握手，双方都能确认对方已准备好接收数据，从而开始安全的数据交换。
   2. **同步序列号**：为了保证数据包的顺序，TCP连接的每一方都必须维护一个序列号。三次握手允许双方在连接建立之前同步这个初始序列号，确保数据传输的顺序性和完整性。
   3. **防止旧连接的初始化数据段干扰新连接**：网络中延迟的数据包可能会在不当的时间到达，通过三次握手，可以防止这样的旧数据包干扰新的连接。

### （3）**四次挥手 (断开连接)**

TCP连接的终止则需要四次挥手，过程如下：

1. **FIN**: 当通信的一方完成数据发送任务后，发送一个FIN包，表示没有数据传输了，我要关闭连接了。

2. **ACK**: 另一方收到FIN包后，发送一个ACK包作为应答，并进入CLOSE_WAIT状态。发送方收到这个ACK后，进入FIN_WAIT_2状态。

3. **FIN**: 这一步是对第一步的回应，另一方也发送一个FIN包，表示同意现在关闭连接。

4. **ACK**: 原始发送FIN包的一方接收到对方的FIN包后，发送一个ACK确认包，然后进入TIME_WAIT状态。等待足够的时间以确保对方接收到ACK包后，最终关闭连接。

**四次挥手的意义**

1. **半关闭（Half-close）的支持**：四次挥手允许连接的一方结束其发送操作，而另一方仍然可以发送数据。即允许单方面的关闭操作，为数据传输的灵活性提供了可能。
2. **确保数据完全传输**：通过四次挥手，TCP协议确保在连接断开前，双方都有足够的时间发送并确认所有残留数据（即确保所有在途的数据都能被正确处理）。
3. **避免“TIME_WAIT”状态下的连接重用**：在最后一个ACK发送后，连接的一方会进入TIME_WAIT状态。这个状态持续的时间足够长，确保了这个ACK能够到达另一方。这样做可以避免在新连接中出现旧连接的数据包，提供了一定程度的安全保障。
4. **资源的正确释放**：通过四次挥手，双方都有机会正确地释放连接所占用的资源。这个过程确保了系统资源的有效利用和回收，避免了资源泄露。















