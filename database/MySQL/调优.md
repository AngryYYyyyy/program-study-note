①②③④⑤⑥⑦⑧⑨⑩

# 一、数据库基础

## 1. 范式

### （1）概述

范式是数据库设计中用于减少数据冗余和提高数据整合性的一种方法。通过应用不同级别的范式规则，可以优化表的结构，确保数据的一致性和可维护性。

### （2）三大范式

#### ① 第一范式（1NF）

- **定义**：第一范式要求表的每个字段都是不可分割的最小数据单位。
- **理解**：第一范式强调数据表的原子性，是数据库设计的基础。例如，一张包含`name-age`列的表不符合1NF，因为该列包含了两个属性。将其拆分为`name`和`age`两列，使表符合第一范式。
- **详细要求**：
  1. 确保每一列的原子性，不可再分。
  2. 合并属性相似或相同的列，避免数据冗余。
  3. 每列由基本数据类型组成。
  4. 表结构简单，呈现为二维表。

#### ② 第二范式（2NF）

- **定义**：建立在1NF基础上，要求所有非键属性完全依赖于整个主键（不仅是主键的一部分）。
- **理解**：如果某属性只依赖主键的一部分，该属性应与主键的这一部分分离，形成新的实体。新实体与原实体之间形成一对多关系。

#### ③ 第三范式（3NF）

- **定义**：在2NF基础上进一步要求，表中的任何非主键属性不能依赖于其他非主键属性。
- **理解**：每个非键属性必须直接依赖主键，不通过其他字段间接依赖。

根据您的笔记内容，以下是修饰后的版本，保持了您指定的格式：

### （3）反范式设计

尽管范式化设计旨在减少数据冗余并提高数据完整性，但完全符合范式的设计并非没有缺点。在实际业务中，经常需要进行大量的表关联查询，如果表结构高度范式化，这些关联操作可能会显著影响查询性能。

**反范式化设计的核心思想：**

1. 适当违反范式化设计的原则，以提升性能和读取效率。
2. 允许存在一定程度的数据冗余，以优化查询性能。

简而言之，反范式化是通过牺牲存储空间来换取时间效率。

### （4）范式化与反范式化的比较

![image-20240715141342040](./assets/image-20240715141342040.png)

1. **更新性能**：范式化设计中，更新操作通常更快，因为涉及的字段较少。
2. **数据冗余**：高度范式化的设计几乎不包含重复数据，更新时需要修改的数据更少。
3. **内存占用**：范式化的表通常更小，因此占用的内存也较少。
4. **查询复杂性**：范式化设计需要频繁的表关联，使得即使是中等复杂度的查询也可能需要至少一次关联，这增加了查询的复杂性。
5. **索引策略**：范式化可能导致原本可以在同一表中共享同一索引的列被分散到不同表中，从而降低索引效率。

反范式化设计通常在需要优化读取性能的大型读取密集型系统中更为常见，而范式化设计适用于更新操作频繁、数据冗余和一致性要求高的应用环境。每种设计方法都有其适用场景和优缺点，选择合适的设计策略需要根据具体业务需求和系统特性来决定。

### （5）反范式应用

#### ① 缓存与汇总数据

**缓存**: 从其他表简单获取并存储的数据，例如，将父表中的数据冗余到子表中。一个常见的例子是将分类信息冗余存放在商品表中。

**汇总**: 指保存使用 `GROUP BY` 语句聚合的数据的表。例如，可以通过对每个用户发送的消息进行计数来显示每个用户发送的消息数量，或者在用户表中添加一个专门的列来存储消息计数，每当用户发送新消息时，更新这一计数。

在管理缓存和汇总表时，通常采用实时维护或定期重建两种方式：
- **缓存表** 通常采用实时更新，确保数据的实时准确性。
- **汇总表** 则更倾向于定期重建，通过定时任务更新数据。

#### ② 计数器表设计

计数器表在Web应用中极为常见，用于记录例如网站点击数、用户朋友数、文件下载次数等。在高并发环境下，优化计数器表的设计至关重要。

**问题**：如果一个计数器表只包含一个记录网站点击次数的行，每次点击更新时都需要在这条记录上加锁，这会导致事务只能串行执行，极大限制并发能力。

**改进方案**：

- 将计数器分布在多行中，以减少锁的竞争。
- 引入“槽”字段，预先在表中增加多行（例如100行），每次更新时随机选择一个槽进行更新。

这种设计可以显著提高系统的处理能力和响应速度，是反范式设计中一种典型的优化策略。

## 2.字段数据类型

### （1）字段优化原则

**最小数据类型**

在选择数据类型时，原则上应选择能够正确存储数据的最小数据类型。较小的数据类型在存储和处理时通常更加高效，因为它们占用的磁盘、内存和CPU缓存较少，同时在处理时也需要更少的CPU周期。

**实例**：如果一个字段可以用字符串类型也可以用整型表示，应优先选择整型。这是因为字符串类型涉及字符集和校对规则，处理起来更为复杂。

**尽量避免NULL**

在大多数情况下，建议将列定义为NOT NULL，除非必须存储NULL值。包含可为NULL的列的查询在MySQL中更难以优化，因为这种列的索引、索引统计和值比较更为复杂。此外，可为NULL的列在存储上也需占用更多空间，且在MySQL中需要特殊处理。

在建立索引时，尤其应避免列设定为可为NULL，因为每个索引记录都会额外占用一个字节空间。尽管将可为NULL的列改为NOT NULL可能带来的性能提升不大，因此在现有的schema中进行这种调整可能不是优先考虑的事项，除非确认这会引起性能问题。

以下是您的笔记内容的修饰版本，按照您指定的格式：

### （2）整数类型

在MySQL中，可以选择多种整数类型来存储数据，包括：`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`。它们分别使用8, 16, 24, 32, 64位存储空间，相当于1、2、3、4、8个字节。整数类型还可以选择是否使用`UNSIGNED`属性，这个属性表明该类型不允许负值，大致可以将正数的上限提高一倍。例如，`TINYINT UNSIGNED`的存储范围是0到255，而普通的`TINYINT`的范围是-128到127。

有符号和无符号整数类型占用相同的存储空间，并具有相同的性能表现，因此可根据实际需求选择适当的类型。

需要注意的是，`integer`和`int`在MySQL中存储大小和性能上没有区别，二者的命名只是为了在业务逻辑上区分使用。

关于整数类型的宽度指定，如`INT(11)`，对于大多数应用而言，这个宽度定义并无实际意义，它并不限制值的合法范围，只是规定了MySQL的某些交互工具用来显示字符的个数。例如，在MySQL命令行客户端中，无论是`INT(1)`还是`INT(20)`，其存储和计算行为是相同的。

### （3）实数类型

实数类型包括带有小数部分的数字。MySQL支持两类实数存储方式：精确的`DECIMAL`类型和不精确的浮点类型`FLOAT`与`DOUBLE`。

- `DECIMAL`类型用于存储需要精确小数处理的场景，如财务计算。它本质上以字符串形式存储，因此CPU不支持对`DECIMAL`的直接计算，而是依赖MySQL自身实现的高精度计算。
- 浮点类型`FLOAT`和`DOUBLE`则由CPU直接支持运算，这使得浮点运算速度更快。`FLOAT`使用4个字节存储，而`DOUBLE`使用8个字节，提供了比`FLOAT`更高的精度和更大的数值范围。
- 相较之下，`DECIMAL`在存储相同范围的值时通常占用更多空间。

**选择标准**：
- 在不需要高精度且优先考虑运算速度的场合，应选择`FLOAT`或`DOUBLE`。
- 只有在需要对小数进行精确计算的情况下，比如财务或金融数据，才推荐使用`DECIMAL`。

在数据量大且要求高精度的情况下，可以考虑使用`BIGINT`替代`DECIMAL`。例如，要求精确到万分之一的财务数据可以将所有金额乘以一百万后存储在`BIGINT`中，这样既避免了浮点数的计算不精确问题，也减少了使用`DECIMAL`的计算代价。

### （4）字符类型

MySQL支持多种字符串类型，主要包括`VARCHAR`和`CHAR`类型、`BLOB`和`TEXT`类型、`ENUM`（枚举）和`SET`（集合）类型。

#### ① VARCHAR

`VARCHAR`是用于存储可变长度字符串的数据类型，非常适合存储长度不一的文本。它只使用必要的空间来存储数据（例如，较短的字符串使用较少的空间）。`VARCHAR`类型在内部使用1或2个额外字节来记录字符串的实际长度：如果最大长度小于或等于255字节，则使用1个字节；如果超过255字节，则使用2个字节。

`VARCHAR`类型的一个优势是它节省了存储空间，这有助于提升性能。然而，在进行`UPDATE`操作时，如果新的字符串比旧的更长，可能需要在存储上进行额外的调整，如`MyISAM`会将行拆成片段存储，而`InnoDB`可能需要分裂页。

#### ② CHAR

`CHAR`是一种定长类型，MySQL会为`CHAR`字段预分配足够的空间来存储定义的最大长度。`CHAR`类型存储时会删除所有末尾空格，并根据需要使用空格填充，以便进行比较。

##### 如何选择CHAR与VARCHAR？

- **VARCHAR** 适合用于列的最大长度远大于平均长度，或者列很少更新的场景。如果使用复杂的字符集（如UTF-8），每个字符占用不同字节数，也推荐使用`VARCHAR`。
  
- **CHAR** 适合存储长度相对固定的短字符串，或所有值几乎都是同一长度的场景。例如，存储MD5加密的密码非常适合使用`CHAR`，因为它是固定长度的。对于经常更新的数据，`CHAR`也比`VARCHAR`更合适，因为定长的`CHAR`类型不易产生碎片。

对于非常短的字符串，如用`CHAR(1)`存储只有`Y`和`N`的值，在单字节字符集中只需要一个字节，而`VARCHAR(1)`需要两个字节，因为还有一个记录长度的额外字节。

##### 关于VARCHAR长度选择

选择`VARCHAR(5)`和`VARCHAR(200)`存储"hello"虽然在磁盘空间上开销相同，但更短的列在内存使用上更为高效。MySQL在处理这些类型时，尤其是在使用内存临时表进行排序或操作时，会因为更长的列分配更多的内存，从而影响性能。因此，最佳策略是只分配实际需要的空间，避免不必要的资源消耗。

#### ③ BLOB和TEXT类型

`BLOB`和`TEXT`是专为存储大量数据设计的字符串数据类型。`BLOB`用于存储二进制数据，而`TEXT`用于存储文本数据。两者的主要区别在于`BLOB`没有字符集和排序规则，而`TEXT`具有字符集和排序规则。

在MySQL中，`BLOB`和`TEXT`类型的处理与其他数据类型不同。每个`BLOB`或`TEXT`值被视为一个独立的对象，通常需要特殊的存储处理。对于过大的`BLOB`或`TEXT`数据，`InnoDB`存储引擎会使用专门的外部存储区域进行存储，并在行内用1到4个字节存储一个指向实际数据的指针。

使用`BLOB`和`TEXT`类型时需谨慎：

1. **避免使用**：`BLOB`和`TEXT`值可能会引起性能问题，因此在设计数据库时应尽可能避免使用这些类型。
   
2. **列隔离**：如果必须使用，建议将`BLOB`或`TEXT`列分离到独立的表中，以提高性能和管理的灵活性。

3. **查询限制**：避免在不必要时检索大型的`BLOB`或`TEXT`值。例如，使用`SELECT *`查询可能会无意中在网络上传输大量数据。建议使用索引列进行搜索，确定需要的数据行后，再从这些行中检索`BLOB`或`TEXT`值。

4. **合成索引**：为了提高大文本字段的查询性能，可以使用合成索引。这涉及到根据大文本字段内容生成的散列值，并将这个散列值存储在单独的列中。然后，可以通过搜索这些散列值来定位数据行。注意，这种方法仅适用于需要精确匹配的查询，因为散列值不适合范围搜索操作。散列值可以通过`MD5`、`SHA1`、`CRC32`或自定义逻辑生成。

这些策略有助于在使用`BLOB`和`TEXT`类型时，平衡性能与存储需求，尽量减少它们对数据库性能的负面影响。

### （5）枚举类型

枚举类型（`ENUM`）是MySQL中用于表示固定字符串集的一种数据类型。当表中的字段只能取固定几个字符串值时，使用枚举类型可以有效减少数据存储空间。MySQL非常高效地处理枚举类型，根据枚举值的数量，内部存储可能仅占用一个或两个字节。在内部，MySQL将枚举值的每个可能项保存为整数，这可以显著减小表的存储大小。

例如，创建一个包含枚举类型的表可以如下操作：

```sql
CREATE TABLE enum_test(
  e ENUM('fish', 'apple', 'dog') NOT NULL
);

INSERT INTO enum_test(e) VALUES ('fish'), ('apple'), ('dog');
```

在使用枚举类型时，需要注意以下几点：

1. **避免使用数字作为枚举常量**：由于枚举列实际上是以整数形式存储的，使用数字作为枚举常量（如`ENUM('1', '2', '3')`）可能导致混淆。这是因为当枚举值被解释为整数时，可能不会如预期那样反映其原始的字符串形式。

2. **定义顺序的重要性**：枚举字段的排序是按照它们在枚举定义中的位置（即内部整数值）进行的，而不是按照字符串值。因此，定义枚举时应按照你需要的排序顺序排列字符串。

这些指导原则可以帮助你在使用枚举类型时避免常见的陷阱，并确保数据以最有效的方式存储和处理。

## 3. 命名规范

### （1）可读性原则

数据库、表、字段的命名应遵循可读性原则，避免或减少使用缩写。命名应直接反映其代表的实体或功能：

- **数据库名**：应与应用名称尽量保持一致。
- **表名**：应体现表中存储的数据内容，建议采用“业务名称_表的作用”的格式。
- **字段名**：表达布尔值（是/否）的字段，建议使用`is_xxx`的格式，数据类型为`unsigned tinyint`（1表示是，0表示否）。
- **存储过程名**：应清晰反映其功能。

### （2）命名约定

- **使用小写字母和数字**：表名和字段名必须使用小写字母或数字，且不得以数字开头。
- **避免使用双下划线**：禁止在两个下划线之间只出现数字。
- **大小写敏感性**：由于MySQL在Windows下不区分大小写，而在Linux下默认区分大小写，建议统一使用小写字母来避免跨平台兼容性问题。

### （3）表名单数形式

- **避免复数形式**：表名应使用单数形式，以确保一致性和避免混淆。

### （4）避免使用保留字

- **禁用保留字**：在命名数据库、表或字段时，不应使用SQL保留字，如`desc`、`range`、`match`等，以防止造成语法错误或冲突。

### （6）索引命名

- **主键索引**：命名为`pk_字段名`。
- **唯一索引**：命名为`uk_字段名`。
- **普通索引**：命名为`idx_字段名`。

遵守这些命名规范有助于维护数据库的清晰结构，提高代码的可读性和可维护性，同时避免在多平台部署时遇到不必要的问题。

## 4.B+树

> 数据结构可视化工具：[数据结构可视化 --- Data Structure Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

### （1）概述

B+树（Balance）是关系型数据库中最常用且最有效的索引结构。B+树起源于平衡二叉树，但本身是一个多叉树。

![image-20240715151247595](./assets/image-20240715151247595.png)

B+树的主要特征包括：

1. **树的高度**：与拥有相同节点数量的平衡二叉树相比，B+树的高度要低很多，这减少了查找时需要的磁盘I/O操作数量。

2. **节点结构**：非叶子节点仅存储键值和指向子节点的指针，不直接存储数据。这种结构有助于提高索引的存储效率。

3. **叶子节点**：叶子节点存储实际的数据记录，并且数据记录在叶子节点内部以及叶子节点之间都是有序排列的。叶子节点按键值的顺序串联起来，便于范围查询。

4. **节点连接**：相邻的叶子节点通过指针相连，这使得范围访问变得更加高效。

一棵m阶的B+树的详细定义如下：

- 每个节点最多包含m个元素。
- 除根节点外，每个节点至少包含(m/2)个元素。
- 如果根节点不是叶节点，那么它至少有两个子节点。
- 所有叶子节点都位于同一层。
- 非叶子节点仅存放键和指向孩子节点的指针，而实际的记录只存储在叶子节点中。
- 一个有k个孩子节点的非叶子节点含有(k-1)个键，且按升序排列。
- 任何键的左子树中的所有键都比该键小，右子树的所有键都大于或等于该键（与二叉排序树的特性相同）。
- 相邻叶子节点之间通过指针连接。

这些特性使得B+树在数据库索引应用中非常高效，特别是在处理大量数据时的查询优化上有显著优势。

### （2）B+树、B树、B*树

#### **① B树**

![image-20240715151426362](./assets/image-20240715151426362.png)

- **数据存储**：在B树中，数据可以存储在所有节点上，包括叶子节点和非叶子节点。这意味着数据和键值（Key）可以在树的任何位置找到。
- **结构特点**：B树的每个节点最多含有m个子节点（m阶），每个节点保存k个键（k<m），以及k+1个指向子节点的指针。
- **查找效率**：查找某个键时，可能需要访问树的多层结构，从根节点开始，直至找到该键所在的节点。

#### **② B+树**

![image-20240715151451421](./assets/image-20240715151451421.png)

- **数据存储**：在B+树中，所有的数据记录仅存储于叶子节点，而内部节点仅存储键值信息，这有助于减少访问磁盘的次数，因为内部节点更小，可以加载更多的键。
- **链表结构**：所有叶子节点形成一个链表，便于进行全范围扫描。在MySQL实现中，这种链表是双向的，即每个节点都有指向前一个和后一个节点的指针，这增加了双向遍历的灵活性。
- **高效范围查询**：由于所有数据都存储在叶子节点的链表中，进行范围查询（如查找一个区间内的所有值）时非常高效。

#### ③ B*树

- **B*树**是B+树的变体，在B+树的基础上增加了非叶子节点间的指针，使得非叶子节点也形成了一个链式结构。
- **优化空间利用**：在B*树中，非叶子节点的分裂规则是当节点满时，将节点中的一部分键值移动到相邻节点（如果有空间的话），只有在相邻节点也满时才进行分裂，这样可以更高效地使用空间。
- **应用**：B*树由于其高效的空间利用率，被用于某些特定的数据库实现中，如Oracle数据库。

这些树结构在数据库索引设计中非常关键，它们帮助数据库管理系统有效地执行查找和范围查询，同时优化存储空间和查询速度。

### （3）MySQL使用B+树

关系型数据库广泛采用B+树作为索引结构，这与磁盘的物理特性密切相关。为了提高效率，关键是要尽量减少磁盘I/O操作。磁盘通常不是按需读取单个字节，而是采用**预读**技术，即使只需要一个字节，磁盘也会从当前位置开始顺序读取一定长度的数据到内存中。预读的长度通常以页（page）为单位，页是计算机存储管理的基本单位，通常大小为4KB。

磁盘的预读特性意味着，如果将B+树的每个节点大小设置为与页大小相匹配或是其整数倍（例如InnoDB的默认节点大小为16KB），可以在每个节点中存储大量的键值。例如，如果每个键占用8字节，一个16KB的节点可以存储大约2000个键。这种设计允许B+树具有非常高的扇出（fanout），通常超过100，意味着在查找记录时能够显著减少I/O操作的次数。

- 扇出是指一个非叶节点包含的指向子节点的指针数量，直接影响树的高度和查找效率。由于B+树的高扇出，数据库系统可以在减少几次磁盘访问的情况下从根节点到达所需的叶子节点。

B+树的特点包括：

- **数据和索引分离**：所有的记录数据只存储在叶子节点上，而非叶子节点仅存储索引键和指向子节点的指针。这种结构使得非叶子节点更小，能够加载更多的索引键，进一步减少访问磁盘的次数。
- **顺序读写优化**：叶子节点中的记录按索引键的顺序排列，并且以双向链表的形式相连。这不仅优化了范围查询的效率，还确保了相邻的节点数据在磁盘上也有可能物理相邻，从而充分利用磁盘的顺序读写特性。

# 二、索引

## 1.概述

索引是数据库中用于提高查询效率的数据结构。简单来说，**索引是一种特殊的数据结构**，它存储在数据库的一个表中，以使数据检索更快。InnoDB存储引擎支持多种类型的索引，最常见的包括：B+树索引、全文索引和哈希索引。

尽管哈希表是一种高效的数据结构，通常用于快速数据检索，但它并不适合用作数据库索引的主要结构，原因包括：

1. **范围查询的限制**：哈希表主要支持精确匹配查询，不适用于范围查找。数据库查询往往需要执行范围搜索，如查找某个区间内的值，这是哈希索引无法有效支持的。

2. **排序困难**：当查询需要按某个字段排序输出时（如使用`ORDER BY`），哈希索引无法直接支持这一操作。哈希索引的本质是将键值通过哈希函数转换为哈希值，这些哈希值的顺序与原始键值的逻辑顺序无关，因此无法用于排序。

3. **组合索引的局限性**：对于组合索引（如索引涵盖字段a、b、c），如果查询仅涉及前两个字段（a和b），B+树索引可以利用这部分索引进行查询。但如果使用哈希索引，通常需要将所有参与索引的字段合并后进行哈希，这样就无法只使用部分字段来利用索引。

4. **大数据量下的冲突问题**：当数据量庞大时，哈希表的冲突概率增加，这会影响哈希索引的效率。虽然可以通过扩展哈希表或使用更复杂的哈希函数来减少冲突，但这会增加计算成本，并可能降低数据检索的速度。

因此，尽管哈希索引在特定场景下（如精确查找小数据集）可以提供极快的查询性能，但由于上述限制，在数据库系统中，特别是需要高效支持复杂查询和大数据集的场景下，更倾向于使用B+树等更为灵活的索引结构。

## 2. B+树索引

### （1）聚簇索引

聚簇索引不仅是一个索引结构，而且决定了表中数据行的物理存储顺序。在聚簇索引中，数据实际存放在索引的叶子节点上，这意味着表数据和索引成为了一个不可分割的整体。因此，一个表只能有一个聚簇索引。

对于InnoDB引擎，主键索引自动成为聚簇索引。如果没有明确指定主键，MySQL会选择第一个唯一索引（非空）作为聚簇索引。如果表没有任何唯一索引，InnoDB会自动生成一个隐藏的行ID作为聚簇索引。

![image-20240715173747277](./assets/image-20240715173747277.png)

聚簇索引的优势在于可以提高数据访问的效率，因为常常访问的数据和键值紧密存储在一起。然而，如果表经常发生插入或删除操作，聚簇索引可能导致数据页分裂，影响性能。

### （2）辅助索引

辅助索引（也称为非聚簇索引或二级索引）在InnoDB中是与聚簇索引分开存储的。辅助索引的叶节点不直接存储行数据本身，而是存储索引键值和相应行的主键值。

在执行查询时，如果使用辅助索引检索数据，数据库可能需要进行两次查找：首先在辅助索引中找到对应的主键，然后使用这个主键在聚簇索引中找到实际的数据。这种操作被称为“回表”。

辅助索引可以提高查询效率，特别是对那些不需要访问所有数据列的查询。但是，每个辅助索引都增加了额外的存储需求，并可能在数据修改时导致额外的维护成本。

### （3）回表

回表是一个过程，涉及在辅助索引查询中使用索引键值查询到主键，然后再使用这个主键去聚簇索引中查询完整的数据行。这是必要的因为辅助索引只存储了行的主键而不是完整的数据。

回表过程会增加查询成本，因为它通常需要进行两次索引查找：一次在辅助索引上，一次在聚簇索引上。这使得辅助索引的查询效率通常低于直接通过聚簇索引查询。因此，设计索引时，需要权衡索引带来的查询优化与其维护及性能开销。

### （4）联合索引

联合索引，也称为复合索引，是在多个列上同时建立的索引。在MySQL中，联合索引按照索引中的列顺序存储键值。这种索引可以极大地提升多个列参与查询条件时的查询性能。

**工作原理：**

当创建如`(a, b, c)`的联合索引时，MySQL会首先根据列`a`的值排序，当列`a`的值相同时，再根据列`b`的值排序，以此类推。这样，如果查询条件包含列`a`，或者列`a`和列`b`，甚至是所有三列，联合索引都能有效地支持查询。然而，如果查询仅涉及列`b`和列`c`，而不涉及列`a`，那么这个索引就不会被利用。

**最左前缀原则：**

联合索引遵循最左前缀原则，即MySQL可以使用索引的最左边的一个或多个列。查询条件需要以索引定义的顺序来使用索引中的列。

联合索引非常适合那些经常一起查询的列。正确地创建联合索引可以减少查询中的排序和临时表的使用，从而提高查询效率。

### （5）覆盖索引

覆盖索引是指一个索引包含了查询中需要的所有数据。简而言之，如果一个查询能够仅通过索引中的信息完成，而不必回表到原始数据行，那么这个索引就是覆盖索引。

**优点：**
1. **性能提升**：由于数据文件本身没有被访问，查询速度可以显著提升，尤其是对于大数据量的表。
2. **减少I/O**：因为所有需要的数据都在索引中，数据库引擎不需要执行额外的I/O操作去数据文件中检索数据。

**适用场景：**

覆盖索引尤其适用于查询中涉及多个列但实际输出的列不多的情况。例如，如果某查询只需要输出用户的ID和用户名，而这两列已经在一个索引中，就可以仅通过索引来获取这些信息，无需访问表中的其他数据。

**检测方法：**

在MySQL中，可以通过`EXPLAIN`命令的输出来检查查询是否使用了覆盖索引。如果`Extra`列显示为`Using index`，这表明查询是一个覆盖索引查询。

## 3.哈希索引

在InnoDB存储引擎中，除了标准的B+树索引之外，还存在一种特别的索引类型称为自适应哈希索引（Adaptive Hash Index，AHI）。这种索引旨在提高频繁访问数据的查询效率。

自适应哈希索引是由InnoDB自动创建和管理的，它通过监控对表的查询操作来决定哪些键值对会受益于哈希索引。当系统检测到某些索引被频繁查询时，它会将这些热点数据的索引转换成哈希索引，从而加快数据检索速度。

**工作原理**

- **自动监控**：InnoDB会持续监控查询模式，识别哪些索引经常被访问。
- **创建哈希索引**：对于那些被频繁访问的索引，InnoDB会在内部自动创建对应的哈希索引。
- **快速定位数据**：通过哈希索引，InnoDB可以几乎立即定位到数据的具体位置，这比在B+树中逐级查找要快得多。

在传统的B+树索引中，查找数据可能需要3到4次磁盘I/O，这是因为B+树的高度通常为3或4层。而通过自适应哈希索引，InnoDB可以直接通过哈希值定位数据，大幅减少查询所需的时间。

**哈希函数和冲突解决**

- **哈希函数**：InnoDB使用除法散列法来计算哈希值。
- **冲突解决**：当两个或多个键产生相同的哈希值时，InnoDB使用链表方式解决哈希冲突。

尽管自适应哈希索引能显著提高等值查询的性能，但它们仅适用于等值查询（如`SELECT * FROM table WHERE column = value`）：

- **等值查询**：哈希索引非常适合处理形如`column = value`的查询。
- **非范围查询**：对于需要执行范围查询的情况，哈希索引无法提供支持，因为哈希索引不保留数据的顺序信息。

自适应哈希索引是完全由InnoDB内部管理的，用户无法直接创建、修改或删除这类索引。这种索引的存在完全取决于InnoDB的内部算法和当前的数据库使用模式。

总结来说，自适应哈希索引是InnoDB优化读取性能的一个高级特性，它能在数据库层面自动优化频繁查询的响应时间，适用于读密集型应用中频繁访问的数据。

## 4.全文索引

全文检索（Full-Text Search, FTS）是一种强大的技术，能够在大量文本中快速查找包含特定关键字的文档。这种技术特别适用于搜索包含大量文本的数据库，如图书、文章集合或网页内容。全文检索的核心在于倒排索引（Inverted Index），这是一种索引方法，它将文档中的关键词映射回包含它们的文档。

倒排索引记录了每个关键词出现在哪些文档中。具体来说，对于每个关键词，索引会列出所有包含该词的文档，通常这些信息会与关键词的出现频率和位置信息一起存储，从而支持复杂的搜索查询，如邻近搜索或短语搜索。

在实际应用中，比如一个数据库保存了唐宋时期的诗词，用户可能想根据某些词或短语来查找诗词。传统的`LIKE '%keyword%'`查询非常低效，因为它需要扫描整个文本字段，逐条比对文本。全文检索通过创建倒排索引，极大地提高了搜索效率。

从MySQL 5.6开始，InnoDB引擎支持了全文检索，允许用户在创建表时使用`FULLTEXT`类型的索引来优化文本搜索查询。然而，MySQL的全文索引功能相比专门的搜索引擎如Elasticsearch、Solr（这些基于Apache Lucene）可能功能较弱，主要因为：

1. **限制较多**：MySQL的全文索引每张表只能有一个，且对非西欧语言的支持较弱。
2. **性能**：虽然InnoDB的全文检索足以应对一些基本需求，但在处理大规模文本数据时，其性能和可扩展性不如专门的搜索引擎。

如果设计一个唐宋诗词的数据库，可以这样优化：

1. **建立全文索引**：在诗词全文上建立全文索引，以便快速搜索包含特定关键词的诗句。
2. **使用倒排索引表**：为了处理如“包含某字”的查询，可以创建一个额外的表来存储每个关键字及其出现在哪些诗句中的信息。

```sql
-- 创建一个名为 poems 的表来存储诗词信息
CREATE TABLE poems (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 主键，自增的诗词ID
    dynasty VARCHAR(10),                -- 朝代
    author VARCHAR(100),                -- 作者名称
    title VARCHAR(255),                 -- 诗词标题
    content TEXT,                       -- 诗词内容
    FULLTEXT(content)                   -- 对 content 列创建全文索引
) ENGINE=InnoDB;                        -- 使用 InnoDB 存储引擎

-- 查询包含“望”字的诗词
-- 使用全文索引进行搜索
SELECT title, content FROM poems
WHERE MATCH(content) AGAINST('+望' IN BOOLEAN MODE); 
-- 此查询会返回所有在 content 字段中包含“望”字的诗词的标题和内容
-- '+' 表示词语“望”必须出现在 content 中
-- BOOLEAN MODE 指定使用布尔全文搜索模式
```

全文检索为文本密集型应用提供了高效的搜索功能，尽管MySQL支持基本的全文检索，对于更复杂或数据量更大的全文搜索需求，可能需要考虑使用专门的搜索引擎。对于中文等需要分词处理的语言，这些工具通常提供更高级的分析和搜索功能。

## 5.高性能的索引创建策略

### （1）索引列的选择

在创建索引时，选择具有高选择性的列至关重要。索引的选择性是指唯一值的数量（即基数或cardinality）与表中记录总数（N）的比例。这个比例范围从1/N到1，其中1表示每个索引值都是唯一的，这样的索引选择性最优。

高选择性的索引能够极大地提升查询效率，因为它可以在查询过程中排除更多的数据行，从而减少需要处理的数据量。例如，一个包含个人身份证号的列将是一个选择性很高的索引，因为每个值都是唯一的。

相反，如果一个列中的数据重复率很高（如性别字段），这样的索引选择性较低。在这种情况下，即使使用索引，查询效率也不会显著提高，因为索引无法有效地减少搜索范围。

### （2）索引列的类型

在定义数据表时，选择合适的数据类型对性能有重要影响。整数类型如TINYINT、MEDIUMINT、INT、BIGINT占用的存储空间及其可以表示的数据范围是不同的。在可能的情况下，应选择尽可能小的数据类型，这不仅可以加快CPU的比较操作速度，还能减少索引占用的存储空间，从而在数据库的数据页中存储更多的记录。

这种策略对于主键尤其重要，因为主键不仅会存储在聚集索引中，还会在所有二级索引中重复出现。使用较小的数据类型作为主键可以节省大量的存储空间和I/O资源，从而提高整体数据库性能。

### （3）前缀索引

对于BLOB、TEXT或者非常长的VARCHAR字段，MySQL无法对其完整长度建立索引。在这种情况下，可以建立前缀索引，这种索引只索引字段的一部分。

**语法示例：**

```sql
ALTER TABLE tableName ADD KEY (column(10));
```
这里的`10`表示索引的前10个字符。

**前缀索引的缺点：**

虽然前缀索引可以减少索引的大小并提高处理速度，但它也有局限性：MySQL无法利用前缀索引来进行ORDER BY或GROUP BY操作，也无法进行覆盖扫描。

有时候，如在处理电子邮件地址或某些特定格式的数据时，后缀索引也是有用的。虽然MySQL原生不支持后缀索引，但可以通过将字符串反转并建立基于反转字符串的前缀索引来实现相似功能。这种索引的维护可以通过触发器或应用程序代码来实现。

### （4）搜索、排序或分组的索引策略

创建索引的目的主要是提升数据库查询的性能，尤其是对于经常需要搜索、排序或分组的操作。合理的索引策略可以极大地加快这些操作的处理速度。下面是一些关于如何为这些操作创建索引的策略：

#### ①WHERE 子句的索引

为经常出现在WHERE子句中的列创建索引是提高查询性能的常用方法。当你预测某些列会频繁用于过滤记录时，为这些列创建索引可以加快查询速度，因为索引可以帮助数据库快速定位到那些满足条件的记录。

#### ②连接子句的索引

在进行表连接操作时，连接条件中使用的列应该有索引。这样可以快速匹配来自不同表的记录，特别是在处理大量数据的连接查询时，索引可以显著减少查询时间。

#### ③ORDER BY 和 GROUP BY 子句的索引

为出现在ORDER BY或GROUP BY子句中的列创建索引可以加快排序和分组操作。数据库可以直接利用索引的顺序，避免额外的排序步骤，从而提高查询效率。

如果一个查询涉及到多列排序或分组，可以考虑创建复合索引。复合索引包含了多个列，顺序与查询中ORDER BY或GROUP BY的顺序相对应。

### （5）多列索引

#### ①索引列的顺序问题

多列索引的列顺序非常关键，因为在一个多列B-Tree索引中，数据首先按照索引的最左列进行排序，然后是第二列，依此类推。因此，索引的扫描可以按照升序或降序进行，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。

#### ②选择性最高的列优先

一个经验法则是将选择性最高的列放到索引的最前列。选择性高的列意味着该列在查询中作为过滤条件时能够排除更多的数据行，从而提高查询效率。这是在不需要考虑排序和分组时的优先策略。

#### ③根据查询调整索引列顺序

实际应用中，可能需要根据那些运行频率最高的查询来调整索引列的顺序，尤其是排序和分组操作。性能优化不仅依赖于索引列的选择性，还与查询条件的具体情况密切相关。

#### ④使用不同顺序的索引

在优化性能时，有时需要使用相同的列但顺序不同的索引来满足不同类型的查询需求，确保每种查询都能得到最优的执行效率。

### （6）三星索引

#### ①一星索引

一星索引指的是索引能将相关记录放到一起，使得必须扫描的索引片宽度尽可能缩短，也就是索引的扫描范围越小越好。

#### ②二星索引（排序星）

如果查询需要排序、GROUP BY或ORDER BY，且查询所需的顺序与索引一致，那么可以直接使用索引的有序性，而无需再进行排序，这是二星索引的标准。

#### ③三星索引（宽索引星）

三星索引是最优的索引，包含了查询中需要的所有列，从WHERE子句到SELECT子句。这种覆盖索引使得查询无需回表，直接通过索引即可获取所需数据，极大地减少了IO请求次数和查询步骤。

### （7）三星索引实践

实现三星索引的关键在于精确理解查询需求并优化索引以满足这些需求。下面是几个步骤，可以帮助在实际数据库操作中有效地实现三星索引：

#### ①分析查询模式

首先，需要分析应用程序中的主要查询模式。查看哪些查询最为频繁，这些查询的WHERE子句、SELECT子句，以及可能的排序（ORDER BY）和分组（GROUP BY）操作。理解这些查询模式是创建有效索引的基础。

#### ②确定索引的列

根据分析得出的数据，确定哪些列应该被包含在索引中。优先考虑那些在WHERE子句中用于过滤数据的列，然后是SELECT子句中的列，最后是ORDER BY或GROUP BY中的列。

#### ③优化索引顺序

索引的列顺序应该根据查询条件来优化。通常，将选择性最高的列（即能够排除最多数据的列）放在索引的前面。然后，考虑排序和分组的需求，确保索引能够按照查询中的顺序提前排序数据，从而避免额外的排序过程。

#### ④创建覆盖索引

尽可能创建覆盖索引，即索引包含了查询中需要的所有数据列。这种索引能够让数据库引擎仅通过索引就能返回查询结果，极大地减少了对磁盘的访问次数和提高了查询速度。

**示例：**

假设有一个经常执行的查询，它需要从客户表中选择客户的名称和联系信息，根据城市进行过滤，然后按照客户的注册日期排序：

```sql
SELECT customerName, contact, city, registrationDate
FROM customers
WHERE city = 'New York'
ORDER BY registrationDate DESC;
```

为了为这个查询创建一个三星索引，我们可以按以下方式定义索引：

```sql
CREATE INDEX idx_three_star ON customers(city, registrationDate DESC, customerName, contact);
```

这个索引首先按城市过滤（高选择性），然后保证了数据按注册日期的降序排序，同时还包含了查询所需的所有其他列，从而实现了一个覆盖索引。

#### ⑤监测和调整

创建索引后，监控其性能以及它对其他数据库操作的影响。索引虽然可以提高查询效率，但也可能会降低插入、更新和删除操作的速度。如果必要，根据实际情况调整索引的结构和列顺序，以达到最佳性能平衡。

通过这些步骤，可以在实际应用中有效地实施三星索引，优化数据库的性能和响应速度。

# 三、调优

## 1.调优金字塔

很明显从图上可以看出，越往上走，难度越来越高，收益却是越来越小的。

对于**架构调优**，在系统设计时首先需要充分考虑业务的实际情况，是否可以把不适合数据库做的事情放到数据仓库、搜索引擎或者缓存中去做；然后考虑写的并发量有多大，是否需要采用分布式；最后考虑读的压力是否很大，是否需要读写分离。对于核心应用或者金融类的应用，需要额外考虑数据安全因素，数据是否不允许丢失。所以在进行优化时，首先需要关注和优化的应该是架构，如果架构不合理，即使是DBA能做的事情其实是也是比较有限的。

对于**MySQL调优**，需要确认业务表结构设计是否合理，SQL语句优化是否足够，该添加的索引是否都添加了，是否可以剔除多余的索引等等

比如**硬件和OS调优**，需要对硬件和OS有着非常深刻的了解，仅仅就磁盘一项来说，一般非DBA能想到的调整就是SSD盘比用机械硬盘更好。DBA级别考虑的至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是XFS），操作系统的磁盘调度算法选择，是否需要调整操作系统文件管理方面比如atime属性等等。

## 2.查询性能优化

### （1）查询性能低下的原因

查询性能低下通常由于访问了过多的数据。优化这类查询主要集中在减少访问的数据量。以下是一些常见的导致查询性能低下的原因：

#### ① 请求多余的数据

这是查询性能低下的一个常见原因。包括以下几个方面：

**a. 查询了不必要的记录**

有时候，查询条件设置不当，可能会返回更多的记录。例如，WHERE 子句的条件过于宽松，或者查询中缺乏适当的过滤，导致返回大量不需要的记录。

**b. 总是取出全部列**

即使只需要几个字段，也请求了表中的所有列。这种情况通常出现在使用 `SELECT *` 而不是指定具体列的查询中。这不仅增加了数据传输的负载，还可能引起不必要的磁盘I/O操作。

**c. 重复查询相同的数据**

在多个查询中反复请求相同的数据，尤其是在应用程序的不同部分独立执行相似的查询时。这不仅消耗CPU和内存资源，也可能导致缓存效率低下。

优化这些问题的方法包括精确定义查询条件，只请求必要的列，以及使用缓存策略来减少数据库的访问频率。

#### ② 扫描额外的记录

在确认查询只返回必要的数据之后，下一步是检查是否扫描了过多的数据。对于MySQL来说，衡量查询开销的三个基本指标是：**响应时间**、**扫描的行数**和**返回的行数**。这些指标大致反映了MySQL在执行查询时需要处理的数据量，并可以用来估算查询的执行时间。这些指标通常会记录在MySQL的慢日志中，检查慢日志是发现扫描行数过多的查询的一个好方法。

**响应时间**由两部分组成：服务时间和排队时间。服务时间是数据库处理查询实际花费的时间。排队时间是查询因等待某些资源（如I/O完成或行锁等）而未能立即执行的时间。

**扫描的行数与返回的行数**的分析对于评估查询效率至关重要。理想情况下，扫描的行数应该与返回的行数相同。但在实践中，特别是在进行关联查询时，可能需要扫描多行才能生成结果集中的一行。扫描行数与返回行数的比率通常很低，一般在1:1到10:1之间，但有时这个比率可能非常大。

**访问类型**也是评估查询成本的重要方面。MySQL有多种数据访问方法，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等，这些方法在EXPLAIN语句的type列中有所反映。知道这些访问类型及其对应的数据扫描行数，可以帮助优化查询。

如果查询不能找到合适的访问类型，通常的解决方案是添加适当的索引。索引能使MySQL以最高效、扫描行数最少的方式找到所需记录。

**优化具有高扫描行数的查询的方法**：

1. **使用索引覆盖扫描**：将所有需要的列都包含在索引中，这样存储引擎就无需回到数据表中获取对应的行，从而可以直接返回结果。
   
2. **改变库表结构**：例如，使用单独的汇总表来存储频繁查询的数据，减少查询时需要处理的数据量。

3. **重写查询**：修改查询的方式，让MySQL优化器能够以更有效的方法执行查询，例如调整JOIN的顺序、优化WHERE子句中的条件等。

通过这些技巧，可以显著减少查询必须扫描的数据量，从而提高查询性能。

### （2）慢查询日志

慢查询日志是MySQL用于记录执行时间超过预设阈值的SQL语句的功能，它是优化数据库性能的一个重要工具。默认情况下，慢查询日志是关闭的，但可以通过以下步骤启用并配置它。

要开启慢查询日志功能，需要修改MySQL的配置文件（通常是`my.cnf`或`my.ini`），在该文件中设置以下参数：

```sql
[mysqld]
slow_query_log = 1
slow_query_log_file = /path/to/your/log-file
long_query_time = 10
log_queries_not_using_indexes = 1
```

**参数说明：**

- **slow_query_log**: 设置为1以开启慢查询日志。
- **slow_query_log_file**: 指定慢查询日志的存储路径及文件名。
- **long_query_time**: 设置为查询执行的时间阈值（单位为秒）。如果查询执行时间超过这个值，就会被记录在慢查询日志中。默认值通常为10秒。
- **log_queries_not_using_indexes**: 设置为1时，任何未使用索引的查询也会被记录在慢查询日志中，即使其执行时间未达到`long_query_time`设定的阈值。

一旦慢查询日志启用，你可以使用多种工具来分析这些日志，以识别性能瓶颈和优化查询。一些常用的工具包括：

- **mysqldumpslow**: MySQL自带的工具，可以用来分析慢查询日志并汇总最慢的查询。
- **Percona Toolkit**: 提供了`pt-query-digest`工具，它比`mysqldumpslow`提供了更详细的分析和更灵活的报告选项。

假设你已经设置并生成了慢查询日志，可以使用`mysqldumpslow`命令来分析这些日志：

```bash
mysqldumpslow -s t -t 10 /path/to/your/log-file
```

**参数说明：**

- **-s t**: 按照查询时间排序。
- **-t 10**: 显示前10条最慢的查询。

在开启慢查询日志时，要注意对性能的影响。尽管慢查询日志对于发现和优化慢查询非常有用，但记录这些信息可能会轻微增加服务器的负载。因此，通常建议在非生产环境中进行详尽的测试，或者在生产环境中仅在必要时临时启用。

### （3）Explain执行计划

#### ① 什么是执行计划

在MySQL中，执行计划是查询优化器生成的一个方案，显示了如何执行数据库查询。优化器评估多种可能的查询路径，并选择成本最低的那一个。执行计划包括了多表连接的顺序、各表的访问方法等关键信息，从而决定了查询的执行方式。

#### ② Explain

使用EXPLAIN语句，可以查看MySQL如何执行特定的SQL查询，特别是它如何访问表中的行，是否使用了索引，以及联接的类型等。这对于分析并优化数据库查询性能非常有帮助。EXPLAIN提供的信息包括：

- **表的读取顺序**：显示了表在查询中的处理顺序。
- **数据读取操作的类型**：如全表扫描、索引扫描、范围扫描等。
- **可用的索引**：显示查询中可能使用的所有索引。
- **实际使用的索引**：显示查询实际使用的索引。
- **表之间的引用**：展示表在多表查询中如何相互关联。
- **每张表查询的行数**：优化器估计为了生成结果集需要检查的行数。

使用EXPLAIN可以帮助我们理解和优化查询，例如，确定是否需要添加或修改索引来改进查询性能。

假设我们有一个简单的查询语句，想查看其执行计划，可以这样写：

```sql
EXPLAIN SELECT * FROM table1;
```

这条EXPLAIN语句会输出一个结果集，其中包含上述各项指标。这些指标提供了关于MySQL如何处理这个查询的详细信息，帮助开发者和数据库管理员优化查询性能。

**分析EXPLAIN输出**

- **id**：查询的序列号，表示查询中操作的执行顺序。
- **select_type**：查询的类型，比如简单查询（SIMPLE）、联接查询（JOIN）等。
- **table**：输出行所针对的表名。
- **type**：访问类型，是决定查询速度的重要因素。通常，range比index快，index比ALL快。
- **possible_keys**：显示可能应用在这张表上的索引。
- **key**：实际使用的索引。如果没有选择索引，值是NULL。
- **key_len**：使用的索引的长度。在索引选择中，长度越长越好。
- **ref**：显示索引的哪一列被使用了，如果可能的话，是一个常数。
- **rows**：根据表统计信息及索引选择，估计需要检查的行数。
- **Extra**：包含不适合在其他列中显示的额外信息，如“Using index”。

通过详细分析这些信息，可以调整查询语句或索引策略，优化数据库的性能。

#### ④ type

在MySQL的执行计別中，`type`列非常关键，它表示MySQL执行查询时选择的访问类型。这个类型指示了查询的效率，显示MySQL如何访问表中的数据。下面是`type`列可能出现的值，按性能从最好到最坏排序：

1. **system**：这是特殊的const类型，仅当表中只有一行时出现。此时，MySQL能够在初始化时就优化查询，因为整个表就是一行数据。

2. **const**：当查询的结果能够在优化阶段就确定为一个常量时使用。例如，通过主键或唯一索引查询单个行的情况。因为只返回一行数据，所以非常快。

3. **eq_ref**：在连接查询中，当对于前表的每一个行，后表只有一行匹配时（使用主键或唯一索引），这种类型最常见于多表JOIN操作，每次JOIN操作都能精确地定位到单一行记录。

4. **ref**：这种类型类似于eq_ref，但区别在于JOIN或WHERE条件中使用的索引不是唯一索引，也就是说，对于前表的每个行，后表可能有多个行匹配，但都能通过索引快速定位。

5. **range**：只检索给定范围内的行，使用一个索引来选择行。常见于使用BETWEEN、<、>、IN等操作符的查询。这种方式比全表扫描要好，因为它只需要扫描索引树的一部分。

6. **index**：此访问类型仅扫描索引树。虽然比ALL要快，因为避免了访问表的数据行，但比range类型要慢，因为它扫描的是整个索引。

7. **ALL**：最低效的访问类型，进行全表扫描，检查表中的每一行，看它是否符合WHERE子句的条件。尽量避免这种类型的查询，因为它会非常慢，尤其是对于大表。

为了优化查询，应该力求使查询至少达到`range`级别，更好的目标是达到`ref`或更高级别。使用合适的索引是提高查询性能，优化访问类型的关键策略。通过调整表结构或重写查询，可以改进查询的`type`，从而提高数据库的查询效率。

### （4）查询优化器

MySQL查询优化器是负责生成最有效执行计划的组件。查询优化器的工作是非常复杂的，涉及多个阶段，每个阶段都是为了确保查询以最高效的方式执行。

![image-20240715202040635](./assets/image-20240715202040635.png)

1. **查询缓存**：MySQL首先检查查询缓存，如果查询结果已经在缓存中并且表没有更新，它会直接返回缓存中的结果，跳过后续的所有步骤。这可以显著加快响应时间，尤其是对于重复执行的相同查询。然而，从MySQL 8.0开始，查询缓存功能已被废弃，因为在高并发环境中它可能导致性能问题。

2. **解析查询**：查询被解析成一个内部数据结构，通常是一个解析树。这一阶段涉及到SQL语句的语法和语义分析，确保SQL语句是合法的，并且构建出可执行的结构。解析器会分解SQL语句，识别出各个组成部分，如关键字、表名、列名等。

3. **优化过程**：这是查询优化器的核心部分，包括重写查询、选择合适的索引、决定表的连接顺序等。这一阶段涉及到深度的成本分析，优化器将尝试多种可能的执行计划，根据成本估算模型选择成本最低的一个。优化过程包括但不限于：

   ​	**查询重写**：优化器可能会自动重写查询，以更有效的形式执行。例如，将子查询转换为连接查询。

   ​	**索引选择**：根据可用索引和查询条件，优化器决定使用哪些索引。

   ​	**连接顺序**：在涉及多个表的查询中，确定哪个表先读取，哪个表后读取是至关重要的，优化器会评估不同的连接顺序以找到最佳方案。

   ​	**读取顺序**

4. **查询执行计划的生成**：最终生成一个查询执行计划，这个计划指导MySQL如何执行SQL查询。

5. **存储引擎的反馈**：优化器在优化查询时，还会与存储引擎进行交互，询问存储引擎关于数据的物理存储细节，如数据页的分布、索引的统计信息等。这些信息对于选择最优的查询路径至关重要。

通过这些步骤，查询优化器能够确定最有效的执行方式，最小化查询的响应时间和资源消耗。对于数据库管理员和开发人员来说，理解优化器的工作方式对于写出高效的SQL语句和调优现有查询至关重要。

## 3.高性能的索引使用策略

### （1）不在索引列上做任何操作

为了确保MySQL可以有效地使用索引，重要的是不对索引列进行任何操作，如函数调用、计算或转换。当索引列被包含在表达式或作为函数参数时，MySQL可能无法利用已有的索引。保持索引列的“独立性”可以确保查询性能最优化。

```sql
-- 错误示例：在索引列上使用函数
SELECT * FROM users WHERE DATE(created_at) = '2022-01-01';

-- 正确示例：直接使用索引列
SELECT * FROM users WHERE created_at >= '2022-01-01' AND created_at < '2022-01-02';

```

### （2）尽量全值匹配

当存在联合索引时，尽量使用全值匹配，即查询条件涵盖索引中的所有列。这样做可以最大限度地利用索引的优势，减少查询的数据范围，提高查询效率。

```sql
-- 假设在firstName和lastName上有联合索引
-- 错误示例：只使用了联合索引的一部分
SELECT * FROM users WHERE firstName = 'John';

-- 正确示例：全值匹配联合索引
SELECT * FROM users WHERE firstName = 'John' AND lastName = 'Doe';

```

### （3）最佳左前缀法则

在使用联合索引时，应遵循最左前缀法则。这意味着查询条件应从索引的最左列开始，并且按顺序使用索引列，不应跳过任何列。这是因为MySQL的索引是按照从左到右的顺序建立的，如果查询条件中缺少最左边的列，那么索引的效率会大打折扣。

```sql
-- 假设有一个联合索引(first_name, last_name, email)
-- 错误示例：跳过了中间的last_name列
SELECT * FROM users WHERE first_name = 'John' AND email = 'john@example.com';

-- 正确示例：按索引顺序提供条件
SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe' AND email = 'john@example.com';

```

### （4）范围条件放最后

在使用联合索引进行查询时，应将范围条件放在最后。如果索引的最左列是精确匹配，而右侧的列是范围查询，这样可以保证MySQL仍能有效地使用索引。如果在中间的某个列上进行范围查询，则后续列的索引将无法被利用。

```sql
-- 假设有一个联合索引(endDate，startDate )
-- 错误示例：将范围条件放在第一位
SELECT * FROM events WHERE startDate > '2022-01-01' AND endDate = '2022-01-02';

-- 正确示例：范围条件放在最后
SELECT * FROM events WHERE endDate = '2022-01-02' AND startDate > '2022-01-01';

```

### （5）覆盖索引

覆盖索引是一种非常强大的工具，它指的是索引包含了查询中需要的所有字段，因此查询操作只需访问索引而不必回表查询数据。这大大减少了数据访问量，对于I/O密集型应用尤其有益。覆盖索引可以极大地减少磁盘I/O需求并提高查询速度，尤其是在使用InnoDB存储引擎时，由于其二级索引中包含了主键值，使得覆盖索引的效果更加显著。

```sql
-- 假设有一个覆盖索引(userId, userName, userEmail)
-- 错误示例：查询列不完全由索引覆盖
SELECT userId, userName, userAge FROM users WHERE userId = 101;

-- 正确示例：查询列完全由索引覆盖
SELECT userId, userName, userEmail FROM users WHERE userId = 101;

```

### （6）不等于要慎用

在MySQL中，使用`!=`或`<>`条件时，通常无法有效利用索引，因为这些操作要求检查除特定值之外的所有记录，导致全表扫描。

```sql
-- 错误示例：使用不等于操作
SELECT * FROM users WHERE age != 25;

-- 更优化的做法是改变查询方式，避免使用不等于
SELECT * FROM users WHERE age < 25 OR age > 25;
```

### （7）Null/Not Null影响

设计表时，应尽量避免列声明为可为null，因为null值的处理通常会使索引效率降低，尤其是在复合索引中。

```sql
-- 错误示例：含有NULL值的列可能不会被有效索引
SELECT * FROM users WHERE email IS NULL;

-- 优化策略：尽量保证字段非NULL，或者使用默认值代替NULL
```

### （8）like查询的影响

使用`LIKE`查询且通配符（`%`）位于开头时，索引无法使用，导致全表扫描。

使用覆盖索引可以改善这个问题。

```sql
-- 错误示例：以通配符开头
SELECT * FROM users WHERE username LIKE '%smith';

-- 正确示例：通配符不在开头
SELECT * FROM users WHERE username LIKE 'smith%';
```

### （9）字符类型加引号

在进行字符类型字段的查询时，若不加引号，MySQL可能不识别为字符串查询，从而导致索引失效。

```sql
-- 错误示例：未加引号
SELECT * FROM users WHERE username = 12345;

-- 正确示例：加上单引号
SELECT * FROM users WHERE username = '12345';
```

### （10）or的影响

使用`OR`条件时，如果查询的列涉及多个索引，通常MySQL无法同时利用这些索引，可能会回退到全表扫描。

```sql
-- 错误示例：使用OR条件连接多个列
SELECT * FROM users WHERE username = 'smith' OR email = 'smith@example.com';

-- 更优化的做法：可能需要重新设计查询或使用UNION来改善性能
SELECT * FROM users WHERE username = 'smith'
UNION
SELECT * FROM users WHERE email = 'smith@example.com';
```

### （11）使用索引来优化排序和分组

MySQL可以使用索引来优化排序操作，但仅当`ORDER BY`的列完全匹配索引的顺序，并且所有列的排序方向相同时。

```sql
-- 假设有一个索引定义为（lastName, firstName）
-- 正确示例：使用索引排序
SELECT lastName, firstName FROM users ORDER BY lastName, firstName;

-- 错误示例：顺序不匹配索引
SELECT lastName, firstName FROM users ORDER BY firstName, lastName;
```

### （12）按主键顺序插入记录

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕，它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。

最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。

注意到向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长﹔另一方面毫无疑问是由于页分裂和碎片导致的。

因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时(InnoDB默认的最大填充因子是页大小的15/16，留出部分空间用于以后修改)，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载,主键页就会近似于被顺序的记录填满,这也正是所期望的结果。

如果新行的主键值不一定比之前插入的大，所以InnoDB无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置-—通常是已有数据的中间位置——并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化。下面是总结的一些缺点:

写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机IO。

因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。

所以使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。

### （13）优化Count查询

首先要注意，COUNT()是一个特殊的函数，有两种非常不同的作用:它可以统计某个列值的数量，也可以统计行数。

在统计列值时要求列值是非空的（不统计NULL)。

COUNT()的另一个作用是统计结果集的行数。常用的就是就是当我们使用COUNT(*)。实际上，它会忽略所有的列而直接统计所有的行数。

通常来说，COUNT()都需要扫描大量的行（意味着要访问大量数据）才能获得精确的结果，因此是很难优化的。在MySQL层面能做的基本只有索引覆盖扫描了。如果这还不够,就需要考虑修改应用的架构，可以用估算值取代精确值，可以增加汇总表，或者增加类似Redis这样的外部缓存系统。

### （14）优化limit分页

在系统中需要进行分页操作的时候，我们通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY子句。

一个非常常见又令人头疼的问题就是，在偏移量非常大的时候

优化此类分页查询的一个最简单的办法是

会先查询翻页中需要的N条数据的主键值，然后根据主键值回表查询所需要的N条数据，在此过程中查询N条数据的主键id在索引中完成，所以效率会高一些。

# 四、事务

## 1.事务概述

事务是数据库管理系统执行过程中的一个逻辑单位，由一个或多个SQL语句组成。事务在数据库系统中非常重要，因为它保证了数据操作的完整性和一致性。

### （1）为什么需要事务

事务的主要目的是为了确保数据的完整性和一致性，即使在面对并发操作或系统故障的情况下。事务确保了一组操作要么完全成功，要么完全失败，这对于保持数据库状态的准确性和可靠性是必要的。例如，在银行系统中，从一个账户向另一个账户转账的操作，必须确保资金从一个账户正确扣除并且相应地添加到另一个账户，事务帮助实现了这种操作的完整性。

### （2）事务特性

事务的四大特性通常被称为ACID特性：

**原子性（Atomicity）**：事务中的所有操作要么全部完成，要么全部不执行，不会结束在中间某个环节。事务在执行过程中发生错误会被回滚（Rollback）到事务开始前的状态，就像这些操作从未被执行过一样。

 **一致性（Consistency）**：事务必须使数据库从一个一致性状态转换到另一个一致性状态。一致性状态的定义基于业务规则，事务在完成时保证所有的数据规则都应用成功，从而保持数据的准确性和完整性。

 **隔离性（Isolation）**：通常情况下，一个事务所做的修改在最终提交之前，对其他事务是不可见的。隔离性可以防止多个事务同时执行时由于交叉执行导致数据不一致。

 **持久性（Durability）**：一旦事务提交，则其所做的修改会永久保存在数据库中，即使系统发生故障也不会丢失。

### （3）事务引发的问题

事务在解决操作级别的问题时，也可能引入一些复杂性，主要体现在以下几种问题：

- **脏读（Dirty Read）**：一个事务读取了另一个事务未提交的数据。如果那个事务回滚，读取的数据就是无效的。
  
- **不可重复读（Non-Repeatable Read）**：在同一事务中，多次读取同一数据集合时，由于其他事务的更新操作，后续读取的数据可能与前面的不一致。
  
- **幻读（Phantom Read）**：一个事务重新执行一个查询，返回一组符合查询条件的行，发现有些行以前没有但现在出现，或者以前有但现在没有了。这是由于其他事务插入或删除了数据行造成的。

### （4）隔离级别

为了解决上述问题，SQL标准定义了几种事务隔离级别，不同的隔离级别对性能和并发操作的影响程度不同：

- **读未提交（Read Uncommitted）**：允许事务读取未被其他事务提交的修改，可能导致脏读。
- **读已提交（Read Committed）**：保证一个事务只能读取已经被其他事务提交的修改，可以避免脏读，但是不可重复读仍可能发生。
- **可重复读（Repeatable Read）**：确保在同一事务中多次读取同一数据结果相同，避免了不可重复读，但幻读仍可能发生。
- **串行化（Serializable）**：最高的隔离级别，强制事务串行执行，避免了脏读、不可重复读和幻读，但可能会导致性能问题。

根据应用的具体需求和数据的重要性，开发者可以选择适当的隔离级别来平衡性能和数据完整性。

## 2.MySQL事务应用

### （1）事务基本语法

在MySQL中，事务的控制主要通过以下几个基本语句来实现：

- **事务开始（START TRANSACTION 或 BEGIN）**：这两个命令都用于启动一个新的事务。`BEGIN` 是 `START TRANSACTION` 的简写形式。

  ```sql
  START TRANSACTION;
  ```

  或

  ```sql
  BEGIN;
  ```

- **事务回滚（ROLLBACK）**：如果在事务执行过程中遇到错误或者需要主动放弃修改，可以使用 `ROLLBACK` 命令来撤销所有未提交的更改，回到事务开始时的状态。

  ```sql
  ROLLBACK;
  ```

- **事务提交（COMMIT）**：当事务中的所有操作都成功完成后，使用 `COMMIT` 命令将所有更改永久保存到数据库中。

  ```sql
  COMMIT;
  ```

### （2）保存点

保存点允许在事务中创建一个可回滚的点，这使得可以部分撤销事务中的操作而不是全部撤销。保存点非常适合处理复杂的事务逻辑，可以在事务执行的特定阶段放置一个标记，以便在需要时回滚到该点。

- **设置保存点（SAVEPOINT）**：

  ```sql
  SAVEPOINT savepoint_name;
  ```

- **回滚到保存点（ROLLBACK TO SAVEPOINT）**：

  ```sql
  ROLLBACK TO SAVEPOINT savepoint_name;
  ```

- **释放保存点（RELEASE SAVEPOINT）**：删除一个保存点。如果事务提交，所有的保存点自动被释放。

  ```sql
  RELEASE SAVEPOINT savepoint_name;
  ```

### （3）隐式提交

某些SQL语句在执行时会自动触发事务的提交，这称为隐式提交。这意味着，如果在一个事务中执行了这类命令，当前的事务会自动结束，并提交所有更改。常见的触发隐式提交的语句包括`ALTER TABLE`, `CREATE INDEX`, `DROP DATABASE` 等。

### （4）设置隔离级别

在MySQL中，可以通过`SET TRANSACTION`语句设置事务的隔离级别，以控制事务的并发访问特性。隔离级别的设置会影响数据的可见性和事务的并发行为。

- **设置事务的隔离级别**：

  ```sql
  SET TRANSACTION ISOLATION LEVEL level_name;
  ```

  其中`level_name`可以是以下任一项：
  - `READ UNCOMMITTED`
  - `READ COMMITTED`
  - `REPEATABLE READ`
  - `SERIALIZABLE`

  示例：

  ```sql
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

这些功能和语法的应用使MySQL在处理需要保证数据完整性和一致性的应用场景中表现出色。

## 3.MVCC

### （1）版本链

多版本并发控制（MVCC）是InnoDB存储引擎用于提高数据库读取性能和并发性的重要技术。MVCC允许在执行读操作时不锁定资源，从而在高并发环境下减少锁的竞争。在InnoDB中，每条记录在修改时都会在隐藏的列中记录额外的信息，这些信息对实现MVCC至关重要。

每当一条记录被更新时，InnoDB存储引擎的操作步骤如下：

1. **trx_id（事务ID）**: 每次对记录的修改都会记录当前事务的ID。这个ID反映了修改该记录的事务的唯一性和顺序。

2. **roll_pointer（回滚指针）**: 此隐藏列指向undo日志中该记录之前版本的信息。undo日志记录了之前的数据值，允许在事务失败或回滚时恢复旧值。

3. **undo日志**: undo日志是实现事务原子性的关键。每次记录的修改都对应至少一条undo日志记录，这些日志记录了旧的记录值，并按照产生的顺序编号。

随着记录被反复更新，每次修改都会生成新的版本并将其添加到版本链的头部。因此，版本链实际上是通过roll_pointer形成的一个链表，链表的每一个节点都包含了记录的一个历史版本。

### （2）ReadView

在InnoDB中，ReadView是MVCC实现中的核心组件之一，用于处理不同隔离级别下的数据可见性问题。ReadView主要用于确定在执行SELECT语句时哪些数据版本对当前事务是可见的。这个机制是理解READ COMMITTED和REPEATABLE READ隔离级别差异的关键。

ReadView包括以下四个主要内容：

1. **m_ids (活跃事务ID列表)**：这是当前系统中所有未提交事务的事务ID列表。这些事务可能对数据库中的数据行进行了修改。

2. **min_trx_id (最小事务ID)**：这是在生成ReadView时活跃的读写事务中最小的事务ID。它帮助判断哪些早期版本的数据行可以被当前事务看到。

3. **max_trx_id (下一个事务ID)**：这是系统将要分配给下一个新事务的ID。这个ID帮助判断哪些数据修改是在当前事务开始后发生的，因此对当前事务不可见。

4. **creator_trx_id (创建者事务ID)**：这是生成该ReadView的事务的ID。这个ID有助于解决当前事务自己对数据所做修改的可见性问题。

当一个事务执行SELECT语句时，InnoDB需要确定每条数据行的哪个版本对该事务可见。ReadView通过以下步骤实现这一目标：

- 如果数据行的最新版本的trx_id小于min_trx_id，意味着该版本是在ReadView生成之前就已经提交的，因此对当前事务可见。

- 如果数据行的最新版本的trx_id大于或等于max_trx_id，意味着该版本是在当前事务之后才创建的，因此对当前事务不可见。

- 如果数据行的trx_id在min_trx_id和max_trx_id之间，需要进一步查看该trx_id是否在m_ids列表中：
  - 如果在m_ids中，说明对应的事务还未提交，该版本对当前事务不可见。
  - 如果不在m_ids中，说明对应的事务已经提交，该版本对当前事务可见。

### （3）READ COMMITTED

**Read Committed** 是一个常用的事务隔离级别，提供了中等级别的隔离。在这个级别下，一个事务中的SELECT语句只能看到其他事务已经提交的修改。这意味着，一个事务在执行期间可能多次执行同一查询，却得到不同的结果，因为其它事务可能在此期间提交了更新。这个级别解决了脏读的问题，但不可重复读和幻读仍然可能发生。

- **特点**：
  - 防止了脏读（Dirty Reads）：不能读取未提交的数据。
  - 允许不可重复读（Non-repeatable reads）：同一事务的不同查询可以返回不同数据。
  - 可能出现幻读（Phantom reads）。

- **工作方式**：在Read Committed隔离级别下，每次执行查询时，InnoDB都会生成一个新的ReadView。这意味着查询只能看到在查询执行时刻之前已经提交的事务所做的更改。

### （4）REPEATABLE READ

**Repeatable Read** 是MySQL的默认事务隔离级别，提供较高的数据一致性保障。在这个级别下，一个事务中的查询可以多次执行，但始终返回第一次查询时的数据快照。这个级别解决了脏读和不可重复读的问题，但在标准SQL中，幻读仍然可能发生。然而，由于MySQL的InnoDB存储引擎使用了独特的锁定读和MVCC机制，它在实践中也能有效防止幻读。

- **特点**：
  - 防止了脏读和不可重复读。
  - 在MySQL的InnoDB引擎中，通过Next-Key Locks也大部分防止了幻读。
  - 提供了一致性查询视图（Consistent Nonlocking Reads），事务中的所有读取查询都看到事务开始时刻的数据快照。

- **工作方式**：在Repeatable Read隔离级别下，事务开始时创建一个ReadView，并在整个事务期间重复使用这个ReadView。这确保了事务内的查询返回一致的结果，即使其他事务已经提交了修改。

**总结**：
- **Read Committed** 和 **Repeatable Read** 主要的区别在于如何处理事务中的查询一致性和何时生成ReadView。
- 在 **Read Committed** 级别，每次查询都可能见到不同的数据状态，因为它允许查询见到在事务外提交的数据改变。
- 在 **Repeatable Read** 级别，事务看到的是一个稳定的数据快照，保证了查询结果的一致性，即使外部事务已经提交了新的更改。

### （5）幻读问题

1. **事务T1** 开始时进行了一次查询：

   T1开始时，创建一个ReadView。这个ReadView中包含了事务开始时刻数据库中所有已提交事务的最新视图。

   ```sql
   SELECT * FROM teacher WHERE number = 30;
   ```
   这时没有找到任何记录，因为还没有number = 30的记录存在。

2. **事务T2** 接着插入了一条新记录：
   ```sql
   INSERT INTO teacher VALUES(30, '豹', '数据湖');
   ```
   该记录的 `trx_id` 被设置为T2的事务ID，并提交。

3. 回到 **事务T1**，执行更新操作：
   ```sql
   UPDATE teacher SET domain = 'RocketMQ' WHERE number = 30;
   ```
   即使这条记录在T1的原始ReadView中不可见，UPDATE操作仍会尝试锁定并更新所有匹配该条件的行。

   此时，由于T2已经提交了新记录，该记录在物理上存在于表中，且没有与任何未完成的事务关联（即T2已提交），因此T1可以锁定并更新它。

   此操作将记录的`trx_id`更新为T1的事务ID，使该记录成为T1的一部分。

4. 当T1再次查询同样的条件时：
   ```sql
   SELECT * FROM teacher WHERE number = 30;
   ```
   由于T1已经修改了这条记录，其 `trx_id` 更新为T1的事务ID，这使得T1现在能够“看到”这条记录，因为它现在匹配T1的ReadView中的可见性条件。

**为什么发生这种情况**

- **MVCC和锁的不同机制**：MVCC通过创建ReadView来保证SELECT语句的一致性视图，但这不影响数据库中实际存在的数据。而UPDATE或DELETE语句会尝试对匹配的数据行加锁，这包括那些在事务开始后插入并已提交的行。
- **ReadView的限制**：ReadView确保事务可以一致地看到事务开始时刻的数据快照，但不阻止事务修改在其执行期间由其他事务提交的数据。因此，如果一个事务在另一个事务提交新记录后执行UPDATE或DELETE，它将能够修改这些新的行。

























