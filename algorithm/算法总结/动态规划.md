# 三、动态规划

## 1.简介

动态规划（Dynamic Programming, DP）是一种通过将原问题分解为相对简单的子问题来解决复杂问题的方法。动态规划不是一种具体的算法，而是一种解决特定问题的策略，因此它广泛应用于多种数据结构和问题类型中。

此外，一些计数或非最优化问题的递推解法有时也被称为动态规划，尽管这种命名并不严格。事实上，动态规划与其他类型的递推有许多相似之处，了解它们之间的异同对学习十分有帮助。

### （1）引入

[P1216 [USACO1.5\] [IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1216)

观察下面的数字金字塔：

![img](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

任务是编写一个程序，找出从顶端到底部的一条路径，使得路径上的数字之和最大。每一步可以走到左下或右下。

例如，在上图中，路径 7→3→8→7→5 产生了最大的数字和。

最直接的方法是尝试所有可能的路径，但由于路径数目是 $O(2^n)$ 级别的，这种方法不可行。

注意到，对于任何一条最优路径，其每一步的决策都是最优的。例如，考虑路径 7→3→8→7，到达第四行第二个数时，没有其他路径可以得到更高的权值。

对每个点来说，下一步只有两种选择：左下或右下（如果存在）。因此，只需记录当前点的最大权值，并用这个最大权值来更新后续点的最大权值，从而减少问题的规模。

但这种方法可能存在子问题重复计算的问题，即同一个子问题可能会被多次求解。为解决这一问题，可以通过“记忆化”的方式存储每个子问题的解，确保每个子问题只被计算一次。

上述内容概述了动态规划的基本思想，接下来的部分将系统地介绍动态规划的各种策略和应用。

### （2）动态规划原理

动态规划适用于解决满足三个核心特性的问题：最优子结构、无后效性和子问题重叠。理解这些特性是掌握动态规划的关键。

#### 最优子结构

最优子结构是指一个问题的最优解包含其子问题的最优解。如果一个问题具有最优子结构，那么可以通过组合子问题的最优解来构造整个问题的最优解。这种特性是动态规划和贪心算法的共同点，但动态规划通常适用于子问题相互重叠且需要全局优化的情形。

意味着，要解决一个大问题的最优解，你可以依赖更小的子问题的最优解来构建。这就像搭建一座大楼，如果每一层都是坚固的，那么整座大楼自然也是坚固的。

为了利用最优子结构，可以采取以下步骤：

1. **确定选择**：证明问题的最优解开始于做出一个选择。
2. **分析子问题**：对于每个可能的首选项，假设其余部分已被解决，并确定由此产生的子问题。
3. **问题简化**：描述子问题空间，并尽量保持其简单。
4. **反证法**：证明每个子问题的解必须是最优的。如果某个子问题的解非最优，则可以用其最优解替换，导致原问题的解更优，与最优解的设定矛盾。

简单例子：找零问题

想象你是一个店主，需要给客人找零95美分。你的抽屉里有25美分、10美分、5美分和1美分的硬币。问题是：如何用最少的硬币数量完成找零？

如果我们用最优子结构的思维来看这个问题，我们会这样思考：

1. **确定选择**：首先选择一个硬币，这个选择应该是使剩下的找零金额最容易解决的硬币。例如，首先选择一个25美分的硬币，因为它值得最多。
2. **分析子问题**：选择了一个25美分硬币后，你现在需要找零70美分（95 - 25）。这个70美分的找零问题就是一个新的子问题。
3. **问题简化**：重复步骤1和2，每次都选择一个最大的硬币，直到找零金额为零。接下来，你可能会再选一个25美分，然后是20美分（两个10美分），最后是5美分。
4. **反证法**：如果你在任何步骤中选择了一个不同的硬币（如开始就用三个10美分而不是一个25美分），你最终将使用更多硬币。因此，每个子问题（如剩余70美分、45美分等）的解决方案都必须是最优的，否则，整个找零过程就不是最优的。

这个例子展示了如何通过解决每个小问题的最优解（最少硬币数量），逐步构建出整个问题的最优解。动态规划正是通过这种方式工作的，只不过它还会存储每个子问题的解，避免重复计算，提高效率。

#### 无后效性

无后效性意味着一旦某个子问题的解被确定后，它就不会被后续的决策影响。这是动态规划中的重要特性，它保证了一旦某个状态被计算，其结果就可以被存储并反复使用，而不需要考虑将来可能的变化。

#### 子问题重叠

动态规划的效率在很大程度上依赖于子问题的重叠性。在许多情况下，不同的递归计算路径会多次遇到同一子问题。通过记忆化技术（通常使用数组或哈希表存储已解决的子问题的解），可以避免重复计算，从而显著提高效率。

子问题的存储不仅节省了计算时间，也简化了问题解决过程，使我们能够仅通过查表来获取已解决子问题的结果，这是动态规划与普通递归或贪心算法的显著区别。

### （3）基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 有向无环图，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题。

## 2.记忆化搜索

记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

### （1）引入

[P1048 [NOIP2005 普及组\] 采药 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1048)

#### 朴素的 DFS做法

#### 优化

### （2）与递推的联系与区别

### （3）如何写记忆化搜索

#### 方法一

#### 方法二

所谓“无需外部变量”的 DFS 是指在递归过程中不依赖于类或全局作用域的变量来存储结果，而是通过递归的返回值来传递结果。

## 3.背包DP

## 4.区间DP

## 5.DAG上的DP

## 6.树形DP

## 7.状压DP

## 8.数位DP

## 9.计数DP

## 10.动态DP

## 11.概率DP

## 12.DP优化

## 13.其他DP方法