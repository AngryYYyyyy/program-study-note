## 1.什么是算法

算法(algorithm，[ˈælɡərɪðəm]，计算程序)：就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。

算法（algorithm）是解决一系列问题的清晰指令，也就是，能对一定规范的输入，在有限的时间内获得所要求的输出。

简单来说，算法就是解决一个问题的具体方法和步骤。

程序 = 算法+数据结构

### （1）特征

**可行性**：算法中执行的任何计算步骤都可以分解为基本可执行的操作步，即每个计算步都可以在有限时间里完成（也称之为有效性）。

**确定性**：算法的每一步都要有确切的意义，不能有二义性。例如“增加x的值”，并没有说增加多少，计算机就无法执行明确的运算。

**有穷性**：算法的有穷性是指算法必须在执行有限个步骤后终止。操作次数不宜过大，不能超过人们事先设定的时间限制。

**输入**：算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法已经给出了初始条件。

**输出**：一个算法可能有1个或多个输出，以反映输入数据加工后的代码，没有输出的算法是没有意义的！

### （2）**算法的评价**

通常一个好算法应该达到如下目标：

**正确性**：算法应该正确的解决问题。

**可读性**：算法应该具有较好的可读性，让人们理解算法的作用。

**健壮性**：输入非法数据时，算法也可以做出适当的反应，而不会产生奇奇怪怪的输出。

## 2.复杂度

时间复杂度和空间复杂度是衡量一个算法效率的重要标准。

### （1）基本操作数

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。

对基本操作的计数或是估测可以作为评判算法用时的指标。

### （2）时间复杂度

评估程序所需要的时间。

| 复杂度 | 标记符号              | 说明                                 |
| ------ | --------------------- | ------------------------------------ |
| 常量   | O(1)                  | 操作数量为常数，与输入数据的规模无关 |
| 对数   | O(log2 n)             | 与输入数据的比例是 log2（n）         |
| 线性   | O(n)                  | 与输入数据成正比                     |
| 平方   | O(n²)                 | 与输入数据规模的比例为平方           |
| 立方   | O(n³)                 | 与输入数据规模的比例为立方           |
| 指数   | O(2ⁿ)   O(kⁿ)   O(n!) | 快速增长，尽量减少这种代码           |

### （2）空间复杂度

评估程序所需要的储存空间。空间复杂度一般不作考虑，一般都优先考虑时间复杂度。

## 3.对数器

对数器是在计算机科学和编程竞赛中用来验证算法正确性的一种工具。其核心目的是通过与一个已知正确但效率较低的方法进行比较来测试一个新算法的正确性。这种方法特别适用于那些在提交给比赛评判系统后，系统只告诉你是否正确而不指出错误位置的情况。下面是对对数器的一个详细概念和使用方法的说明：

对数器是一种测试工具，用于比较两个方法的执行结果是否一致，从而验证被测试方法的正确性。它通常由以下几部分组成：

1. **待测方法（a）**：这是你开发的新方法，用于解决某个具体问题。
2. **对比方法（b）**：一个已知正确但复杂度较高的方法。这个方法的作用是作为标准来验证待测方法的正确性。
3. **随机样本生成器**：用于产生大量随机输入数据，以全面测试方法a和方法b。
4. **对比验证程序**：对比方法a和方法b的输出，确认两者是否一致。

主要用于开发过程中自我检验算法的正确性，特别是在没有外部错误反馈的环境中，如算法竞赛或独立测试场景。

在Java中生成一个随机数组，可以指定数组的最大长度和元素的最大值，你可以使用以下方法：

```java
import java.util.Random;
public class RandomArrayGenerator {
    public static int[] generateRandomArray(int maxLength, int maxValue) {
        Random random = new Random();
        // 随机生成数组的长度，从1到maxLength
        int length = random.nextInt(maxLength) + 1;
        int[] array = new int[length];
        
        // 填充数组，元素值范围为0到maxValue（包括0，不包括maxValue）
        for (int i = 0; i < length; i++) {
            array[i] = random.nextInt(maxValue);
        }
        return array;
    }
}
```

这段代码实现了一个名为`RandomArrayGenerator`的类，其中包含一个名为`generateRandomArray`的方法，该方法接收最大长度`maxLength`和最大值`maxValue`作为参数，然后返回一个随机生成的整数数组。数组的长度是随机的，介于1和`maxLength`之间，数组中每个元素的值介于0和`maxValue`（不包括`maxValue`）之间。

## 4.枚举

### （1）简介

枚举（Enumerate）是基于已有知识来猜测答案的一种问题求解策略。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

### （2）要点

**给出解空间**

建立简洁的数学模型。

枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素？

**减少枚举的空间**

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

**选择合适的枚举顺序**

根据题目判断。比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。

### （3）例题

题目：一个数组中的数互不相同，求其中和为0的数对的个数。

分析：

枚举两个数的代码很容易就可以写出来。

但是两个数是否都一定要枚举出来呢？枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数）的条件，如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。较为进阶地，在数据范围允许的情况下，我们可以使用桶记录遍历过的数。

```java
package conclusion.algorithm_basics.enums;

import java.util.Arrays;

/**
 * @Author ：AngryYYYYYY
 * @Date ：Created in 2024/8/12 21:54
 * @Description：计算数组中和为0的数对的个数。
 */
public class Solution01 {
    public static void main(String[] args) {
        // 示例数组
        int[] arr = {-3, -2, -1, 0, 1, 2, 3, 4};
        
        // 调用process方法，计算和为0的数对的个数
        int result = process(arr);
        
        // 输出结果
        System.out.println(result);
    }

    /**
     * 计算给定数组中和为0的数对的个数。
     *
     * @param array 输入的整数数组，元素互不相同
     * @return 和为0的数对的个数
     */
    private static int process(int[] array) {
        int answer = 0;

        // 找到数组中元素绝对值的最大值
        // 用于映射负数的索引
        int max = Arrays.stream(array).map(Math::abs).max().getAsInt();

        // 创建一个大小为2*max+1的布尔数组，用来记录数组中出现的元素
        boolean[] bucket = new boolean[2 * max + 1];

        // 遍历数组中的每个元素
        for (int i = 0; i < array.length; i++) {

            // 如果存在一个元素，使得当前元素和它的和为0，则计数器加1
            if (bucket[max - array[i]]) {
                answer++;
            }

            // 将当前元素标记为已出现
            bucket[max + array[i]] = true;
        }

        // 返回和为0的数对的个数
        return answer;
    }
}

```

## 5.模拟

### （1）简介

模拟就是用计算机来模拟题目中要求的操作。

模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。

### （2）要点

写模拟题时，遵循以下的建议有可能会提升做题速度：

- 在动手写代码之前，在草纸上尽可能地写好要实现的流程。
- 在代码中，尽量把每个部分模块化，写成函数、结构体或类。
- 对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 "YY-MM-DD 时：分" 把它抽取到一个函数，处理成秒，会减少概念混淆。
- 调试时分块调试。模块化的好处就是可以方便的单独调某一部分。
- 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

对于Java编程来说，要学习stream、集合、lambda以及String、Math、Arrays等工具类能够有效提高模拟的效率。

### （3）例题

华为od：

2024D-API 集群负载统计

2024D-整数对最小和

2024D-回收银饰

2024D-字符串分割（二）

2024D-GPU调度

2024D-整数分解

2024D-攀登者1

2024D-攀登者2（90%）

2024D-小明能到达的最大坐标值

2024D-素数之积

2024D-高效货运

2024D-结队编程

2024D-螺旋数字矩阵

2024D-灰度图恢复

2024D-来自异国的客人

2024D-数组去重和排序

2024D-学生重新排队（90%）

算法体系：

## 6.递归&分治

### （1）递归

递归（Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。

#### 引入

> 要理解递归，就得先理解什么是递归。

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。

以下是一些有助于理解递归的例子：

1. 如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。
2. 你今年几岁？答：去年的岁数加一岁，1999 年我出生。

递归在数学中非常常见。例如，集合论对自然数的正式定义是：1 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

```java
int func(int value) {
  if (value == 终止条件) return 最小子问题解;
  return func(缩小规模的value);
}
```

#### 为什么要写递归

1. 结构清晰，可读性强。例如，分别用不同的方法实现归并排序：

   ```java
   // 不使用递归的归并排序算法
   public void mergeSort(int[] a) {
       int n = a.length;
       for (int seg = 1; seg < n; seg += seg) {
           for (int start = 0; start < n - seg; start += seg + seg) {
               merge(a, start, start + seg - 1, Math.min(start + seg + seg - 1, n - 1));
           }
       }
   }
   
   // 使用递归的归并排序算法
   public void mergeSort(int[] a, int front, int end) {
       if (front >= end) return;
       int mid = front + (end - front) / 2;
       mergeSort(a, front, mid);
       mergeSort(a, mid + 1, end);
       merge(a, front, mid, end);
   }
   ```

   显然，递归版本比非递归版本更易理解。递归版本的做法一目了然：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug，且难以调试。

2. 练习分析问题的结构。当发现问题可以被分解成相同结构的小问题时，递归写多了就能敏锐发现这个特点，进而高效解决问题。

#### 递归的缺点

在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 **栈溢出** 的后果。

显然有时候递归处理是高效的，比如归并排序；**有时候是低效的**，比如简单递推场景，因为栈会消耗额外空间。例如，计算链表长度的例子：

```java
// 典型的递推遍历框架
public int size(Node head) {
    int size = 0;
    for (Node p = head; p != null; p = p.next) {
        size++;
    }
    return size;
}

// 使用递归实现
public int sizeRecursion(Node head) {
    if (head == null) return 0;
    return sizeRecursion(head.next) + 1;
}
```

#### 递归的优化

搜索优化和记忆化搜索

比较初级的递归实现可能递归次数太多，容易超时。这时需要对递归进行优化。

### （2）分治

分治（Divide and Conquer）的字面解释是「分而治之」，即将一个复杂的问题分解成两个或更多的相同或相似的子问题，直至子问题简单到可以直接求解，最终将这些子问题的解合并以解决原问题。

#### 过程

> 如果各子问题不独立，即分治法需要重复解决公共子问题，那么尽管分治法仍可使用，通常采用动态规划会更为合适。

分治算法的核心思想就是「分而治之」，其大致流程可分为三步：分解 -> 解决 -> 合并。

1. **分解**：将原问题分解为结构相同的子问题。
2. **解决**：递归地解决这些子问题，直至达到易于解决的边界。
3. **合并**：将各子问题的解整合为原问题的解。

适合采用分治法的问题通常具有以下特征：

- 问题的规模缩小到一定程度就可以简单直接解决。
- 问题可以分解为若干个规模较小的相同问题，即问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
- 分解出的子问题相互独立，即子问题间不包含重复的子问题。

以归并排序为例，假设实现归并排序的函数名为 `mergeSort`。这个函数的职责是对传入的数组进行排序。这个问题显然可以分解：对数组的左右两半分别排序，然后合并。

```java
void mergeSort(int[] array) {
  if (array.length <= 1) return;
  int mid = array.length / 2;
  int[] left = Arrays.copyOfRange(array, 0, mid);
  int[] right = Arrays.copyOfRange(array, mid, array.length);
  
  mergeSort(left);
  mergeSort(right);
  merge(left, right, array);
}
```

传给它半个数组，那么处理完后这半个数组就已经被排好了。注意到，`mergeSort` 与二叉树的后序遍历模板极其相似。因为分治算法的套路是 **分解 -> 解决（触底）-> 合并（回溯）**，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。

`merge` 函数的实现方式与两个有序链表的合并一致。

#### 要点

**理解函数的职责并信任它能完成任务**。避免深入探究函数的具体实现细节，否则容易陷入细节中无法自拔。函数的设计就是为了解决一部分问题，不需要一次性解决所有问题。

以遍历二叉树为例。

```java
void traverse(TreeNode root) {
  if (root == null) return;
  traverse(root.left);
  traverse(root.right);
}
```

这几行代码足以遍历任何一棵二叉树。对于递归函数 `traverse(root)`，只需相信给定根节点 `root`，它就能遍历整棵树。因此，只需要将节点的左右子节点传递给同一个函数即可。

同样的方法也适用于遍历 N 叉树，其递归遍历代码与二叉树的遍历类似，只是在处理子节点时使用循环，不过，对于 N 叉树，显然没有中序遍历：

```java
void traverseNaryTree(Node root) {
  if (root == null) return;
  for (Node child : root.children) {
    traverseNaryTree(child);
  }
}
```

#### 区别

递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

## 7.贪心

### （1）简介

贪心算法（Greedy Algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

### （2）证明

在使用贪心算法时，通常需要证明其正确性，即证明其传递性。

这里建议先不要去练习证明，因为贪心是最具自然智慧的算法，主要是通过阅历和经验进行提升。

### （3）要点

#### 特点

- 局部最优选择
- 无回溯

#### 常见题型

贪心算法在比赛和实际问题中典型的应用场景：

1. **排序后选择**：将问题的元素按照某种标准排序，然后按顺序做出选择，例如活动选择问题。
2. **动态选择**：在处理过程中动态地选择当前最优解，如使用优先队列或比较处理相关问题。

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

具体一些

- **资源分配问题**：如背包问题（在不同的场景下可能需要使用贪心算法、动态规划等不同策略）。
- **图的最小生成树**：如Prim算法和Kruskal算法。
- **图的最短路径问题**：如Dijkstra算法。
- **数据压缩**：如哈夫曼编码。

脱离算法的限制，用最朴实的自然zhi'hui

#### 与动态规划的区别

- **贪心算法**：通常只做出在某种意义上的局部最优解决策，并且一旦做出这些决策，就不会撤销。
- **动态规划**：保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法的效率通常高于动态规划，但是它的应用也更受限，因为它依赖于问题具有“贪心选择性质”（每步所做的贪心选择将导致全局最优解），这一性质并非所有问题都具备。

### （3）例题

#### 华为od：

2024D-停车场车辆统计

2024D-虚拟游戏理财

2024D-贪心歌手

2024D-任务处理

2024D-小朋友来自多少小区

2024D-座位调整（边界判断模板）

2024D-分割均衡字符串

2024D-变换最小字符串

2024D-伐木工

2024D-停车找车位

2024D-社交距离

2024D-会议室占用时间

#### 算法体系：

字符串拼接最小字典序

会议室安排

最低成本分割金条

IPO项目选择

点灯

#### leetcode：

买卖股票最佳时机

跳跃游戏Ⅰ

跳跃游戏Ⅱ

划分字母区间

## 8.排序

## 9.前缀和&差分

### （1）前缀和

前缀和是一个数组的元素的累计总和，通常用于减少重复的计算，是一种重要的预处理方式,提高区间和查询的效率。

#### 一维前缀和

前缀和数组`prefix[]`的第`i`项，代表原数组`arr[]`从第一个元素到第`i`个元素的总和。即：

$\[ \text{prefix}[i] = \sum_{j=1}^{i} \text{arr}[j] \]$

前缀和的计算公式可以表示为：

$\[ \text{prefix}[i] = \text{prefix}[i-1] + \text{arr}[i] \]$

其中，`prefix[0]`通常设为0，方便计算从数组第一个元素开始的和。

示例：求长度为n的数组的前缀和，并且作用于求区间和

```java
int n = arr.length;
int[] prefixAnd=new int[n+1];
prefixAnd[0]=0;
for(int i=1;i<=n;i++){
    prefixAnd[i]=prefixAnd[i-1]+array[i];
}
```

则[start,end]区间和为

```java
prefixAnd[end+1]-prefixAnd[start]
```

当然如果不处理则

```java
prefixAnd[end] - (start == 0 ? 0 : prefixSums[start - 1])
```

示例：如果该数组是环形数组，那么如何求[start,end]区间，注意start>end的情况会因为环形数组出现

如果start <= end

```java
prefixAnd[end] - (start == 0 ? 0 : prefixAnd[start - 1])
```

如果start>end转换为求取[start,n-1]和[0,end]

我们也可以扩容数组（n*2），例如{1,2,3,4}-->{1,2,3,4,1,2,3,4}并建立前缀和

```java
int n = arr.length;
prefixAnd = new int[2 * n];
prefixAnd[0] = arr[0];
for (int i = 1; i < 2 * n; i++) {
    prefixAnd[i] = prefixAnd[i - 1] + arr[i % n];
}
```

则[start,end]区间和为

start>end

```java
prefixAnd[end+n]- (start == 0 ? 0 : prefixAnd[start - 1])
```

start <= end

```java
prefixAnd[end]- (start == 0 ? 0 : prefixAnd[start - 1])
```



#### 二维/多维前缀和

对于二维或多维数组，前缀和的概念可以扩展以支持快速计算任意子矩阵或子体的和。在二维的情况下，如果有一个`m x n`的矩阵`matrix[][]`，其前缀和`prefix[][]`可以定义为：

$\[ \text{prefix}[i][j] = \sum_{p=1}^{i} \sum_{q=1}^{j} \text{matrix}[p][q] \]$

二维前缀和的计算公式为：

$\[ \text{prefix}[i][j] = \text{prefix}[i-1][j] + \text{prefix}[i][j-1] - \text{prefix}[i-1][j-1] + \text{matrix}[i][j] \]$

这里，`prefix[i-1][j]` 和 `prefix[i][j-1]` 分别是上方和左方的前缀和，而`prefix[i-1][j-1]`被加回因为它被计算了两次。

这种方法基于容斥原理，允许我们在常数时间内求出任意子矩阵的和，只需要一次简单的加减运算。使用二维前缀和可以有效处理二维空间的累加问题，尤其是在处理图像、统计和动态规划问题中非常有用。

二维前缀和的应用示例包括图像处理中的区域亮度计算、二维区间查询等。在多维情况下，前缀和的概念也可以类似地扩展，虽然随着维度的增加，计算和存储的复杂性也会增加。

### （2）差分

### （3）例题

#### 前缀和

华为od：

2024D-查找接口成功率最优时间段

2024D-分割数组的最大差值

2024D-环中最长字串2（需优化）

## 10.二分查找

### （1）简介

二分查找（binary search），也称为折半搜索（half-interval search）或对数搜索（logarithmic search），是一种在有序数组中查找特定元素的高效算法。它通过每次查找过程中将搜索区间减半，从而快速定位元素是否存在。

#### 工作原理

在升序数组中查找元素时：

1. 比较数组中间元素与目标值：
   - 如果中间元素等于目标值，搜索结束。
   - 如果中间元素小于目标值，继续在右侧子数组中搜索。
   - 如果中间元素大于目标值，继续在左侧子数组中搜索。

#### 复杂度

时间复杂度：最坏情况和平均情况为\(O(\log n)\)，其中 \(n\) 是数组长度。

空间复杂度：在迭代实现中，二分查找只需要常数空间\(O(1)\)。

### （2）实现

**优化：**

- 使用 `n >> 1` 替代 `n / 2` 可以减少指令数，尤其是当你确定 `n` 是非负数时。
- 通过计算 `left + (right - left) / 2` 而不是 `(left + right) / 2` 来避免潜在的整数溢出。
- 该实现为[]的写法，当然可以根据情况调整

```java
private static int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1); // 避免溢出，同时使用位运算提高效率
        if (arr[mid] < target) {
            left = mid + 1;  // 目标在右侧
        } else if (arr[mid] > target) {
            right = mid - 1; // 目标在左侧
        } else {
            return mid;      // 找到目标
        }
    }
    return -1;              // 未找到目标
}
```

二分搜索法不仅可用于在有序数组中查找元素，还可应用于解决一些涉及优化决策和答案区间的问题，如“最大值最小化”等二分答案的问题。这类问题通常要求我们找到满足特定条件的最优值，并且答案具有某种单调性，使得二分搜索成为理想的解决方案。

### （3）二分答案

"二分答案" 是一种解题策略，广泛应用于解决那些答案可能在一定范围内并且满足某种单调性条件的问题。在这种策略中，你不是去枚举每一个可能的答案来检验其正确性，而是通过二分搜索法来更高效地缩小答案的可能范围。

在“二分答案”的方法中，你通常会遇到这样一类问题：需要确定一个最优值（例如最大值最小、最小值最大），且这个最优值满足某种判断条件（如是否可行、是否符合要求等）。

#### 二分答案的适用条件

1. **固定的答案区间**：你知道可能的最大值和最小值，即答案存在于一个明确的区间内。
2. **单调性**：如果某个值是可行的，那么在这个值的一侧（取决于问题是求最大还是最小）的所有值也都是可行的。这种单调性是应用二分搜索的关键。
3. **判断函数**：该函数用于检验中间值 `mid` 是否满足题目条件。接着，通过调整搜索范围（上限或下限），逐步逼近答案。

#### 示例

考虑一个问题，比如确定一个最小的速度，使得在该速度或更高速度下，一个车辆可以在规定时间内完成一定距离的行驶。

假设速度范围是从 1 km/h 到 100 km/h。你会这样使用二分答案：

- **设定初始范围**：low = 1, high = 100。
- **二分搜索**：
  - 计算中值 `mid = (low + high) / 2`。
  - 通过一个函数 `canComplete(mid)` 检验在速度 `mid` 下是否可以完成任务。
  - 如果 `canComplete(mid)` 返回 true，说明至少可以在这个速度下完成任务，因此尝试更小的速度，即调整上限 `high = mid`。
  - 如果返回 false，说明即使是这个速度也不能完成任务，因此需要更高的速度，即调整下限 `low = mid + 1`。
- **终止条件**：当 `low` 与 `high` 相遇时，即找到了满足条件的最小速度。

与枚举所有可能值相比，二分答案大幅减少了计算次数，特别是在答案范围较大时。

通过二分答案，复杂的优化问题可以转化为一系列可操作的判断任务，从而有效地找到最优解。这种策略提高了解决问题的效率和可扩展性，是算法设计中的一种重要技巧。

### （4）最大值最小化

“最大值最小化”问题常见于如分配、装载、调度等场景，其中我们需要将一系列资源或任务分配到若干组中，使得各组中“最不理想”的情况尽可能地“最理想”。例如，分割数组、最大工作负载最小化等。

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做1，不满足看做0 ，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

#### 条件

要使用二分搜索解决这类问题，需确保以下条件：

1. **固定的答案区间**：必须知道可能的答案范围，即最小值和最大值。

2. **判断条件的可实现性**：需要一个有效的方法来判断任何一个给定的中间值是否可行（可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值的可行性）。

3. **答案的单调性**：如果一个特定的值是可行的，那么在一个方向上所有的值也应该是可行的（例如，如果某个载重量能承受，则更大的载重量也应当能承受）。

#### 实现策略

使用二分搜索来不断调整答案范围，直至找到最优解：

```java
//[)
int binarySearchMinimizeMax(int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (isFeasible(mid)) {
            high = mid; // 如果mid可行，则可能的最大值可以更小
        } else {
            low = mid + 1; // 如果mid不可行，需要增加值
        }
    }
    return low; // low 和 high 会收敛到最小的可行解
}
```

适用于很多看似不是搜索问题的优化问题，尤其是在解的单调性可以被明确的情况下。

考虑一个问题，比如要将一组作业分配给k个工人，使得每个工人的最大工作量尽可能小。这里，我们可以使用二分搜索来确定这个“最大工作量”的最小可能值。

### （5）例题

华为od：

2024D-部门人力分配

2024D-项目排期

2024D-孙悟空吃蟠桃

2024D-小明找位置

## 11.倍增

## 12.构造