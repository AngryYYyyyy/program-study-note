# 网络基础（二）

# 一、再谈协议

## 1.1 协议

> 协议是一种约定：由逻辑代码和数据共同实现
>
> ==协议通常指的是为实现某个层的功能而定义的规则==

## 1.2 协议分层

> 可以实现逻辑分层、解耦
>
> ==物理层提供传输能力，软件层提供传输方法==
>
> ==协议分层的特点意味着必须做到将报头和有效数据封装、解包以及分用的功能==

# 二、结构化数据

> 结构化数据在数据传输中存在因不同机器大小端、对齐方式不同的问题，而造成数据传输失败的问题
>
> ==通过制订特定的协议方式，对数据进行处理，相当于加了一层软件层==

## 2.1序列化

> ==序列化是将数据结构或对象转换为一个字节流的过程，这样可以将其存储到文件、数据库中或通过网络传输==。

### 2.1.1 基于计算机的请求、响应的序列化

```c++
void serialize(std::string *package)
{
    //协议："_x op _y"
    *package=std::to_string(_x)+SPACE+_op+SPACE+std::to_string(_y);
}
void serialize(std::string *package)
{
    //协议："_exitCode _result"
    *package=std::to_string(_exitCode)+SPACE+std::to_string(_result);
}
```



## 2.2 反序列化

> ==反序列化是将字节流转回其原始数据结构或对象的过程。==

### 2.2.1 基于计算机的请求、响应的序列化

```c++
bool deserialize(std::string &package)
{
    //将字节流"_x op _y"数据赋予到结构体数据中 
    size_t space1=package.find(SPACE);
    if(space1==std::string::npos){return false;}
    size_t space2=package.rfind(SPACE);
    if(space2==std::string::npos){return false;}
    _x=atoi(package.substr(0,space1).c_str());
    _y=atoi(package.substr(space2+SPACE_LEN).c_str());
    _op=*package.substr(space1+SPACE_LEN,space2-space1+1).c_str();
    return true;
}
bool deserialize(const std::string &package)
{
    size_t pos=package.find(SPACE);
    if(pos==std::string::npos){return false;}
    _exitCode=atoi(package.substr(0,pos).c_str());
    _result=atoi(package.substr(pos+SPACE_LEN).c_str());
    return true;
}
```



## 2.3 序列化/反序列化方法

> **JSON**: ==轻量级的数据交换格式==，经常用于web应用中。例如，JavaScript中的`JSON.parse()`和`JSON.stringify()`。
>
> **XML**: 一个标记语言，用于编码文档中的数据。例如，Java中的JAXB。
>
> **Protocol Buffers (protobuf)**: Google开发的一个高效的二进制序列化格式。
>
> **MessagePack**: 另一个效率高、紧凑的二进制序列化格式。

### 2.3.1基于json的序列化/反序列化

```c++
#include <jsoncpp/json/json.h>
class Request
{
    void serialize(std::string *out)
    {
        //json
        // 1. Value对象，万能对象
        // 2. json是基于KV
        // 3. json有两套操作方法
        // 4. 序列化的时候，会将所有的数据内容，转换成为字符串
        Json::Value root;
        root["x"] = x_;
        root["y"] = y_;
        root["op"] = op_;
        Json::FastWriter fw;
        // Json::StyledWriter fw;
        *out = fw.write(root);
    }
    
    
    bool deserialize(std::string &in)
    {
        //json
        Json::Value root;
        Json::Reader rd;
        rd.parse(in, root);
        x_ = root["x"].asInt();
        y_ = root["y"].asInt();
        op_ = root["op"].asInt();
        return true;
    }
};


class Response
{
    void serialize(std::string *out)
    {
        //json
        Json::Value root;
        root["exitcode"] = exitCode_;
        root["result"] = result_;
        Json::FastWriter fw;
        // Json::StyledWriter fw;
        *out = fw.write(root);
    }
    bool deserialize(std::string &in)
    {
        //json
        Json::Value root;
        Json::Reader rd;
        rd.parse(in, root);
        exitCode_ = root["exitcode"].asInt();
        result_ = root["result"].asInt();
        return true;
    }
```

> 注意：
>
> 可以使用`#define`==定义宏来选择序列化/反序列化的方法==，也可以在命令行上定义宏，这在多个编译环境中都是可能的。
>
> ```c++
> #define _MY_METHOD_
> #ifdef _MY_METHOD_
> //...自定义方法
> #else
> //...json方法等
> #endif
> ```
>
> 以`gcc`和`g++`为例，使用`-D`选项在命令行上定义宏。
>
> ```
> g++ -D_MY_METHOD_ -o $@ $^ -std=c++11 -lpthread
> ```
>
> 命令行定义的宏是全局的，会影响所有编译单元，除非显式地在代码中使用`#undef`取消定义。

## 2.4 自描述长度

> 在网络通信、文件存储和其他需要序列化/反序列化的场景中，数据往往是分块或多次发送的，常常需要一种方式来判断数据的完整性。为此，我们经常==将四字节的字符串长度大小放到结构化数据的开头==，称为“自描述长度”或“前缀长度”，这样接收方可以轻松地知道要读取的数据量。

### 2.4.1 编码 (Encode)

> 1. 将数据按照协议转换为特定的字节流，为后续判断数据的完整性做准备。
> 4. 将这个字节流的长度值放在数据之前，然后发送或存储整个数据。
>

```c++
std::string encode(const std::string &package,uint32_t len)
{
    // data  ->  len\r\n data \r\n
    return std::string encodePackage=to_string(len)+CRLF+package+CRLF;
}
```

### 2.4.2 解码 (Decode)

> 1. 首先读取数据的长度值转换回整数，并通过输出型参数传递，判断数据的完整性。
> 2. 读取该长度值所表示的字节数量的数据。
> 3. 清空读取的数据，以便后续数据的解码
>

```c++
std::string decode(std::string &package,uint32_t *len)
{
    //num\r\n data \r\n  ->  data
    size_t pos=package.find(CRLF);
    if(pos==std::string::npos){return "";}
    //读取数据的长度值
    uint32_t packageLen=atoi(package.substr(0,pos).c_str());
    //读取该长度值所表示的字节数量的数据
    std::string decodePackage=package.substr(pos+CRLF_LEN,packageLen);
    //设置输出型参数
    *len=packageLen;
    //清空读取的数据
    uint32_t removeLen = package.substr(0,pos).size() + packageLen + 2 * CRLF_LEN;
    package.erase(0,removeLen);
    return decodePackage;
}
```



## 2.5 实现网络版本计算机

### 2.5.1 Protocol.hpp

```c++
#pragma once
#include <string>
#define CRLF "\r\n"    //响应拆分符
#define CRLF_LEN strlen(CRLF)
#define SPACE " "
#define SPACE_LEN strlen(SPACE)
#define OPS "+-*/%"
std::string encode(const std::string &package,uint32_t len)
{
    // data-> num\r\n data \r\n
    std::string encodePackage;
    encodePackage=to_string(len)+CRLF+package+CRLF;
    return encodePackage;
}


std::string decode(std::string &package,uint32_t *len)
{
    //num\r\n data \r\n.....->data
    size_t pos=package.find(CRLF);
    if(pos==std::string::npos){return "";}
    uint32_t packageLen=atoi(package.substr(0,pos).c_str());
    std::string decodePackage;
    decodePackage=package.substr(pos+CRLF_LEN,packageLen);
    *len=packageLen;
    uint32_t removeLen = package.substr(0,pos).size() + packageLen + 2 * CRLF_LEN;
    package.erase(0,removeLen);
    return decodePackage;
}



class request
{
public:
    request(){}
    ~request(){}
public:
    void serialize(std::string *package)
    {
        //"_x op _y"
        *package=std::to_string(_x)+SPACE+_op+SPACE+std::to_string(_y);
    }
    bool deserialize(std::string &package)
    {
        //"_x op _y"-> x op y
        size_t space1=package.find(SPACE);
        if(space1==std::string::npos){return false;}
        size_t space2=package.rfind(SPACE);
        if(space2==std::string::npos){return false;}
        _x=atoi(package.substr(0,space1).c_str());
        _y=atoi(package.substr(space2+SPACE_LEN).c_str());
        _op=*package.substr(space1+SPACE_LEN,space2-space1+1).c_str();
        return true;
    }


    void debug()
    {
        std::cout << "#################################" << std::endl;
        std::cout << "x_: " << _x << std::endl;
        std::cout << "op_: " << _op << std::endl;
        std::cout << "y_: " << _y << std::endl;
        std::cout << "#################################" << std::endl;
    }
public:
    int _x;
    int _y;
    char _op;
};

class response
{
public:
    response():_exitCode(0), _result(0){}
    ~response(){}
public:
    void serialize(std::string *package)
    {
        //"_exitCode _result"
        *package=std::to_string(_exitCode)+SPACE+std::to_string(_result);
    }
    bool deserialize(const std::string &package)
    {
        size_t pos=package.find(SPACE);
        if(pos==std::string::npos){return false;}
        _exitCode=atoi(package.substr(0,pos).c_str());
        _result=atoi(package.substr(pos+SPACE_LEN).c_str());
        return true;
    }


    void debug()
    {
        std::cout << "#################################" << std::endl;
        std::cout << "_exitCode: " << _exitCode << std::endl;
        std::cout << "_result: " << _result << std::endl;
        std::cout << "#################################" << std::endl;
    }
public:
    int _exitCode;
    int _result;
};


bool makeReuquest(const std::string &str, request *req)
{
    char buffer[1024];
    snprintf(buffer, sizeof buffer, "%s", str.c_str());
    //解析左操作数
    char *left = strtok(buffer, OPS);
    if (!left) return false;
    //解析右操作数
    char *right = strtok(nullptr, OPS);
    if (!right) return false;
    req->_op = str[strlen(left)];
    req->_x = atoi(left);
    req->_y = atoi(right);
    return true;
}
```

### 2.5.2 calServer.cpp

#### netCal的流程

**数据读取与处理**

- **分块读取数据**：由于网络数据传输可能会分块到达，循环中使用 `read` 函数读取socket数据是恰当的。你正确地处理了读取0字节（对方关闭socket）和读取错误的情况。
- **拼接收到的数据包**：你使用了一个字符串 `receivePackage` 来累积读取到的数据。这是处理TCP数据流的常见做法，因为TCP保证了数据的顺序，但不保证一次读取的完整性。

**数据完整性检查**

- **解码与数据完整性检查**：通过调用 `decode` 函数并检查返回的长度，你尝试验证数据的完整性。这是处理基于长度或标记的协议的典型方法。确保在接收完整的数据包前不处理数据是重要的。

**数据处理与响应**

- **请求处理**：通过反序列化解码后的数据包到 `request` 对象，进行计算，并生成响应，展示了典型的请求-响应服务逻辑。
- **响应序列化与编码**：你序列化响应对象，然后对其进行编码准备发送。确保正确地处理了数据编码和发送准备工作。

**发送数据**

- **发送响应**：使用 `write` 函数将编码后的数据包发送给客户端。

```c++
//以下并不是完整的代码，可以选择基于线程池TCP服务器
static response calculator(const request &req)
{
    response resp;
    switch (req._op)
    {
    case '+':resp._result = req._x + req._y;break;
    case '-':resp._result = req._x - req._y;break;
    case '*':resp._result = req._x * req._y;break;
    case '/':
        { 
            if (req._y == 0) resp._exitCode = -1; //除零错误，退出码设为-1
            else resp._result = req._x / req._y;
        }
    break;
    case '%':
        { 
            if (req._y == 0) resp._exitCode = -2; //模零错误，退出码设为-2
            else resp._result = req._x % req._y;
        }
    break;
    default:
        resp._exitCode = -3; // 非法操作符，退出码设为-3
        break;
    }
    return resp;
} 



void netCal(int sock)
{
    std::string receivePackage;
    while(true)
    {
        char buffer[1024];
        //数据的传输可能存在分块传输，并不总是完整的数据
        ssize_t s=read(sock,buffer,sizeof(buffer)-1);
        if (s == 0)
        {
            //写端关闭
            logMessage(NOTICE, "client close sock, service done");
            break;
        }
        else if (s < 0)
        {
            //读取失败
            logMessage(WARINING, "read client error, errorcode: %d, errormessage: %s",
                       clientIp.c_str(), clientPort, errno, strerror(errno));
            break;
        }
        //请求数据包接收成功
        buffer[s]='\0';
        receivePackage+=buffer;
        //解码去掉自描述信息，返回自描述信息
        uint32_t len=0;
        std::string decodeReceivePackage =decode(receivePackage,&len);
        //对数据的完整性做检查
        if(len==0){continue;}
        //对请求数据包反序列化
        request req;
        req.deserialize(decodeReceivePackage);
        //进行计算服务，并做出响应
        response resp=calculator(req);
        //将相应信息序列化进响应（传输）数据包
        std::string transmitPackage;
        resp.serialize(&transmitPackage);
        //编码
        std::string encodeTransmitPackage= encode(transmitPackage,transmitPackage.size());
        // 将编码后的包发送给客户端
		write(sock, encodeTransmitPackage.c_str(), encodeTransmitPackage.size());
    }
}
```

### 2.5.3 calClient.cpp

```c++
//以下并不是完整的代码，可以选择TCP模式的客户端
//控制服务的终止
volatile bool quit = false;
void loop()
{
    std::string message;
    while (!quit)
    {
        message.clear();
        std::cout << "请输入你的消息>>> ";
        std::getline(std::cin, message);
        if (strcasecmp(message.c_str(), "quit") == 0)
        {
            //退出服务
            quit = true;
            continue;
        }
        //生成请求结构化数据
        request req;
        //解析message，获取两个操作数和一个操作符，填充到request对象中
        if (!makeReuquest(message, &req)){continue;}
        //将请求序列化进请求（传输）包
        std::string transmitPackage;
        req.serialize(&transmitPackage); 
        //编码
        std::string encodeTransmitPackage = encode(transmitPackage, transmitPackage.size()); 
        //将编码后的包发送给服务端
        ssize_t s = write(_sock, encodeTransmitPackage.c_str(), encodeTransmitPackage.size());
        if (s > 0)
        {
            std::string reveicePackage;
			while(true)
            {
                char buffer[1024];
                size_t s = read(_sock, buffer, sizeof(buffer) - 1);
                if (s <= 0) break;
                //写端读取成功
                buffer[s] = 0;
                reveicePackage +=buffer;
                response resp;
                uint32_t len = 0;
                std::cout << "debug->get response->\n" << reveicePackage << std::endl;
                //接收的响应包进行解码，并检查数据的完整性
                std::string decodeReveicePackage = decode(reveicePackage, &len); 
                if (len == 0) {continue;}
                //解码后的包序列化，将响应包封装为自定义的结构化数据（Response），填充resp属性
                resp.deserialize(decodeReveicePackage);
                printf("[exitcode: %d] %d\n", resp._exitCode, resp._result);、
            }
        }
        else 
        {
            break;
        }
    }
    close(_sock);  
}
```



# 三、HTTP

> HTTP (HyperText Transfer Protocol) 是互联网上用于传输web文档的标准协议。
>
> 它是一个应用层协议，通常运行在TCP/IP协议之上。
>
> http服务向指定的服务器申请特定的资源（音频、视频、图片），获取到本地进行展示或者使用
>
> 抓包工具：Progress Telerik Fiddler Web Debugger

## 3.1 **请求/响应模型**

### 3.1.1 客户端

> 客户端（通常是Web浏览器）发送一个HTTP请求到服务器。请求包含请求信息和可能包含本地信息等。

#### （1）请求格式

**1）请求行:**

- 方法：如GET、POST、PUT、DELETE等。
- 请求的URI：通常是URL的路径(\所指向的是web根目录)和查询字符串部分（例如搜索引擎的搜索内容）。
- 协议版本：如HTTP/1.1、HTTP/1.0。

例如：
```
GET /index.html HTTP/1.1
```

**2) 请求头部**:

> 这些是描述请求的元数据，头部需要添加正文的长度信息

例如：

```
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
```

**3) 空行**:

> 头部和正文之间的分隔。

**4) 请求正文**:

> 主要用于POST和PUT请求。它包含发送给服务器的数据，例如个人登录信息、上传的文件和图片等。

以下是完整的请求格式实例：

```c++
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
//...空行
//...正文
```



### 3.1.2 服务端

> 服务器根据该请求，发送回一个HTTP响应。响应包含状态信息和可能包含请求的内容。

#### （1）响应格式

**1) 状态行**:

- 协议版本：如HTTP/1.1。
- 状态码：如200、404等。
- 状态文本：如OK、Not Found等。

例如：

```
HTTP/1.1 200 OK
```

**2) 响应头部**:
描述响应的元数据。例如：

```
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache/2.2.14 (Win32)
Content-Length: 88
Content-Type: text/html
Connection: Closed
```

**3) 空行**

> 头部和正文之间的分隔。

**4) 响应正文**

> 返回给客户端的数据，例如HTML文档、图片或JSON数据。

以下是完整的响应格式实例：

```c++
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache/2.2.14 (Win32)
Content-Length: 88
Content-Type: text/html
//...空行
<html>
<body>
Hello, world!
</body>
</html>
```



## 3.2 URL和URI

> `URL`（Uniform Resource Locator）和`URI`（Uniform Resource Identifier）都是用于==标识资源的字符串==。它们之间存在细微但重要的差异。

### 3.2.1 URI (Uniform Resource Identifier)

> - URI是一个广泛的术语，用于标识任何类型的资源。
> - 所有URLs都是URIs，但并非所有的URIs都是URLs。
> - URI可以进一步细分为`URL`和`URN`（Uniform Resource Name）。
> - URI的一个例子（同时也是URL）是：`https://www.example.com/pages/index.html`
> - URI的一个例子（是URN但不是URL）是：`urn:isbn:0451450523`，这里`urn:isbn:`是命名空间，表示这是一个书籍的国际标准书号。
>

### 3.2.2 URL (Uniform Resource Locator)

> - ==URL是URI的一个子集==。
> - URL不仅标识资源，还提供了一种定位资源或在Internet上检索资源的手段。
> - 它通常包含以下部分：==协议(或称为方案)、域名(或IP地址)、端口号(可选的，常用的服务会自动添加)、路径和查询字符串==。
> - 例如，URL `https://www.example.com:8080/pages/index.html?search=query` 中：
>   - `https` 是协议或方案
>   - `www.example.com` 是域名
>   - `8080` 是端口号
>   - `/pages/index.html` 是路径，用于寻找服务器中特定的服务资源
>   - `search=query` 是查询字符串
> - URL总是表示资源的位置和检索方法。
>

## **3.3 HTTP方法**

> 网络行为：将远端资源拿到本地（GET）和将本地资源（属性字段）提交远端服务器(POST)
>

### 3.3.1 GET

> `GET`: 请求指定资源。GET请求应该只用于数据检索。
>
> GET会将参数==以明文的方式拼接到到URI中==

### 3.3.2 POST

> `POST`: 提交数据以便服务器处理。
>
> POST会将参数==以明文的方式拼接到请求正文中==
>
> 区别：传参方式、GET传参相对不私密、POST可以传入比较大的字段

### 3.3.3 其他方法

- `PUT`: 更新当前资源或创建新资源。
- `DELETE`: 删除指定资源。
- `HEAD`: 与GET类似，但只请求资源的头部。
- 其他方法还包括`OPTIONS`, `PATCH`, 和 `TRACE`。

## **3.4 状态码**

> 响应返回状态码以告知请求的状态。

- `2xx`：成功
- `3xx`：重定向
  - 临时重定向：版本更新或修复时采用的临时方案
  - 永久重定向：更换域名

- `4xx`：客户端错误（例如，404表示“未找到”）
- `5xx`：服务器错误

## 3.5 **HTTP头部**

> HTTP消息（请求和响应）都包含头部，头部包含了关于消息的元数据，例如`User-Agent`, `Accept-Type`, `Content-Type`等。
>
> http特性：无状态、无连接
>
> HTTP自身是无状态的，意味着服务器不会保存关于客户端的任何数据。但是，通常使用cookies在会话中跟踪状态。

### 3.5.1 Connection

#### （1）短链接(closed)

> 在HTTP/1.0中，每次请求和响应之后，连接都会关闭。

#### （2）持久链接（keep-alive）

> HTTP/1.1引入了持久连接（也称为连接保持），其中多个请求和响应可以在单个连接中发送，满足tcp底层多请求传输的需求。

### 3.5.2 Cookie

> 小块数据存储在用户的浏览器上，使服务器可以在多个请求之间识别用户。 
>
> 用于在客户端存储少量信息. 通常用于实现会话(session)的功能
>
> cookie是浏览器维护的文件（内存级、磁盘级），存在不安全的问题，可以采用cookie+session，认证时形成session文件，保存用户临时私密信息，文件名session_id通常具备唯一性，在服务器端维护，将session_id写入本地的cookie中
>

### 3.5.3 其他一些头部

> Location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; 
>
> Content-Type 数据类型(text/html等) 
>
> Content-Length: Body的长度 
>
> Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; 
>
> User-Agent: 声明用户的操作系统和浏览器版本信息; 
>
> Referer: 当前页面是从哪个页面跳转过来的;  



## 3.6 HTTP简单实现

```c++
std::string getPath(std::string request)
{
    std::size_t pos = request.find(CRLF);
    if(pos == std::string::npos) return "";
    std::string requestLine = request.substr(0, pos);
    std::size_t first = requestLine.find(SPACE);
    if(pos == std::string::npos) return "";
    std::size_t second = requestLine.rfind(SPACE);
    if(pos == std::string::npos) return "";
    std::string path = requestLine.substr(first+SPACE_LEN, second - (first+SPACE_LEN));
    //首页
    if(path.size() == 1 && path[0] == '/') path += HOME_PAGE;
    return path;
}

std::string readFile(const std::string &recource)
{
    std::ifstream in(recource, std::ifstream::binary);
    if(!in.is_open()) return "404";
    std::string content;
    std::string line;
    while(std::getline(in, line)) content += line;
    in.close();
    return content;
}
void handlerHttpRequest(int sock)
{
    char buffer[1024];
    ssize_t s = read(sock, buffer, sizeof buffer);
    if(s > 0) cout << buffer;
    std::string path = getPath(buffer);
    //web root
    std::string recource = ROOT_PATH;
    recource += path;
    std::cout << recource << std::endl;
    std::string html = readFile(recource);
    //去格式后缀
    std::size_t pos = recource.rfind(".");
    std::string suffix = recource.substr(pos);
    cout << suffix << endl;
    //开始响应
    std::string response;
    response = "HTTP/1.0 200 OK\r\n";
    if(suffix == ".jpg") response += "Content-Type: image/jpeg\r\n";
    else response += "Content-Type: text/html\r\n";
    response += ("Content-Length: " + std::to_string(html.size()) + "\r\n");
    response += "Set-Cookie: this is my cookie content;\r\n";
    response += "\r\n";
    response += html;
    send(sock, response.c_str(), response.size(), 0);
}
```



# 四、HTTPS

> HTTPS（全称：超文本传输协议安全，HyperText Transfer Protocol Secure）是一个用于安全通信的传输协议。它==在 HTTP 上增加了一个保护层，确保数据在传输过程中的安全性==。这一保护层由 SSL/TLS 协议提供。
>
> 特点：
>
> - **加密**：数据在传输过程中都会被加密，这样即使被拦截，数据也不能轻易地被解读。
> - **身份验证**：确保你访问的网站真的是你认为的那个网站，而不是一个假冒的网站。
> - **数据完整性**：确保数据在传输过程中不被篡改。

## 4.1 加密方式

### 4.1.1 对称加密

对称加密使用相同的密钥进行数据的加密和解密。这意味着加密方和解密方都必须拥有这个密钥，并且在安全通信前，双方必须以安全的方式共享这个密钥。

- **优点**：

  加密和解密速度快，适用于大量数据的加解密。

  算法简单，如AES（高级加密标准）和DES（数据加密标准）。

- **缺点**：

  密钥管理和分发。在每对通信双方都需要一个唯一的密钥时，随着参与者数量的增加，安全管理密钥变得越来越复杂。

  安全性依赖于密钥的保密性。如果密钥被泄露，加密的信息就可能被解密。

### 4.1.2 非对称加密

非对称加密，又称公钥加密，使用一对密钥：公钥和私钥。公钥可以公开，用于加密信息；私钥必须保密，用于解密信息。由于这两个密钥是数学上相关联的，使用公钥加密的信息只能用对应的私钥解密，反之亦然。

- **优点**：

  解决了密钥分发问题。公钥可以公开分享，而不影响通信的安全性。

  支持数字签名，验证信息来源和完整性。

- **缺点**：

  相比对称加密，非对称加密的计算过程更为复杂和缓慢，因此通常不适用于大量数据的加密。

  需要可靠的机制来验证公钥的真实性，防止中间人攻击。这通常通过使用数字证书和证书授权中心（CA）实现。

#### 具体流程

- **开始阶段**：首先，需要生成一对密钥。这通常通过使用非对称加密算法如RSA、ECC（椭圆曲线加密）等完成。生成的公钥可以与任何人共享，而私钥必须严格保密。

- **发送信息**：当某个发送者想要安全地发送信息给接收者时，他们会使用接收者的公钥对信息进行加密。由于公钥是公开的，任何人都可以使用它来加密信息，但只有持有对应私钥的接收者能解密这个信息。

- **公开通道**：加密后的信息可以通过不安全的公开通道（例如互联网）发送给接收者。由于信息已经加密，即便被拦截，没有私钥的人也无法解密这个信息。

- **接收信息**：接收者使用自己的私钥对收到的加密信息进行解密。由于私钥不与任何人共享，因此只有接收者能够解密和阅读原始信息。

#### 数字签名

非对称加密除了加密和解密信息外，还广泛用于数字签名：

- **创建签名**：发送者首先使用一个哈希函数计算信息的哈希值（摘要），然后用自己的私钥对这个哈希值进行加密，生成数字签名。签名随信息一起发送给接收者。
- **验证签名**：接收者收到信息和签名后，使用相同的哈希函数计算信息的哈希值，同时用发送者的公钥解密数字签名以获得哈希值。如果两个哈希值匹配，就证明信息在传输过程中未被篡改，并确认信息确实来自签名的发送者。

## 4.2 HTTPS加密方案

> 非对称加密+对称加密+证书认证

### (1)HTTPS 工作流程

HTTPS的工作流程是建立在TLS/SSL协议之上的，这是一种提供加密通信和数据完整性的安全协议。以下是HTTPS连接建立过程中的关键点，包括证书的验证和加密数据传输的详细解释：

#### 1. 服务器申请证书

为了建立HTTPS连接，服务器管理员首先需要向受信任的证书授权中心（CA）申请一个数字证书。这通常包括生成一对密钥：公钥和私钥。公钥不需要保密，而私钥必须严格保密。

#### 2. 服务器响应

当浏览器（客户端）请求建立HTTPS连接时，服务器会提供其数字证书作为响应。这个证书至少包含以下信息：
- 服务器的公钥
- 证书的有效期
- 证书的发行者（CA）
- 证书持有者（通常是服务器）的信息
- 数字签名

#### 3. 客户端验证证书

通过数据签名检测证书的完整性

- 数字签名是CA使用其私钥创建的，附加在证书上的。它基于证书的内容（不包括签名本身）。
- 客户端（浏览器）使用CA的公钥（浏览器已内置了受信任CA的公钥列表）来验证签名。如果签名验证成功，表明证书未被篡改，从而确保了证书的完整性。

其他验证步骤

- **检查CA**：浏览器检查证书是否由其信任的CA签发。
- **检查有效期**：浏览器检查证书是否在有效期内。
- **域名匹配**：浏览器检查证书中的域名是否与正在访问的网站域名匹配。

#### 4. 密钥交换

- 客户端生成一个随机数作为对称加密的密钥（会话密钥），然后用服务器的公钥加密这个密钥，并发送给服务器。

#### 5. 服务器解密

- 服务器使用自己的私钥解密收到的信息，获得会话密钥。此时，服务器和客户端都有了相同的会话密钥。

#### 6. 建立安全的会话

- 客户端和服务器使用会话密钥进行对称加密，确保通信过程中数据的机密性和完整性。

#### 7. 传输加密数据

- 所有通过HTTPS连接传输的数据都将使用这个会话密钥加密。这包括HTTP请求和响应数据，确保了数据传输过程中的安全。

这个过程不仅确保了数据传输的安全性，还通过证书验证确保了用户正在与预期的服务器通信，防止了中间人攻击。数字签名和会话密钥的使用是TLS/SSL协议核心安全特性的体现，保障了互联网通信的安全。

## （2）深刻理解加密

1. **非对称加密用于密钥交换**：客户端生成一个随机的对称加密密钥（称为会话密钥），然后使用服务器的公钥对这个会话密钥进行加密，并将其发送给服务器。只有服务器有对应的私钥，因此只有服务器能够解密得到这个会话密钥。
2. **对称加密用于数据传输**：一旦服务器和客户端都有了会话密钥，他们就使用这个密钥对后续通信的内容进行加密和解密。对称加密算法（如AES）用于这个阶段，因为它们在处理大量数据时比非对称加密算法更快更高效。

# 五、再谈端口号

> 传输层（Transport Layer）是计算机网络的 OSI 模型中的第四层，也是 TCP/IP 模型中的一个关键组件。传输层在网络中扮演着关键的角色，它负责端到端的通信服务。

## 5.1 端口号

> 端口号(Port)标识了一个主机上进行通信的不同的应用程序
>
> 在操作系统中用哈希表维护端口号到进程的唯一映射关系，但进程到端口号不一定唯一
>
> 端口号在传输层起到分用的功能，对上执行相应的进程

### 5.1.1 范围划分

> 0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的
>
> 1024 - 65535: 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的

### 5.1.2 知名端口号

> ssh服务器, 使用22端口 
>
> ftp服务器, 使用21端口 
>
> telnet服务器, 使用23端口 
>
> http服务器, 使用80端口 
>
> https服务器, 使用443

## 5.2 常用检测指令

### 5.2.1 netstat

> netstat是一个用来查看网络状态的重要工具. 
>
> 语法：netstat [选项]  
>
> 功能：查看网络状态  
>
> 常用选项： 
>
> - n 拒绝显示别名，能显示数字的全部转化成数字 
> - l 仅列出有在 Listen (监听) 的服務状态 
> - p 显示建立相关链接的程序名 
> - t (tcp)仅显示tcp相关选项 
> - u (udp)仅显示udp相关选项 
> - a (all)显示所有选项，默认不显示LISTEN相关

### 5.2.2 pidof

> 在查看服务器的进程id时非常方便. 
>
> 语法：pidof [进程名]  
>
> 功能：通过进程名, 查看进程id

# 五、UDP（User Datagram Protocol）

> 提供的是无连接、不可靠的通信服务。
>
> 这意味着数据==可能会丢失或到达的顺序与发送顺序不同==。但它的优势是低延迟和高效。
>
> 面向数据报，==不能够灵活的控制读写数据的次数和数量==
>
> 应用层交给UDP多长的报文, UDP原样发送, ==既不会拆分, 也不会合并==
>
> 对于一些可以容忍少量数据丢失的应用程序（如实时音视频流、VoIP、在线游戏），UDP 是个好选择。

## 1.UDP协议端格式

![image-20230822200811955](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230822200811955.png)

> 16位UDP长度, 表示整个数据报(UDP首部+UDP数据)的最大长度
>
> ==如果我们需要传输的数据超过64Kb（8KB）, 就需要在应用层手动的分包, 多次发送, 并在接收端手动拼装==
>
> ==如果校验和出错, 就会直接丢弃==

## 2.UDP报头

> UDP的报头非常简单，总共只有8个字节，方便解包。通过位段来实现
>
> 1. **源端口（Source Port） - 2字节**
>    这是发送方的端口号。对于诸如DNS这样的已知应用，此字段很重要。但对于某些应用程序，发送方可能不关心使用哪个端口，因此可能设置为零。
> 2. **目标端口（Destination Port） - 2字节**
>    这是接收方的端口号。这告诉接收方应该将数据报传递给哪个应用程序或服务。
> 3. **长度（Length） - 2字节**
>    ==这包括UDP报头和UDP数据的总长度。因为报头总是8个字节，所以最小值为8==。
> 4. **校验和（Checksum） - 2字节**
>    这是一个可选的字段，==用于检查UDP报头和数据的完整性==。如果未使用，则其值为零。

## 3.UDP缓冲区

> UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作; 
>
> UDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果缓冲区满了, 再到达的UDP数据就会被丢弃

## 4. 基于UDP的应用层协议

> NFS: 网络文件系统 
>
> TFTP: 简单文件传输协议 
>
> DHCP: 动态主机配置协议 
>
> BOOTP: 启动协议(用于无盘设备启动) 
>
> DNS: 域名解析协议



# 六、TCP

TCP全称为 "传输控制协议(Transmission Control Protocol")，对数据的传输进行一个详细的控制。

## 1.协议段格式

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230824195840638.png" alt="image-20230824195840638" style="zoom:50%;" />

> 源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去; 
>
> 首部长度: 表示该TCP报头有多少个32位bit(4bite)，所以TCP报头最大长度是15 * 4 = 60字节 ，并且最小是20字节
>
> 6位标志位: URG: 紧急指针是否有效
>
>  ==ACK: 确认序号是否有效==
>
> PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走 
>
> RST: 对方要求重新建立连接; 我们把携带RST标识的称为复位报文段 
>
> ==SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段==
>
> ==FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段== 
>
> 16位校验和: 发送端填充, CRC校验。接收端校验不通过, 则认为数据有问题。此处的检验和不光包含TCP首部, 也包含TCP数据部分。
>
> 16位紧急指针: 标识哪部分数据是紧急数据; 
>
> 40字节头部选项: 暂时忽略;

### （1）确认序号

发送缓冲区是由字符数组维护的（TCP面向字节流，每个数据占1字节），数据所对应的下标即他们的序号，发送的数据的序号属性字段都会被填充。

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230824201224366.png" alt="image-20230824201224366" style="zoom:50%;" />



确认序号属于一种对数据的应答，表示该确认序号前的数据都被接收，防止数据的丢失，形成了TCP的确认应答机制，也是其他机制的必要条件。

该属性字段不仅解决了丢包问题、对数据的乱序传输也可以通过对序号的排序进行解决，提高数据传输的可靠性。

### （2）窗口大小

**再次理解缓冲区：**

1. **缓冲区的基本作用**

- **临时存储**：缓冲区提供了临时数据存储的能力，在数据最终被发送到网络对端或由应用程序处理之前，它们被存储在缓冲区中。
- **数据拷贝**：`read()`、`write()`等IO操作实际上涉及将数据从应用程序缓冲区拷贝到内核缓冲区（写操作），或者从内核缓冲区拷贝到应用程序缓冲区（读操作）。

2. **发送和接收缓冲区**

- **发送缓冲区**：发送缓冲区存储待发送到网络的数据。当应用程序执行写操作时，数据首先被放置到发送缓冲区，等待TCP协议将其发送到网络上。
- **接收缓冲区**：接收缓冲区存储从网络接收的数据，直到应用程序准备好通过读操作来处理这些数据。接收缓冲区确保了即使应用程序暂时未准备好接收数据，数据也不会丢失。

3. **全双工通信**

TCP提供了全双工通信能力，意味着双方可以同时发送和接收数据。每一端的TCP连接都有自己的发送和接收缓冲区，这使得数据可以在两个方向上独立地流动和被控制。

4. **应用层对缓冲区的控制**

虽然操作系统和TCP协议负责管理缓冲区的大小及其数据的实际传输，应用程序可以通过各种机制来影响缓冲区的使用，例如：

- **缓冲区大小**：应用程序可以请求改变默认的缓冲区大小，以优化性能或资源使用。
- **阻塞与非阻塞IO**：应用程序可以根据需要选择使用阻塞或非阻塞IO，这影响了应用程序如何与缓冲区交互。
- **流控制**：通过适当地读取接收缓冲区或填充发送缓冲区，应用程序可以影响数据流的速率。

**窗口大小：**

TCP窗口大小是TCP协议流量控制机制的一个重要组成部分，它指定了在接收方发送下一个确认（ACK）之前发送方可以发送多少字节的数据。窗口大小的设置直接影响网络通信的效率和速度，是网络性能调优中的一个关键参数。

### （3） 保留（6位）

这些标志是TCP传输控制和管理连接的核心部分，决定了报文的类别。

**SYN（Synchronize）**

> - 表示该报文用于建立连接。
> - 当一个新的连接被初始化时，`SYN`标志被设置。

**FIN（Finish）**:

> - 表示该报文用于关闭连接。
> - 当一个方向上的数据传输完成时，`FIN`标志被设置，通知接收方不再有数据发送。

**ACK（Acknowledgment）**:

> - 表示该报文具有确认序列字段有效的作用。
> - 无论是在连接建立、数据传输还是连接终止的过程中，只要TCP报头中的确认号字段有效，`ACK`标志就会被设置，用于检查确认序列。

**PSH（Push）**:

> - 用于告诉接收端立即将数据传递给应用程序，而不是等待缓冲区填满。
> - 例如，当read（）读取条件不满足（接受数据的低水位线）时候，会被阻塞式等待，标志PSH，便于数据的快速到达。
> - 这通常用于确保数据及时到达，尤其是在交互式应用中，如Telnet。

**URG（Urgent）**:

> - 表示紧急指针字段有效。
> - 当`URG`标志被设置时，表示TCP段中有紧急数据，应当被快速处理。解决了因序列号导致的报文处理优先级一致的问题。
> - 紧急处理紧急指针偏移量处的数据（只有一个字节），一般用于获取机器的状态。

**RST（Reset）**:

> - 用于重置连接。
> - 当发生错误（ACK被窃取,超时响应等等）或接收到一个不预期的段时，`RST`标志可能会被设置，表示连接应该被立即终止并重置。
> - 它也可以用于拒绝非法的`SYN`请求或响应一个关闭的监听端口。

## 2 .TCP实现机制

### （1）确认应答机制

通过对方的应答来判断发送的消息是否收到，即确定是否丢包（收到应答则没丢包，没收到则不确定），用来解决丢包问题和数据顺序一致。

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230824201350480.png" alt="image-20230824201350480" style="zoom:50%;" />





### （2）超时重传机制

超时重传（Retransmission Timeout，RTO）是TCP协议中用来保证数据传输可靠性的核心机制之一。当预期的确认（ACK）没有在适当的时间内到达时，发送方会重新发送数据。这个机制涉及到两个主要场景：接收者的应答丢失或超时，以及发送者的数据丢失或超时。

**接收者应答丢失或超时**：发送方发送了数据，但是由于网络拥堵、路径变更、数据包丢失等原因，其对应的ACK没有返回或者超过了预定的时间限制。

**发送者数据丢失或超时**：发送方可能由于网络问题导致数据段丢失，或者数据段在网络中耗时太长而超时。

- **超时计时器**：当发送方发送数据段后，它启动一个超时计时器。如果在计时器到期之前没有收到对应数据段的ACK，发送方将重传该数据段。
- **动态超时时间**：TCP使用一种称为RTT（往返时间）测量的方法来动态计算超时时间。发送方根据历史RTT数据和其变化来调整超时时间，以适应网络条件的变化。
- **指数退避**：为了防止网络拥塞，每次超时重传后，TCP都会增加下一次的超时时间，通常是将超时时间翻倍，这称为指数退避。
- **数据重传**：当发送方检测到数据段丢失（通过超时或后续收到的ACK暗示的更高序列号），它会重传丢失的数据段。
- **去重策略**：接收方维护一个接收窗口来跟踪已经成功接收的数据段序列号。如果接收到重复的数据段，接收方会丢弃它，并发送一个ACK响应，指示当前期望接收的序列号。



### （3）连接管理机制

#### （1）再次理解三次握手、四次挥手

<img src="C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230824210345417.png" alt="image-20230824210345417" style="zoom:50%;" />

![image-20240403153522420](D:/%E7%AC%94%E8%AE%B0/C++/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240403153522420.png)

> tpc是面向连接的，由os进行管理，而维护需要成本，因此链接的建立可能由于SYN洪流导致链接失败，而三次握手让服务端和客户端共同承担SYN洪流，一定程度上避免SYN洪流的攻击，并且用最小成本的方式验证了全双工。

#### （2）全连接队列

> 监听接口listen的第二个参数backlog其实是底层的全连接队列的长度，表示在不accept的情况下，最多能获取n+1个链接
>
> 维护一个全连接队列，可以在服务器闲置状态下，从队列中获取链接，减少链接的丢失。
>
> 如果太长的话会影响客户体验，并且占用系统资源，降低服务器效率低下

#### （3）TIME_WAIT状态

> 即使四次挥手后连接被关闭，双方各自还需要等待一段时间（通常是几分钟），以确保网络中残留的任何数据包都能被丢弃。这个状态通常被称为“TIME_WAIT”。

#### （4）CLOSE_WAIT状态

> 当一个 TCP 连接在 CLOSE_WAIT 状态时，表示远程端（对端）已经关闭了连接，发送了一个 `FIN` 包，并等待本地系统的确认。
>
> 本地端接收到 `FIN` 包，并进入 `CLOSE_WAIT` 状态，意味着应用程序需要完成任何必要的清理工作，然后主动关闭连接。

### （4）滑动窗口

对每一个发送的数据段, 都要给一个ACK确认应答，收到ACK后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差， 尤其是数据往返的时间较长的时候。

发送方的发送的数据在无应答（发送成功、发送失败）的情况下，如果想实现超时重传，前提是应该在发送缓冲区中保留数据。

#### （1）发送缓冲区

![image-20230824211017402](C:\Users\40500\AppData\Roaming\Typora\typora-user-images\image-20230824211017402.png)

> 发送缓冲区分为三个区域，==收到应答、未收到应答、未发送==。
>
> 并且TCP的缓冲区被设计成环状结构（取模实现）。
>
> 收到应答，说明该区域可以被清空。
>
> 未收到应答，会超时重传提供数据。

#### （2）窗口

> 可以没有收到ACK情况下，直接发送的区域（未收到应答区域）。窗口的大小由接受方窗口大小字段确定。

#### （3）滑动

> 当发送端接收到数据的确认时，它将窗口向前滑动相应的数量，从而允许更多的数据被发送。
>
> 当收到ACK时，移动窗口的start、end下标索引，start=确认序号，end=start+窗口大小，窗口进行滑动。
>
> 窗口大小由对方的接受能力决定。
>
> 清空发送缓冲区的本质其实是滑动窗口的移动。

#### （4）丢包问题

> 可以克服部分ACK包丢失的情况。
>
> 对于数据包丢失，接收端可以连续发送的确认序号，可以采用高速重发控制（快重传）。

### （5）流量控制

> TCP根据接收端的能力来决定发送的速度。
>

### （6）拥塞控制

> 如果因为网络的软件问题（网络拥塞问题）出现大量丢包，则不能采用超时重传机制，只会导致网络更加拥塞，应该采用慢启动机制，数据由少到多慢慢递增。

#### （1）拥塞控制算法（递增策略）

> 指数增加，超过阈值后，变成线性增长，如果又遇到网络拥塞，重新指数增加，但阈值设为上一次的一半。

#### （2）发送数据的大小

> 发送数据的数量不仅要考虑对方接受数据的能力，还应该考虑网络拥塞。
>
> 滑动窗口=Min（窗口大小，网络拥塞窗口）。

### （7）延迟应答

> 如果收到数据后立刻应答，可能返回的窗口比较小，延迟一段时间，等待接收端从接收缓冲区取出数据，返回的窗口比较大，提高传输效率
>

### （8） 捎带应答

> 不论是客户端还是服务端，在应答时也可能想发送信息（ACK携带数据），而不是机器式的应答。
>
> 这也是需要同时用于序号、确认序号的原因。
>
> 提高了全双工数据传输的效率。

### （9） 面向字节流

> tcp面向字节流，不关心任何的数据格式，但是应用层的使用数据时，必须有特定的格式，进行特定的处理
>

#### （1）粘包问题

> 应用层无法从字节流区分一个完整的数据段，需要明确报文和报文的边界
>
> 而udp不存在粘包问题

## 3 .基于TCP应用层协议

> - HTTP 
> - HTTPS 
> - SSH 
> - Telnet 
> - FTP 
> - SMTP

## 4 .TCP异常

> 进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别. 
>
> 机器重启: 和进程终止的情况相同. 
>
> 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即 使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在, 也会把连接释放. 
>
> 另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会定期检测对方的状态. 例如QQ, 在QQ 断线之后, 也会定期尝试重新连接

## 5. udp和tcp

> TCP用于可靠传输的情况, 应用于文件传输, 重要状态更新等场景; 
>
> UDP用于对高速传输和实时性要求较高的通信领域, 例如, 早期的QQ, 视频传输等. 另外UDP可以用于广 播

### 6.5.1 tcp的优势来源

#### （1）可靠性

> - 校验和
> - 序列号(按序到达)/确认应答
> - 超时重发 
> - 连接管理 
> - 流量控制 
> - 拥塞控制

#### （2）提高性能

> - 滑动窗口
> -  快速重传
> -  延迟应答 
> - 捎带应答

### 6.5.2 用UDP实现可靠传输

> 利用TCP的控制机制。







































