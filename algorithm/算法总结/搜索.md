# 二、搜索

## 1.简介

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。

搜索是一些高级算法的基础。在 OI 中，纯粹的搜索往往也是得到部分分的手段，但可以通过纯粹的搜索拿到满分的题目非常少。

## 2.DFS（搜索）

### （1）引入

在搜索算法中，DFS通常指的是通过递归函数实现暴力枚举的算法，这在结构上与图论中的DFS算法相似，但并非完全相同。

这里的DFS依然保持“深度优先”的探索特点，即先探究一种可能性直到其最终结果，然后回溯至上一个决策点尝试另一种可能。

假设有一个问题：将正整数 $$n$$ 分解为3个不同的正整数的和，例如 $$6 = 1 + 2 + 3$$，且每一个数必须大于等于前一个数。要输出所有的分解方案。

如果不使用搜索技术，可以通过三重循环来解决问题：

```java
for (int i = 1; i < n + 1; i++) {
    for (int j = i; j < n + 1; j++) {
        for (int k = j; k < n + 1; k++) {
            if (i + j + k == n) System.out.printf("%d = %d + %d + %d%n", n, i, j, k);
        }
    }
}
```

如果要将数字分解为四个或更多个整数，仅仅增加更多的循环显然不是一个高效的解决方案，这时就需要考虑使用递归搜索。

### （2）DFS实现

该类搜索算法的特点在于将问题分为多个“层”，每层基于前几层的状态进行决策，直到达到目标状态。

例如，将正整数 $$n$$ 分解成小于等于 $$m$$ 个正整数之和，且后一个数至少与前一个数相等，输出所有方案。这可以通过递归的方式实现，每层决定一个整数部分，直至整个数被完全分解。

设一组方案将 $$n$$ 分解为 $$k$$ 个正整数 $$a_1, a_2, \ldots, a_k$$ 的和。我们在递归中记录三个状态变量：$$n - \sum_{j=1}^{i-1} a_j$$，即剩余未分配的和；$$a_{i-1}$$，即前一层的正整数，用于保证数的递增；和 $$i$$，即当前递归的深度，用于确保总数不超过 $$m$$。

为了记录方案，我们用 arr 数组，第 $$ i $$ 个表示 $$ a_i $$，注意到 arr 实际上是一个栈的概念。

递归搜索的Java实现代码如下：

```java
static int m;

// arr 用于记录方案
static int[] arr = new int[103];

//n：当前需要分解的数值。
//i：当前分解中的位置索引，即数组 arr 的索引。
//a：当前循环的起始数，保证递增。
public static void dfs(int n, int i, int a) {
    if (n == 0) {
        for (int j = 1; j <= i - 1; j++) System.out.printf("%d ", arr[j]);
        System.out.println();
    }
    if (i <= m) {
        for (int j = a; j <= n; ++j) {
            arr[i] = j;
            dfs(n - j, i + 1, j); 
        }
    }
}

// 主函数
final int N = new Scanner(System.in).nextInt();
m = new Scanner(System.in).nextInt();
dfs(N, 1, 1);
```

### （3）例题

华为od：

2024D-精准核酸检测（并查集）

2024D-生成哈夫曼树

2024D-可以组成网络的服务器

2024D-图像物体的边界

## 3.BFS（搜索）

### （1）简介

BFS 是图论中的一种遍历算法。

BFS 在搜索中也很常用，将每个状态对应为图中的一个点即可。

### （2）例题

华为od：

2024D-地图寻宝（BFS）

2024D-二叉树的广度优先遍历（DFS/BFS）

2024D-聚餐地点（BFS）

## 4.双向搜索

## 5.启发式搜索

## 6.A*

## 7.迭代加深搜索

## 8.IDA*

## 9.回溯法

### （1）简介

回溯法（Backtracking）是一种解决问题的算法，主要用于解决决策问题。它通过试探和回退的方式，逐步探索所有可能的解决方案，以找到所有或者特定的解。这种方法在深度优先搜索（DFS）和广度优先搜索（BFS）中尤为常见，尤其适用于解决组合、排列、分割等问题。

其核心思想是：“试错”——当探索到某一步时，发现当前方案不可行，则退回一步或几步，尝试其他可能的选项。

因此，它常被形象地描述为“走不通就回头”。

### （2）过程

1. **构造空间树**：首先定义问题的解空间，通常表现为树形结构，其中每个节点代表了解决方案中的一部分。
2. **进行遍历**：从根节点开始，按照深度优先搜索（DFS）的策略，探索每一条路径。
3. **边界条件判断**：在遍历过程中，如果遇到不满足条件的节点，就回退到上一步或者上几步，换一个分支继续探索。
4. **达到目标条件**：一旦找到一个解或者所有路径都探索完毕，算法结束。如果找到的是满足特定条件的解，则记录或输出结果。

### （3）例题

华为od：

2024D-表演赛游戏分组

2024D-找到它

## 10.Dancing Links

## 11.Alpha-Beta 剪枝

## 12.优化